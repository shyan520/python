[TOC]

# 前言

如何学习编写第一个程序，每个程序员都有不同的故事。我还是个孩子时就开始学习编程了，当时我父亲在计算时代的先锋之一——数字设备公司（Digital Equipment Corporation）工作。我使用一台简陋的计算机编写了第一个程序，这台计算机是父亲在家里的地下室组装而成的，它没有机箱，裸露的主板与键盘相连，显示器是裸露的阴极射线管。我编写的这个程序是一款简单的猜数字游戏，其输出类似于下面这样：

```
I'm thinking of a number! Try to guess the number I'm thinking of: 25
Too low! Guess again: 50
Too high! Guess again: 42
That's it! Would you like to play again? (yes/no) no
Thanks for playing! 
```

看到家人玩着我编写的游戏，而且它完全按我预期的方式运行，我心里不知有多满足。此情此景我永远都忘不了。

儿童时期的这种体验一直影响我至今。现在，每当我通过编写程序解决了一个问题时，心里都会感到非常满足。相比于孩提时期，我现在编写的软件满足了更大的需求，但通过编写程序获得的满足感几乎与从前一样。

## **读者对象**

本书旨在让你尽快学会 Python，以便能够编写能正确运行的程序——游戏、数据可视化和 Web 应用程序，同时掌握让你终身受益的基本编程知识。本书适合任何年龄的读者阅读，它不要求你有任何 Python 编程经验，甚至不要求你有编程经验。如果你想快速掌握基本的编程知识以便专注于开发感兴趣的项目，并想通过解决有意义的问题来检查你对新学概念的理解程度，那么本书就是为你编写的。本书还可供初中和高中教师用来通过开发项目向学生介绍编程。

## **本书内容**

本书旨在让你成为优秀的程序员，具体地说，是优秀的 Python 程序员。通过阅读本书，你将迅速掌握编程概念，打下坚实的基础，并养成良好的习惯。阅读本书后，你就可以开始学习 Python 高级技术，并能够更轻松地掌握其他编程语言。

在本书的第一部分，你将学习编写 Python 程序时需要熟悉的基本编程概念，你刚接触几乎任何编程语言时都需要学习这些概念。你将学习各种数据以及在程序中将数据存储到列表和字典中的方式。你将学习如何创建数据集合以及如何高效地遍历这些集合。你将学习使用`while`和`if`语句来检查条件，并在条件满足时执行代码的一部分，而在条件不满足时执行代码的另一部分——这可为自动完成处理提供极大的帮助。

你将学习获取用户输入，让程序能够与用户交互，并在用户没停止输入时保持运行状态。你将探索如何编写函数来让程序的各个部分可重用，这样你编写执行特定任务的代码后，想使用它多少次都可以。然后，你将学习使用类来扩展这种概念以实现更复杂的行为，从而让非常简单的程序也能处理各种不同的情形。你将学习编写妥善处理常见错误的程序。学习这些基本概念后，你就能编写一些简短的程序来解决一些明确的问题。最后，你将向中级编程迈出第一步，学习如何为代码编写测试，以便在进一步改进程序时不用担心可能引入 bug。第一部分介绍的知识让你能够开发更大、更复杂的项目。

在第二部分，你将利用在第一部分学到的知识来开发三个项目。你可以根据自己的情况，以最合适的顺序完成这些项目；你也可以选择只完成其中的某些项目。在第一个项目（第12~14章）中，你将创建一个类似于《太空入侵者》的射击游戏。这个游戏名为《外星人入侵》，它包含多个难度不断增加的等级。完成这个项目后，你就能够自己动手开发 2D 游戏了。

第二个项目（第15~17章）介绍数据可视化。数据科学家的目标是通过各种可视化技术来搞懂海量信息。你将使用通过代码生成的数据集、已经从网络下载下来的数据集以及程序自动下载的数据集。完成这个项目后，你将能够编写能对大型数据集进行筛选的程序，并以可视化方式将筛选出来的数据呈现出来。

在第三个项目（第18~20章）中，你将创建一个名为“学习笔记”的小型 Web 应用程序。这个项目能够让用户将学到的与特定主题相关的概念记录下来。你将能够分别记录不同的主题，还可以让其他人建立账户并开始记录自己的学习笔记。你还将学习如何部署这个项目，让任何人都能够通过网络访问它，而不管他身处何方。

## **为何使用 Python**

继续使用 Python，还是转而使用其他语言——也许是编程领域较新的语言？我每年都会考虑这个问题。可我依然专注于 Python，其中的原因很多。Python 是一种效率极高的语言：相比于众多其他的语言，使用 Python 编写时，程序包含的代码行更少。Python 的语法也有助于创建整洁的代码：相比其他语言，使用 Python 编写的代码更容易阅读、调试和扩展。

大家将 Python 用于众多方面：编写游戏、创建 Web 应用程序、解决商业问题以及供各类有趣的公司开发内部工具。Python 还在科学领域被大量用于学术研究和应用研究。

我依然使用 Python 的一个最重要的原因是，Python 社区有形形色色充满激情的人。对程序员来说，社区非常重要，因为编程绝非孤独的修行。大多数程序员都需要向解决过类似问题的人寻求建议，经验最为丰富的程序员也不例外。需要有人帮助解决问题时，有一个联系紧密、互帮互助的社区至关重要，而对于像你一样将 Python 作为第一门语言来学习的人而言，Python 社区无疑是坚强的后盾。

Python 是一门杰出的语言，值得你去学习，咱们现在就开始吧！

# 致谢

要是没有 No Starch Press 出色的专业人士的帮助，本书根本不可能出版。Bill Pollock 邀请我编写一本入门图书，因此这里要深深感谢他给予我这样的机会。Tyler Ortman 在我编写本书的早期帮助我理清思路。Liz Chadwick 和 Leslie Shen 详细阅读了每一章，并提出了宝贵的意见，而 Anne Marie Walker 让本书的很多地方都更清晰。Riley Hoffman 回答了我就图书出版过程提出的每个问题，并且耐心地将我的作品变成了漂亮的图书。

感谢技术审稿人 Kenneth Love。我与 Kenneth 相识于一次 PyCon 大会，他对 Python 和 Python 社区充满热情，一直是我获取专业灵感的源泉。Kenneth 不仅检查了本书介绍的知识是否正确，还抱着让初学编程者对 Python 语言和编程有扎实认识的目的进行了审阅。即便如此，倘若书中有任何不准确的地方，责任都完全由我承担。

感谢我的父亲，感谢他在我很小的时候就向我介绍编程，而且一点都不担心我破坏他的设备。感谢妻子 Erin 在我编写本书期间对我一如既往的鼓励和支持。还要感谢儿子 Ever，他的好奇心每天都会给我带来灵感。

------



# 第一部分　基础知识

本书的第一部分介绍编写 Python 程序所需要熟悉的基本概念，其中很多都适用于所有编程语言，因此它们在你的整个程序员生涯中都很有用。

第 1 章介绍在计算机中安装 Python，并运行第一个程序——它在屏幕上打印消息“Hello world!”。

第 2 章论述如何在变量中存储信息以及如何使用文本和数字。

第 3 章和第 4 章介绍列表。使用列表能够在一个变量中存储任意数量的信息，从而高效地处理数据：只需几行代码，你就能够处理数百、数千乃至数百万个值。

第 5 章讲解使用 if 语句来编写这样的代码：在特定条件满足时采取一种措施，而在该条件不满足时采取另一种措施。

第 6 章演示如何使用 Python 字典，将不同的信息关联起来。与列表一样，你也可以根据需要在字典中存储任意数量的信息。

第 7 章讲解如何从用户那里获取输入，以让程序变成交互式的。你还将学习 while 循环，它不断地运行代码块，直到指定的条件不再满足为止。

第 8 章介绍编写函数。函数是执行特定任务的被命名的代码块，你可以根据需要随时运行它。

第 9 章介绍类，它让你能够模拟实物，如小狗、小猫、人、汽车、火箭等，让你的代码能够表示任何真实或抽象的东西。

第 10 章介绍如何使用文件，以及如何处理错误以免程序意外地崩溃。你需要在程序关闭前保存数据，并在程序再次运行时读取它们。你将学习 Python 异常，它们让你能够未雨绸缪，从而让程序妥善地处理错误。

第 11 章为代码编写测试，以核实程序是否像你期望的那样工作。这样，扩展程序时，你就不用担心引入新的 bug。要想脱离初级程序员的阵容，跻身于中级程序员的行列，测试代码是你必须掌握的基本技能之一。

------



## 第1章　起步

### **老齐导读**

一定要访问 Python 官方网站[www.python.org](https://gitbook.cn/m/mazi/columns/5ce3cfab3481b33762ae04b6/topics/www.python.org)

书中介绍了不同操作系统的 Python 编程环境配置方法，同学按照书中讲述，基本可以完成。如果遇到问题了，可以用如下方式解决：

- 参考「前言」中推荐的有关资料
- 到网上去搜
- 如果已经按照书上的步骤把 Python 环境配置好了，请一定要记住，再向前走一步——配置环境变量。

关于 IDE，为了有更多的选择，我再推荐几个：

1. Python 自带的 IDLE。Python 环境安装之后，就自带了一个非常简单的编辑器。当然，这个仅供玩一玩使用了。如果真正的学习，乃至于将来工程上用，这个远远不够。
2. Vim 和 Emacs。一个被称为“编辑器之神”，另外一个称为“神的编辑器”。如果不了解，建议网上搜一下。我以前用 Vim，后来被年轻人策反了，改用 VScode。
3. VScode。这个是微软开源出来的，很好用。我现在就使用。<https://devblogs.microsoft.com/python/python-in-visual-studio-code-april-2019-release/>
4. 还有 Sublim，PyCharm 等，甚至于在 Java 中常用的 Eclipse 都是用的比较多的。

不管什么 IDE，选择一个，把它用的更称心应手。当然，如果将来做数据科学或者机器学习，更多的是使用 Jupyter。

本章知识导图如下。用椭圆标记的表示学习者可以拓展的部分，如果有兴趣可以通过相关资料拓展。

![enter image description here](https://images.gitbook.cn/b1e4e650-8b25-11e9-b6ad-75422f81aa28)

> 在本章中，你将运行自己的第一个程序——hello_world.py。为此，你首先需要检查自己的计算机是否安装了 Python；如果没有安装，你需要安装它。你还要安装一个文本编辑器，用于编写和运行 Python 程序。你输入 Python 代码时，这个文本编辑器能够识别它们并突出显示不同的部分，让你能够轻松地了解代码的结构。

### **1.1　搭建编程环境**

在不同的操作系统中，Python 存在细微的差别，因此有几点你需要牢记在心。这里将介绍大家使用的两个主要的 Python 版本，并简要介绍 Python 的安装步骤。

#### **1.1.1　Python 2 和 Python 3**

当前，有两个不同的 Python 版本：Python 2 和较新的 Python 3。每种编程语言都会随着新概念和新技术的推出而不断发展，Python 的开发者也一直致力于丰富和强化其功能。大多数修改都是逐步进行的，你几乎意识不到，但如果你的系统安装的是 Python 3，那么有些使用 Python 2 编写的代码可能无法正确地运行。在本书中，我将指出 Python 2 和 Python 3 的重大差别，这样无论你安装的是哪个 Python 版本，都能够按书中的说明去做。

如果你的系统安装了这两个版本，请使用 Python 3；如果没有安装 Python，请安装 Python 3；如果只安装了 Python 2，也可直接使用它来编写代码，但还是尽快升级到 Python 3 为好，因为这样你就能使用最新的 Python 版本了。

#### **1.1.2　运行 Python 代码片段**

Python 自带了一个在终端窗口中运行的解释器，让你无需保存并运行整个程序就能尝试运行 Python 代码片段。

本书将以如下方式列出代码片段：

```
❶ >>> print("Hello Python interpreter!")
Hello Python interpreter!
```

加粗的文本表示需要你输入之后按回车键来执行的代码。本书的大多数示例都是独立的小程序，你将在编辑器中执行它们，因为大多数代码都是这样编写出来的。然而，为高效地演示某基本概念，需要在 Python 终端会话中执行一系列代码片段。只要代码清单中包含三个尖括号（如❶所示），就意味着输出来自终端会话。稍后将演示如何在 Python 解释器中编写代码。

#### **1.1.3　Hello World 程序**

长期以来，编程界都认为刚接触一门新语言时，如果首先使用它来编写一个在屏幕上显示消息“Hello world!”的程序，将给你带来好运。

要使用 Python 来编写这种 Hello World 程序，只需一行代码：

```
print("Hello world!")
```

这种程序虽然简单，却有其用途：如果它能够在你的系统上正确地运行，你编写的任何 Python 程序都将如此。稍后将介绍如何在特定的系统中编写这样的程序。

### **1.2　在不同操作系统中搭建 Python 编程环境**

Python 是一种跨平台的编程语言，这意味着它能够运行在所有主要的操作系统中。在所有安装了 Python 的现代计算机上，都能够运行你编写的任何 Python 程序。然而，在不同的操作系统中，安装 Python 的方法存在细微的差别。

在这一节中，你将学习如何在自己的系统中安装 Python 和运行 Hello World 程序。你首先要检查自己的系统是否安装了 Python，如果没有，就安装它；接下来，你需要安装一个简单的文本编辑器，并创建一个空的 Python 文件——hello_world.py。最后，你将运行 Hello World 程序，并排除各种故障。我将详细介绍如何在各种操作系统中完成这些任务，让你能够搭建一个对初学者友好的 Python 编程环境。

#### **1.2.1　在 Linux 系统中搭建 Python 编程环境**

Linux 系统是为编程而设计的，因此在大多数 Linux 计算机中，都默认安装了 Python。编写和维护 Linux 的人认为，你很可能会使用这种系统进行编程，他们也鼓励你这样做。鉴于此，要在这种系统中编程，你几乎不用安装什么软件，也几乎不用修改设置。

**1. 检查 Python 版本**

在你的系统中运行应用程序 Terminal（如果你使用的是 Ubuntu，可按 Ctrl+Alt+T），打开一个终端窗口。为确定是否安装了 Python，执行命令`python`（请注意，其中的 p 是小写的）。输出将类似下面这样，它指出了安装的 Python 版本；最后的`>>>`是一个提示符，让你能够输入 Python 命令。

```
$ python
Python 2.7.6 (default, Mar 22 2014, 22:59:38)
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

上述输出表明，当前计算机默认使用的 Python 版本为 Python 2.7.6。看到上述输出后，如果要退出 Python 并返回到终端窗口，可按 Ctrl+D 或执行命令`exit()`。

要检查系统是否安装了 Python 3，可能需要指定相应的版本。换句话说，如果输出指出默认版本为 Python 2.7，请尝试执行命令`python3`：

```
$ python3
Python 3.5.0 (default, Sep 17 2015, 13:05:18)
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

上述输出表明，系统中也安装了 Python 3，因此你可以使用这两个版本中的任何一个。在这种情况下，请将本书中的命令`python`都替换为`python3`。大多数 Linux 系统都默认安装了 Python，但如果你的 Linux 系统不知什么原因没有安装 Python 或只安装了 Python 2，而你要安装 Python 3，请参见附录 A。

**2. 安装文本编辑器**

Geany 是一款简单的文本编辑器：它易于安装；让你能够直接运行几乎所有的程序（而无需通过终端来运行）；使用不同的颜色来显示代码，以突出代码语法；在终端窗口中运行代码，让你能够习惯使用终端。附录 B 介绍了其他一些文本编辑器，但我强烈建议你使用 Geany，除非你有充分的理由不这样做。

在大多数 Linux 系统中，都只需执行一个命令就可以安装 Geany：

```
$ sudo apt-get install geany
```

如果这个命令不管用，请参阅 <http://geany.org/Download/ThirdPartyPackages/>的说明。

**3. 运行 Hello World 程序**

为编写第一个程序，需要启动 Geany。为此，可按超级（Super）键（俗称 Windows 键），并在系统中搜索 Geany。找到 Geany 后，双击以启动它；再将其拖曳到任务栏或桌面上，以创建一个快捷方式。接下来，创建一个用于存储项目的文件夹，并将其命名为 python_work（在文件名和文件夹名中，最好使用小写字母，并使用下划线来表示空格，因为这是 Python 采用的命名约定）。回到 Geany，选择菜单 File ▶ Save As，将当前的空 Python 文件保存到文件夹 python_work，并将其命名为 hello_world.py。扩展名.py 告诉 Geany，文件包含的是 Python 程序；它还让 Geany 知道如何运行该程序，并以有益的方式突出其中的代码。

保存文件后，在其中输入下面一行代码：

```
print("Hello Python world!")
```

如果你的系统安装了多个 Python 版本，就必须对 Geany 进行配置，使其使用正确的版本。为此，可选择菜单 Build（生成）▶ Set Build Commands（设置生成命令）；你将看到文字 Compile（编译）和 Execute（执行），它们旁边都有一个命令。默认情况下，这两个命令都是`python`，要让 Geany 使用命令`python3`，必须做相应的修改。

如果在终端会话中能够执行命令`python3`，请修改编译命令和执行命令，让 Geany 使用 Python 3 解释器。为此，将编译命令修改成下面这样：

```
python3 -m py_compile "%f"
```

你必须完全按上面的代码显示的那样输出这个命令，确保空格和大小写都完全相同。

将执行命令修改成下面这样：

```
python3 "%f"
```

同样，务必确保空格和大小写都完全与显示的相同。图1-1显示了该如何在 Geany 中配置这些命令。

![{%}](http://www.ituring.com.cn/figures/2016/PythonProgramme/05.d01z.001.png)

**图1-1　在 Linux 中配置 Geany，使其使用 Python 3**

现在来运行程序 hello_world.py。为此，可选择菜单 Build ▶ Execute、单击 Execute 图标（两个齿轮）或按 F5。将弹出一个终端窗口，其中包含如下输出：

```
Hello Python world!

------------------
(program exited with code: 0)
Press return to continue
```

如果没有看到这样的输出，请检查你输入的每个字符。你是不是将`print`的首字母大写了？是不是遗漏了引号或括号？编程语言对语法的要求非常严格，只要你没有严格遵守语法，就会出错。如果代码都正确，这个程序也不能正确地运行，请参阅1.3节。

**4. 在终端会话中运行 Python 代码**

你可以打开一个终端窗口并执行命令`python`或`python3`，再尝试运行 Python 代码片段。检查 Python 版本时，你就这样做过。下面再次这样做，但在终端会话中输入如下代码行：

```
>>> print("Hello Python interpreter!")
Hello Python interpreter!
>>>
```

消息将直接打印到当前终端窗口中。别忘了，要关闭 Python 解释器，可按 Ctrl+D 或执行命令`exit()`。

#### **1.2.2　在 OS X 系统中搭建 Python 编程环境**

大多数 OS X 系统都默认安装了 Python。确定安装了 Python 后，你还需安装一个文本编辑器，并确保其配置正确无误。

**1. 检查是否安装了 Python**

在文件夹 Applications/Utilities 中，选择 Terminal，打开一个终端窗口；你也可以按 Command+空格键，再输入`terminal`并按回车。为确定是否安装了 Python，请执行命令`python`（注意，其中的 p 是小写的）。输出将类似于下面这样，它指出了安装的 Python 版本；最后的`>>>`是一个提示符，让你能够输入 Python 命令。

```
$ python
Python 2.7.5 (default, Mar 9 2014, 22:15:05)
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits", or "license" for more information.
>>>
```

上述输出表明，当前计算机默认使用的 Python 版本为 Python 2.7.5。看到上述输出后，如果要退出 Python 并返回到终端窗口，可按 Ctrl+D 或执行命令`exit()`。

要检查系统是否安装了 Python 3，可尝试执行命令`python3`。可能会出现一条错误消息，但如果输出指出系统安装了 Python 3，则无需安装就可使用它。如果在你的系统中能够执行命令`python3`，则对于本书的所有命令`python`，都请替换为命令`python3`。如果不知道出于什么原因你的系统没有安装 Python，或者只安装了 Python 2，而你又想安装 Python 3，请参阅附录 A。

**2. 在终端会话中运行 Python 代码**

你可以打开一个终端窗口并执行命令`python`或`python3`，再尝试运行 Python 代码片段。检查 Python 版本时，你就这样做过。下面再次这样做，但在终端会话中输入如下代码行：

```
>>> print("Hello Python interpreter!")
Hello Python interpreter!
>>>
```

消息将直接打印到当前终端窗口中。别忘了，要关闭 Python 解释器，可按 Ctrl+D 或执行命令`exit()`。

**3. 安装文本编辑器**

Sublime Text 是一款简单的文本编辑器：它在 OS X 中易于安装；让你能够直接运行几乎所有程序（而无需通过终端）；使用不同的颜色来显示代码，以突出代码语法；在内嵌在 Sublime Text 窗口内的终端会话中运行代码，让你能够轻松地查看输出。附录 B 介绍了其他一些文本编辑器，但我强烈建议你使用 Sublime Text，除非你有充分的理由不这样做。

要下载 Sublime Text 安装程序，可访问 <http://sublimetext.com/3>，单击 Download 链接，并查找 OS X 安装程序。Sublime Text 的许可策略非常灵活，你可以免费使用这款编辑器，但如果你喜欢它并想长期使用，建议你购买许可证。下载安装程序后，打开它，再将 Sublime Text 图标拖放到 Applications 文件夹。

**4. 配置 Sublime Text 使其使用 Python 3**

如果你启动 Python 终端会话时使用的命令不是`python`，就需要配置 Sublime Text，让它知道到系统的什么地方去查找正确的 Python 版本。要获悉 Python 解释器的完整路径，请执行如下命令：

```
$ type -a python3
python3 is /usr/local/bin/python3
```

现在，启动 Sublime Text，并选择菜单 Tools ▶ Build System ▶ New Build System，这将打开一个新的配置文件。删除其中的所有内容，再输入如下内容：

```
{
    "cmd": ["/usr/local/bin/python3", "-u", "$file"],
}
```

这些代码让 Sublime Text 使用命令`python3`来运行当前打开的文件。请确保其中的路径为你在前一步使用命令`type -a python3`获悉的路径。将这个配置文件命名为 Python3.sublime-build，并将其保存到默认目录——你选择菜单 Save 时 Sublime Text 打开的目录。

**5. 运行 Hello World 程序**

为编写第一个程序，需要启动 Sublime Text。为此，可打开文件夹 Applications，并双击图标 Sublime Text；也可按 Command+空格键，再在弹出的搜索框中输入 sublime text。

创建一个用于存储项目的文件夹，并将其命名为 python_work（在文件名和文件夹名中，最好使用小写字母，并使用下划线来表示空格，因为这是 Python 采用的命名约定）。在 Sublime Text 中，选择菜单 File ▶ Save As，将当前的空 Python 文件保存到文件夹 python_work，并将其命名为 hello_world.py。扩展名.py 告诉 Sublime Text，文件包含的是 Python 程序；它还让 Sublime Text 知道如何运行该程序，并以有益的方式突出其中的代码。

保存文件后，在其中输入下面一行代码：

```
print("Hello Python world!")
```

如果在系统中能够运行命令`python`，就可选择菜单 Tools ▶ Build 或按 Ctrl+B 来运行程序。如果你对 Sublime Text 进行了配置，使其使用的命令不是`python`，请选择菜单 Tools ▶ Build System，再选择 Python 3。这将把 Python 3 设置为默认使用的 Python 版本；此后，你就可选择菜单 Tools ▶ Build 或按 Command+B 来运行程序了。

Sublime Text 窗口底部将出现一个终端屏幕，其中包含如下输出：

```
Hello Python world!
[Finished in 0.1s]
```

如果没有看到这样的输出，请检查你输入的每个字符。你是不是将`print`的首字母大写了？是不是遗漏了引号或括号？编程语言对语法的要求非常严格，只要你没有严格遵守语法，就会出错。如果代码都正确，这个程序也不能正确地运行，请参阅1.3节。

#### **1.2.3　在 Windows 系统中搭建 Python 编程环境**

Windows 系统并非都默认安装了 Python，因此你可能需要下载并安装它，再下载并安装一个文本编辑器。

**1. 安装 Python**

首先，检查你的系统是否安装了 Python。为此，在“开始”菜单中输入`command`并按回车以打开一个命令窗口；你也可按住 Shift 键并右击桌面，再选择“在此处打开命令窗口”。在终端窗口中输入 python 并按回车；如果出现了 Python 提示符（`>>>`），就说明你的系统安装了 Python。然而，你也可能会看到一条错误消息，指出`python`是无法识别的命令。

如果是这样，就需要下载 Windows Python 安装程序。为此，请访问<http://python.org/downloads/>。你将看到两个按钮，分别用于下载 Python 3 和 Python 2。单击用于下载 Python 3 的按钮，这会根据你的系统自动下载正确的安装程序。下载安装程序后，运行它。请务必选中复选框 Add Python to PATH（如图1-2所示），这让你能够更轻松地配置系统。

![{%}](http://www.ituring.com.cn/figures/2016/PythonProgramme/05.d01z.002.png)

**图1-2　确保选中复选框 Add Python to PATH**

**2. 启动 Python 终端会话**

通过配置系统，让其能够在终端会话中运行 Python，可简化文本编辑器的配置工作。打开一个命令窗口，并在其中执行命令`python`。如果出现了 Python 提示符（`>>>`），就说明 Windows 找到了你刚安装的 Python 版本。

```
C:\> python
Python 3.5.0 (v3.5.0:374f501f4567, Sep 13 2015, 22:15:05) [MSC v.1900 32 bit
(Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

如果是这样，就可以直接跳到下一部分——“在终端会话中运行 Python”。

然而，输出可能类似于下面这样：

```
C:\> python
'python' is not recognized as an internal or external command, operable
program or batch file.
```

在这种情况下，你就必须告诉 Windows 如何找到你刚安装的 Python 版本。命令`python`通常存储在 C 盘，因此请在 Windows 资源管理器中打开 C 盘，在其中找到并打开以 Python 打头的文件夹，再找到文件 python。例如，在我的计算机中，有一个名为 Python35 的文件夹，其中有一个名为 python 的文件，因此文件 python 的路径为 C:\Python35\python。如果找不到这个文件，请在 Windows 资源管理器的搜索框中输入 python，这将让你能够准确地获悉命令`python`在系统中的存储位置。

如果认为已知道命令`python`的路径，就在终端窗口中输入该路径进行测试。为此，打开一个命令窗口，并输入你确定的完整路径：

```
C:\> C:\Python35\python
Python 3.5.0 (v3.5.0:374f501f4567, Sep 13 2015, 22:15:05) [MSC v.1900 32 bit
(Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

如果可行，就说明你已经知道如何访问 Python 了。

**3. 在终端会话中运行 Python**

在 Python 会话中执行下面的命令，并确认看到了输出“Hello Python world!”。

```
>>> print("Hello Python world!")
Hello Python world!
>>>
```

每当要运行 Python 代码片段时，都请打开一个命令窗口并启动 Python 终端会话。要关闭该终端会话，可按 Ctrl+Z，再按回车键，也可执行命令`exit()`。

**4. 安装文本编辑器**

Geany 是一款简单的文本编辑器：它易于安装；让你能够直接运行几乎所有的程序（而无需通过终端）；使用不同的颜色来显示代码，以突出代码语法；在终端窗口中运行代码，让你能够习惯使用终端。附录 B 介绍了其他一些文本编辑器，但我强烈建议你使用 Geany，除非你有充分的理由不这样做。

要下载 Windows Geany 安装程序，可访问 <http://geany.org/>，单击 Download 下的 Releases，找到安装程序 geany-1.25_setup.exe 或类似的文件。下载安装程序后，运行它并接受所有的默认设置。

为编写第一个程序，需要启动 Geany。为此，可按超级（Super）键（俗称 Windows 键），并在系统中搜索 Geany。找到 Geany 后，双击以启动它；再将其拖曳到任务栏或桌面上，以创建一个快捷方式。接下来，创建一个用于存储项目的文件夹，并将其命名为 python_work（在文件名和文件夹名中，最好使用小写字母，并使用下划线来表示空格，因为这是 Python 采用的命名约定）。回到 Geany，选择菜单 File ▶ Save As，将当前的空 Python 文件保存到文件夹 python_work，并将其命名为 hello_world.py。扩展名.py 告诉 Geany，文件包含的是 Python 程序；它还让 Geany 知道如何运行该程序，并以有益的方式突出其中的代码。

保存文件后，在其中输入下面一行代码：

```
print("Hello Python world!")
```

如果能够在系统中执行命令`python`，就无需配置 Geany，因此你可以跳过下一部分，直接进入“运行 Hello World程序”部分。如果启动 Python 解释器时必须指定路径，如 C:\Python35\python，请按下面的说明对 Geany 进行配置。

**5. 配置 Geany**

要配置 Geany，请选择菜单 Build ▶ Set Build Commands；你将看到文字 Compile 和 Execute，它们旁边都有一个命令。默认情况下，编译命令和执行命令的开头都是`python`，但 Geany 不知道命令`python`存储在系统的什么地方，因此你需要在其中添加你在终端会话中使用的路径。

为此，在编译命令和执行命令中，加上命令`python`所在的驱动器和文件夹。其中编译命令应类似于下面这样：

```
C:\Python35\python -m py_compile "%f"
```

在你的系统中，路径可能稍有不同，但请务必确保空格和大小写与这里显示的一致。

执行命令应类似于下面这样：

```
C:\Python35\python "%f"
```

同样，指定执行命令时，务必确保空格和大小写与这里显示的一致。图1-3显示了该如何在 Geany 中配置这些命令。

![{%}](http://www.ituring.com.cn/figures/2016/PythonProgramme/05.d01z.003.png)

**图1-3　在 Windows 中配置 Geany，使其使用 Python 3**

正确地设置这些命令后，单击 OK 按钮。

**6. 运行 Hello World 程序**

现在应该能够成功地运行程序了。请运行程序 hello_world.py；为此，可选择菜单 Build ▶ Execute、单击 Execute 图标（两个齿轮）或按 F5。将弹出一个终端窗口，其中包含如下输出：

```
Hello Python world!

------------------
(program exited with code: 0)
Press return to continue
```

如果没有看到这样的输出，请检查你输入的每个字符。你是不是将`print`的首字母大写了？是不是遗漏了引号或括号？编程语言对语法的要求非常严格，只要你没有严格遵守语法，就会出错。如果代码都正确，这个程序也不能正确地运行，请参阅下一节。

### **1.3　解决安装问题**

如果你按前面的步骤做，应该能够成功地搭建编程环境。但如果你始终无法运行程序 hello_world.py，可尝试如下几个解决方案。

- 程序存在严重的错误时，Python 将显示 traceback。Python 会仔细研究文件，试图找出其中的问题。traceback 可能会提供线索，让你知道是什么问题让程序无法运行。
- 离开计算机，先休息一会儿，再尝试。别忘了，在编程中，语法非常重要，即便是少一个冒号、引号不匹配或括号不匹配，都可能导致程序无法正确地运行。请再次阅读本章相关的内容，再次审视你所做的工作，看看能否找出错误。
- 推倒重来。你也许不需要把一切都推倒重来，但将文件 hello_world.py 删除并重新创建它也许是合理的选择。
- 让别人在你的计算机或其他计算机上按本章的步骤重做一遍，并仔细观察。你可能遗漏了一小步，而别人刚好没有遗漏。
- 请懂 Python 的人帮忙。当你有这样的想法时，可能会发现在你认识的人当中就有人使用 Python。
- 本章的安装说明在本书主页上：<http://www.ituring.com.cn/book/1861>。对你来说，在线版也许更合适。
- 到网上寻求帮助。附录 C 提供了很多在线资源，如论坛或在线聊天网站，你可以前往这些地方，请求解决过你面临的问题的人提供解决方案。

不要担心这会打扰经验丰富的程序员。每个程序员都遇到过问题，而大多数程序员都会乐意帮助你正确地设置系统。只要能清晰地说明你要做什么、尝试了哪些方法及其结果，就很可能有人能够帮到你。正如前言中指出的，Python 社区对初学者非常友好。

任何现代计算机都能够运行 Python，如果你遇到了困难，请想办法寻求帮助吧。前期的问题可能令人沮丧，但很值得你花时间去解决。能够运行 hello_world.py 后，你就可以开始学习 Python 了，而且编程工作会更有趣，也更令人愉快。

### **1.4　从终端运行 Python 程序**

你编写的大多数程序都将直接在文本编辑器中运行，但有时候，从终端运行程序很有用。例如，你可能想直接运行既有的程序。

在任何安装了 Python 的系统上都可以这样做，前提是你知道如何进入程序文件所在的目录。为尝试这样做，请确保已将文件 hello_world.py 存储到了桌面的 python_work 文件夹中。

#### **1.4.1　在 Linux 和 OS X 系统中从终端运行 Python 程序**

在 Linux 和 OS X 系统中，从终端运行 Python 程序的方式相同。在终端会话中，可使用终端命令`cd`（表示**切换目录**，change directory）在文件系统中导航。命令`ls`（list 的简写）显示当前目录中所有未隐藏的文件。

为运行程序 hello_world.py，请打开一个新的终端窗口，并执行下面的命令：

```
❶ ~> cd Desktop/python_work/
❷ ~/Desktop/python_work> ls
  hello_world.py
❸ ~/Desktop/python_work> python hello_world.py
  Hello Python world!
```

这里使用了命令`cd`来切换到文件夹 Desktop/python_work（见❶）。接下来，使用命令`ls`来确认这个文件夹中包含文件 hello_world.py（见❷）。最后，使用命令`python hello_world.py`来运行这个文件（见❸）。

就这么简单。要运行 Python 程序，只需使用命令`python`（或`python3`）即可。

#### **1.4.2　在 Windows 系统中从终端运行 Python 程序**

在命令窗口中，要在文件系统中导航，可使用终端命令`cd`；要列出当前目录中的所有文件，可使用命令`dir`（表示目录， directory）。

为运行程序 hello_world.py，请打开一个新的终端窗口，并执行下面的命令：

```
❶ C:\> cd Desktop\python_work
❷ C:\Desktop\python_work> dir
  hello_world.py
❸ C:\Desktop\python_work> python hello_world.py
  Hello Python world!
```

这里使用了命令`cd`来切换到文件夹 Desktop\python_work（见❶）。接下来，使用命令`dir`来确认这个文件夹中包含文件 hello_world.py（见❷）。最后，使用命令`python hello_world.py`来运行这个文件（见❸）。

如果你没有对系统进行配置以使用简单命令`python`，就可能需要指定这个命令的路径：

```
C:\$ cd Desktop\python_work
C:\Desktop\python_work$ dir
hello_world.py
C:\Desktop\python_work$ C:\Python35\python hello_world.py
Hello Python world!
```

大多数程序都可以直接从编辑器运行，但需要解决的问题比较复杂时，你编写的程序可能需要从终端运行。

> **动手试一试**
>
> 本章的练习都是探索性的，但从第2章开始将要求你用那一章学到的知识来解决问题。
>
> **1-1 python.org**：浏览 Python 主页（<http://python.org/>），寻找你感兴趣的主题。你对 Python 越熟悉，这个网站对你来说就越有用。
>
> **1-2 输入错误**：打开你刚创建的文件 hello_world.py，在代码中添加一个输入错误，再运行这个程序。输入错误会引发错误吗？你能理解显示的错误消息吗？你能添加一个不会导致错误的输入错误吗？你凭什么认为它不会导致错误？
>
> **1-3 无穷的技艺**：如果你编程技艺无穷，你打算开发什么样的程序呢？你就要开始学习编程了；如果心中有目标，就能立即将新学到的技能付诸应用；现在正是草拟目标的大好时机。将想法记录下来是个不错的习惯，这样每当需要开始新项目时，都可参考它们。现在请花点时间描绘三个你想创建的程序。

### **1.5　小结**

在本章中，你大致了解了 Python，并在自己的系统中安装了 Python。你还安装了一个文本编辑器，以简化 Python 代码的编写工作。你学习了如何在终端会话中运行 Python 代码片段，并运行了第一个货真价实的程序——hello_world.py。你还大致了解了如何解决安装问题。

在下一章，你将学习如何在 Python 程序中使用各种数据和变量。

------



## 第2章　变量和简单数据类型

### **老齐导读**

Python 中的数据类型，也可以说成是数据对象。这两种说法是根据不同传统来说的。

书中 2.2.1 中对 Python 中变量命名的规则，是重点，同学要特别注意理解。

字符串和数字，既是简单的数据类型（对象类型），也是组成以后其他类型对象的基础，并且是跟我们所使用的自然语言直接对应的。

建议你学习这部分内容的时候，一定要按照书中的描述，按部就班地敲代码，并且一边敲一边思考。书上的代码，都可以在交互模式中进行，对于学习而言，交互模式比较简单，并且能够直观看到结果（2.3.3 节的代码就是在交互模式中实现的）。

当把书上的代码敲完之后，在交互模式下执行如下操作：

```
>>> name = "hello"
>>> dir(name)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
```

然后用内置函数`help`查看上面列出的属性和方法的帮助文档。特别是书中提到的字符串的方法，然后根据文档的描述，理解书中的实现方式。

Python 语言的内置函数`dir`和`help`是非常好的学习助手，并且阅读官方文档，也是学习者从一开始就要逐渐学习并掌握的方法，这就是我在“前言”中所说的一种得“渔”之道。

![enter image description here](https://images.gitbook.cn/f02db660-8811-11e9-b1c9-d994bc31f268)

PS：导图橙色内容为相对本书中的拓展知识技能，有兴趣的读者可以深入研究。

> 在本章中，你将学习可在 Python 程序中使用的各种数据，还将学习如何将数据存储到变量中，以及如何在程序中使用这些变量。

### **2.1　运行 hello_world.py 时发生的情况**

运行 hello_world.py 时，Python 都做了些什么呢？下面来深入研究一下。实际上，即便是运行简单的程序，Python 所做的工作也相当多：

**hello_world.py**

```
print("Hello Python world!")
```

运行上述代码时，你将看到如下输出：

```
Hello Python world!
```

运行文件 hello_world.py 时，末尾的.py 指出这是一个 Python 程序，因此编辑器将使用 Python **解释器**来运行它。Python 解释器读取整个程序，确定其中每个单词的含义。例如，看到单词`print`时，解释器就会将括号中的内容打印到屏幕，而不会管括号中的内容是什么。

编写程序时，编辑器会以各种方式突出程序的不同部分。例如，它知道`print`是一个函数的名称，因此将其显示为蓝色；它知道“Hello Python world!”不是 Python 代码，因此将其显示为橙色。这种功能称为**语法突出**，在你刚开始编写程序时很有帮助。

### **2.2　变量**

下面来尝试在 hello_world.py 中使用一个变量。在这个文件开头添加一行代码，并对第2行代码进行修改，如下所示：

```
message = "Hello Python world!"
print(message)
```

运行这个程序，看看结果如何。你会发现，输出与以前相同：

```
Hello Python world!
```

我们添加了一个名为`message`的**变量**。每个变量都存储了一个**值**——与变量相关联的信息。在这里，存储的值为文本“Hello Python world!”。

添加变量导致 Python 解释器需要做更多工作。处理第1行代码时，它将文本“Hello Python world!”与变量`message`关联起来；而处理第2行代码时，它将与变量`message`关联的值打印到屏幕。

下面来进一步扩展这个程序：修改 hello_world.py，使其再打印一条消息。为此，在 hello_world.py 中添加一个空行，再添加下面两行代码：

```
message = "Hello Python world!"
print(message)

message = "Hello Python Crash Course world!"
print(message)
```

现在如果运行这个程序，将看到两行输出：

```
Hello Python world!
Hello Python Crash Course world!
```

在程序中可随时修改变量的值，而 Python 将始终记录变量的最新值。

#### **2.2.1　变量的命名和使用**

在 Python 中使用变量时，需要遵守一些规则和指南。违反这些规则将引发错误，而指南旨在让你编写的代码更容易阅读和理解。请务必牢记下述有关变量的规则。

- 变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为 message_1，但不能将其命名为 1_message。
- 变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名 greeting_message 可行，但变量名 greeting message 会引发错误。
- 不要将 Python 关键字和函数名用作变量名，即不要使用 Python 保留用于特殊用途的单词，如`print`（请参见附录 A.4）。
- 变量名应既简短又具有描述性。例如，name 比 n 好，student_name 比 s_n 好，name_length 比 length_of_persons_name 好。
- 慎用小写字母 l 和大写字母 O，因为它们可能被人错看成数字1和0。

要创建良好的变量名，需要经过一定的实践，在程序复杂而有趣时尤其如此。随着你编写的程序越来越多，并开始阅读别人编写的代码，将越来越善于创建有意义的变量名。

> **注意**　
>
> 就目前而言，应使用小写的 Python 变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意。

#### **2.2.2　使用变量时避免命名错误**

程序员都会犯错，而且大多数程序员每天都会犯错。虽然优秀的程序员也会犯错，但他们也知道如何高效地消除错误。下面来看一种你可能会犯的错误，并学习如何消除它。

我们将有意地编写一些引发错误的代码。请输入下面的代码，包括其中以粗体显示但拼写不正确的单词 mesage：

```
message = "Hello Python Crash Course reader!"
print(mesage)
```

程序存在错误时，Python 解释器将竭尽所能地帮助你找出问题所在。程序无法成功地运行时，解释器会提供一个 traceback。traceback 是一条记录，指出了解释器尝试运行代码时，在什么地方陷入了困境。下面是你不小心错误地拼写了变量名时，Python 解释器提供的 traceback：

```
  Traceback (most recent call last):
❶   File "hello_world.py", line 2, in <module>
❷     print(mesage)
❸ NameError: name 'mesage' is not defined
```

解释器指出，文件 hello_world.py 的第2行存在错误（见❶）；它列出了这行代码，旨在帮助你快速找出错误（见❷）；它还指出了它发现的是什么样的错误（见❸）。在这里，解释器发现了一个名称错误，并指出打印的变量`mesage`未定义：Python 无法识别你提供的变量名。名称错误通常意味着两种情况：要么是使用变量前忘记了给它赋值，要么是输入变量名时拼写不正确。

在这个示例中，第2行的变量名`message`中遗漏了字母 s。Python 解释器不会对代码做拼写检查，但要求变量名的拼写一致。例如，如果在代码的另一个地方也将 message 错误地拼写成了 mesage，结果将如何呢？

```
mesage = "Hello Python Crash Course reader!"
print(mesage)
```

在这种情况下，程序将成功地运行：

```
Hello Python Crash Course reader!
```

计算机一丝不苟，但不关心拼写是否正确。因此，创建变量名和编写代码时，你无需考虑英语中的拼写和语法规则。

很多编程错误都很简单，只是在程序的某一行输错了一个字符。为找出这种错误而花费很长时间的大有人在。很多程序员天资聪颖、经验丰富，却为找出这种细微的错误花费数小时。你可能觉得这很好笑，但别忘了，在你的编程生涯中，经常会有同样的遭遇。

> **注意**　
>
> 要理解新的编程概念，最佳的方式是尝试在程序中使用它们。如果你在做本书的练习时陷入了困境，请尝试做点其他的事情。如果这样做后依然无法摆脱困境，请复习相关内容。如果这样做后情况依然如故，请参阅附录 C 的建议。

> **动手试一试**
>
> 请完成下面的练习，在做每个练习时，都编写一个独立的程序。保存每个程序时，使用符合标准 Python 约定的文件名：使用小写字母和下划线，如 simple_message.py 和 simple_messages.py。
>
> **2-1 简单消息**：将一条消息存储到变量中，再将其打印出来。
>
> **2-2 多条简单消息**：将一条消息存储到变量中，将其打印出来；再将变量的值修改为一条新消息，并将其打印出来。

### **2.3　字符串**

大多数程序都定义并收集某种数据，然后使用它们来做些有意义的事情。鉴于此，对数据进行分类大有裨益。我们将介绍的第一种数据类型是字符串。字符串虽然看似简单，但能够以很多不同的方式使用它们。

**字符串**就是一系列字符。在 Python 中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号，如下所示：

```
"This is a string."
'This is also a string.'
```

这种灵活性让你能够在字符串中包含引号和撇号：

```
'I told my friend, "Python is my favorite language!"'
"The language 'Python' is named after Monty Python, not the snake."
"One of Python's strengths is its diverse and supportive community."
```

下面来看一些使用字符串的方式。

#### **2.3.1　使用方法修改字符串的大小写**

对于字符串，可执行的最简单的操作之一是修改其中的单词的大小写。请看下面的代码，并尝试判断其作用：

**name.py**

```
name = "ada lovelace"
print(name.title())
```

将这个文件保存为 name.py，再运行它。你将看到如下输出：

```
Ada Lovelace
```

在这个示例中，小写的字符串`"ada lovelace"`存储到了变量`name`中。在`print()`语句中，方法`title()`出现在这个变量的后面。**方法**是 Python 可对数据执行的操作。在`name.title()`中，`name`后面的句点（`.`）让 Python 对变量`name`执行方法`title()`指定的操作。每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。这种信息是在括号内提供的。函数`title()`不需要额外的信息，因此它后面的括号是空的。

`title()`以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。这很有用，因为你经常需要将名字视为信息。例如，你可能希望程序将值`Ada`、`ADA`和`ada`视为同一个名字，并将它们都显示为`Ada`。

还有其他几个很有用的大小写处理方法。例如，要将字符串改为全部大写或全部小写，可以像下面这样做：

```
name = "Ada Lovelace"
print(name.upper())
print(name.lower())
```

这些代码的输出如下：

```
ADA LOVELACE
ada lovelace
```

存储数据时，方法`lower()`很有用。很多时候，你无法依靠用户来提供正确的大小写，因此需要将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为最合适的大小写方式。

#### **2.3.2　合并（拼接）字符串**

在很多情况下，都需要合并字符串。例如，你可能想将姓和名存储在不同的变量中，等要显示姓名时再将它们合而为一：

```
  first_name = "ada"
  last_name = "lovelace"
❶ full_name = first_name + " " + last_name

  print(full_name)
```

Python 使用加号（`+`）来合并字符串。在这个示例中，我们使用`+`来合并`first_name`、空格和`last_name`，以得到完整的姓名（见❶），其结果如下：

```
ada lovelace
```

这种合并字符串的方法称为**拼接**。通过拼接，可使用存储在变量中的信息来创建完整的消息。下面来看一个例子：

```
   first_name = "ada"
   last_name = "lovelace"
   full_name = first_name + " " + last_name

❶ print("Hello, " + full_name.title() + "!")
```

在这里，一个问候用户的句子中使用了全名（见❶），并使用了方法`title()`来将姓名设置为合适的格式。这些代码显示一条格式良好的简单问候语：

```
Hello, Ada Lovelace!
```

你可以使用拼接来创建消息，再把整条消息都存储在一个变量中：

```
  first_name = "ada"
  last_name = "lovelace"
  full_name = first_name + " " + last_name

❶ message = "Hello, " + full_name.title() + "!"
❷ print(message)
```

上述代码也显示消息“Hello, Ada Lovelace!”，但将这条消息存储在了一个变量中（见❶），这让最后的`print`语句简单得多（见❷）。

#### **2.3.3　使用制表符或换行符来添加空白**

在编程中，**空白**泛指任何非打印字符，如空格、制表符和换行符。你可使用空白来组织输出，以使其更易读。

要在字符串中添加制表符，可使用字符组合`\t`，如下述代码的❶处所示：

```
  >>> print("Python")
  Python
❶ >>> print("\tPython")
      Python
```

要在字符串中添加换行符，可使用字符组合`\n`：

```
>>> print("Languages:\nPython\nC\nJavaScript")
Languages:
Python
C
JavaScript
```

还可在同一个字符串中同时包含制表符和换行符。字符串`"\n\t"`让 Python 换到下一行，并在下一行开头添加一个制表符。下面的示例演示了如何使用一个单行字符串来生成四行输出：

```
>>> print("Languages:\n\tPython\n\tC\n\tJavaScript")
Languages:
    Python
    C
    JavaScript
```

在接下来的两章中，你将使用为数不多的几行代码来生成很多行输出，届时制表符和换行符将提供极大的帮助。

#### **2.3.4　删除空白**

在程序中，额外的空白可能令人迷惑。对程序员来说，`'python'`和`'python '`看起来几乎没什么两样，但对程序来说，它们却是两个不同的字符串。Python 能够发现`'python '`中额外的空白，并认为它是有意义的——除非你告诉它不是这样的。

空白很重要，因为你经常需要比较两个字符串是否相同。例如，一个重要的示例是，在用户登录网站时检查其用户名。但在一些简单得多的情形下，额外的空白也可能令人迷惑。所幸在 Python 中，删除用户输入的数据中的多余的空白易如反掌。

Python 能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法`rstrip()`。

```
❶ >>> favorite_language = 'python '
❷ >>> favorite_language
  'python '
❸ >>> favorite_language.rstrip()
  'python'
❹ >>> favorite_language
  'python '
```

存储在变量`favorite_language`中的字符串末尾包含多余的空白（见❶）。你在终端会话中向 Python 询问这个变量的值时，可看到末尾的空格（见❷）。对变量`favorite_language`调用方法`rstrip()`后（见❸），这个多余的空格被删除了。然而，这种删除只是暂时的，接下来再次询问`favorite_language`的值时，你会发现这个字符串与输入时一样，依然包含多余的空白（见❹）。

要永久删除这个字符串中的空白，必须将删除操作的结果存回到变量中：

```
  >>> favorite_language = 'python '
❶ >>> favorite_language = favorite_language.rstrip()
  >>> favorite_language
  'python'
```

为删除这个字符串中的空白，你需要将其末尾的空白剔除，再将结果存回到原来的变量中（见❶）。在编程中，经常需要修改变量的值，再将新值存回到原来的变量中。这就是变量的值可能随程序的运行或用户输入数据而发生变化的原因。

你还可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法`lstrip()`和`strip()`：

```
❶ >>> favorite_language = ' python '
❷ >>> favorite_language.rstrip()
      ' python'
❸ >>> favorite_language.lstrip()
      'python '
❹ >>> favorite_language.strip()
      'python'
```

在这个示例中，我们首先创建了一个开头和末尾都有空白的字符串（见❶）。接下来，我们分别删除末尾（见❷）、开头（见❸）和两端（见❹）的空格。尝试使用这些剥除函数有助于你熟悉字符串操作。在实际程序中，这些剥除函数最常用于在存储用户输入前对其进行清理。

#### **2.3.5　使用字符串时避免语法错误**

**语法错误**是一种时不时会遇到的错误。程序中包含非法的 Python 代码时，就会导致语法错误。例如，在用单引号括起的字符串中，如果包含撇号，就将导致错误。这是因为这会导致 Python 将第一个单引号和撇号之间的内容视为一个字符串，进而将余下的文本视为 Python 代码，从而引发错误。

下面演示了如何正确地使用单引号和双引号。请将该程序保存为 apostrophe.py，再运行它：

**apostrophe.py**

```
message = "One of Python's strengths is its diverse community."
print(message)
```

撇号位于两个双引号之间，因此 Python 解释器能够正确地理解这个字符串：

```
One of Python's strengths is its diverse community.
```

然而，如果你使用单引号，Python 将无法正确地确定字符串的结束位置：

```
message = 'One of Python's strengths is its diverse community.'
print(message)
```

而你将看到如下输出：

```
  File "apostrophe.py", line 1
    message = 'One of Python's strengths is its diverse community.'
                            ^❶
SyntaxError: invalid syntax
```

从上述输出可知，错误发生在第二个单引号后面（见❶）。这种**语法错误**表明，在解释器看来，其中的有些内容不是有效的 Python 代码。错误的来源多种多样，这里指出一些常见的。学习编写 Python 代码时，你可能会经常遇到语法错误。语法错误也是最不具体的错误类型，因此可能难以找出并修复。受困于非常棘手的错误时，请参阅附录 C 提供的建议。

> **注意**　
>
> 编写程序时，编辑器的语法突出功能可帮助你快速找出某些语法错误。看到 Python 代码以普通句子的颜色显示，或者普通句子以 Python 代码的颜色显示时，就可能意味着文件中存在引号不匹配的情况。

#### **2.3.6　Python 2 中的 print 语句**

在 Python 2 中，`print`语句的语法稍有不同：

```
> python2.7
>>> print "Hello Python 2.7 world!"
Hello Python 2.7 world!
```

在 Python 2 中，无需将要打印的内容放在括号内。从技术上说，Python 3 中的`print`是一个函数，因此括号必不可少。有些 Python 2 `print`语句也包含括号，但其行为与 Python 3 中稍有不同。简单地说，在 Python 2 代码中，有些`print`语句包含括号，有些不包含。

> **动手试一试**
>
> 在做下面的每个练习时，都编写一个独立的程序，并将其保存为名称类似于 name_cases.py 的文件。如果遇到了困难，请休息一会儿或参阅附录 C 提供的建议。
>
> **2-3 个性化消息**：将用户的姓名存到一个变量中，并向该用户显示一条消息。显示的消息应非常简单，如“Hello Eric, would you like to learn some Python today?”。
>
> **2-4 调整名字的大小写**：将一个人名存储到一个变量中，再以小写、大写和首字母大写的方式显示这个人名。
>
> **2-5 名言**：找一句你钦佩的名人说的名言，将这个名人的姓名和他的名言打印出来。输出应类似于下面这样（包括引号）：
>
> Albert Einstein once said, “A person who never made a mistake never tried anything new.”
>
> **2-6 名言2**：重复练习2-5，但将名人的姓名存储在变量`famous_person`中，再创建要显示的消息，并将其存储在变量`message`中，然后打印这条消息。
>
> **2-7 剔除人名中的空白**：存储一个人名，并在其开头和末尾都包含一些空白字符。务必至少使用字符组合`"\t"`和`"\n"`各一次。
>
> 打印这个人名，以显示其开头和末尾的空白。然后，分别使用剔除函数`lstrip()`、`rstrip()`和`strip()`对人名进行处理，并将结果打印出来。

### **2.4　数字**

在编程中，经常使用数字来记录游戏得分、表示可视化数据、存储 Web 应用信息等。Python 根据数字的用法以不同的方式处理它们。鉴于整数使用起来最简单，下面就先来看看 Python 是如何管理它们的。

#### **2.4.1　整数**

在 Python 中，可对整数执行加（`+`）减（`-`）乘（`*`）除（`/`）运算。

```
>>> 2 + 3
5
>>> 3 - 2
1
>>> 2 * 3
6
>>> 3 / 2
1.5
```

在终端会话中，Python 直接返回运算结果。Python 使用两个乘号表示乘方运算：

```
>>> 3 ** 2
9
>>> 3 ** 3
27
>>> 10 ** 6
1000000
```

Python 还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修改运算次序，让 Python 按你指定的次序执行运算，如下所示：

```
>>> 2 + 3*4
14
>>> (2 + 3) * 4
20
```

在这些示例中，空格不影响 Python 计算表达式的方式，它们的存在旨在让你阅读代码时，能迅速确定先执行哪些运算。

#### **2.4.2　浮点数**

Python 将带小数点的数字都称为**浮点数**。大多数编程语言都使用了这个术语，它指出了这样一个事实：小数点可出现在数字的任何位置。每种编程语言都须细心设计，以妥善地处理浮点数，确保不管小数点出现在什么位置，数字的行为都是正常的。

从很大程度上说，使用浮点数时都无需考虑其行为。你只需输入要使用的数字，Python 通常都会按你期望的方式处理它们：

```
>>> 0.1 + 0.1
0.2
>>> 0.2 + 0.2
0.4
>>> 2 * 0.1
0.2
>>> 2 * 0.2
0.4
```

但需要注意的是，结果包含的小数位数可能是不确定的：

```
>>> 0.2 + 0.1
0.30000000000000004
>>> 3 * 0.1
0.30000000000000004
```

所有语言都存在这种问题，没有什么可担心的。Python 会尽力找到一种方式，以尽可能精确地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。就现在而言，暂时忽略多余的小数位数即可；在第二部分的项目中，你将学习在需要时处理多余小数位的方式。

#### **2.4.3　使用函数 str() 避免类型错误**

你经常需要在消息中使用变量的值。例如，假设你要祝人生日快乐，可能会编写类似于下面的代码：

**birthday.py**

```
age = 23
message = "Happy " + age + "rd Birthday!"

print(message)
```

你可能认为，上述代码会打印一条简单的生日祝福语：Happy 23rd birthday!。但如果你运行这些代码，将发现它们会引发错误：

```
  Traceback (most recent call last):
    File "birthday.py", line 2, in <module>
      message = "Happy " + age + "rd Birthday!"
❶ TypeError: Can't convert 'int' object to str implicitly
```

这是一个**类型错误**，意味着 Python 无法识别你使用的信息。在这个示例中，Python 发现你使用了一个值为整数（`int`）的变量，但它不知道该如何解读这个值（见❶）。Python 知道，这个变量表示的可能是数值23，也可能是字符2和3。像上面这样在字符串中使用整数时，需要显式地指出你希望 Python 将这个整数用作字符串。为此，可调用函数`str()`，它让 Python 将非字符串值表示为字符串：

```
age = 23
message = "Happy " + str(age) + "rd Birthday!"

print(message)
```

这样，Python 就知道你要将数值23转换为字符串，进而在生日祝福消息中显示字符2和3。经过上述处理后，将显示你期望的消息，而不会引发错误：

```
Happy 23rd Birthday!
```

大多数情况下，在 Python 中使用数字都非常简单。如果结果出乎意料，请检查 Python 是否按你期望的方式将数字解读为了数值或字符串。

#### **2.4.4　Python 2 中的整数**

在 Python 2 中，将两个整数相除得到的结果稍有不同：

```
>>> python2.7
>>> 3 / 2
1
```

Python 返回的结果为1，而不是1.5。在 Python 2 中，整数除法的结果只包含整数部分，小数部分被删除。请注意，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。

在 Python 2 中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为浮点数：

```
>>> 3 / 2
1
>>> 3.0 / 2
1.5
>>> 3 / 2.0
1.5
>>> 3.0 / 2.0
1.5
```

从 Python 3 转而用 Python 2 或从 Python 2 转而用 Python 3 时，这种除法行为常常会令人迷惑。使用或编写同时使用浮点数和整数的代码时，一定要注意这种异常行为。

> **动手试一试**
>
> **2-8 数字8**：编写4个表达式，它们分别使用加法、减法、乘法和除法运算，但结果都是数字8。为使用`print`语句来显示结果，务必将这些表达式用括号括起来，也就是说，你应该编写4行类似于下面的代码：
>
> ```
> print(5 + 3)
> ```
>
> 输出应为4行，其中每行都只包含数字8。
>
> **2-9 最喜欢的数字**：将你最喜欢的数字存储在一个变量中，再使用这个变量创建一条消息，指出你最喜欢的数字，然后将这条消息打印出来。

### **2.5　注释**

在大多数编程语言中，注释都是一项很有用的功能。本书前面编写的程序中都只包含 Python 代码，但随着程序越来越大、越来越复杂，就应在其中添加说明，对你解决问题的方法进行大致的阐述。**注释**让你能够使用自然语言在程序中添加说明。

#### **2.5.1　如何编写注释**

在 Python 中，注释用井号（`#`）标识。井号后面的内容都会被 Python 解释器忽略，如下所示：

**comment.py**

```
# 向大家问好
print("Hello Python people!")
```

Python 解释器将忽略第1行，只执行第2行。

```
Hello Python people!
```

#### **2.5.2　该编写什么样的注释**

编写注释的主要目的是阐述代码要做什么，以及是如何做的。在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了。当然，你总是可以通过研究代码来确定各个部分的工作原理，但通过编写注释，以清晰的自然语言对解决方案进行概述，可节省很多时间。

要成为专业程序员或与其他程序员合作，就必须编写有意义的注释。当前，大多数软件都是合作编写的，编写者可能是同一家公司的多名员工，也可能是众多致力于同一个开源项目的人员。训练有素的程序员都希望代码中包含注释，因此你最好从现在开始就在程序中添加描述性注释。作为新手，最值得养成的习惯之一是，在代码中编写清晰、简洁的注释。

如果不确定是否要编写注释，就问问自己，找到合理的解决方案前，是否考虑了多个解决方案。如果答案是肯定的，就编写注释对你的解决方案进行说明吧。相比回过头去再添加注释，删除多余的注释要容易得多。从现在开始，本书的示例都将使用注释来阐述代码的工作原理。

> **动手试一试**
>
> **2-10 添加注释**：选择你编写的两个程序，在每个程序中都至少添加一条注释。如果程序太简单，实在没有什么需要说明的，就在程序文件开头加上你的姓名和当前日期，再用一句话阐述程序的功能。

### **2.6　Python 之禅**

编程语言 Perl 曾在互联网领域长期占据着统治地位，早期的大多数交互式网站使用的都是 Perl 脚本。彼时，“解决问题的办法有多个”被 Perl 社区奉为座右铭。这种理念一度深受大家的喜爱，因为这种语言固有的灵活性使得大多数问题都有很多不同的解决之道。在开发项目期间，这种灵活性是可以接受的，但大家最终认识到，过于强调灵活性会导致大型项目难以维护：要通过研究代码搞清楚当时解决复杂问题的人是怎么想的，既困难又麻烦，还会耗费大量的时间。

经验丰富的程序员倡导尽可能避繁就简。Python 社区的理念都包含在 Tim Peters 撰写的“Python 之禅”中。要获悉这些有关编写优秀 Python 代码的指导原则，只需在解释器中执行命令`import this`。这里不打算赘述整个“Python 之禅”，而只与大家分享其中的几条原则，让你明白为何它们对 Python 新手来说至关重要。

```
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
```

Python 程序员笃信代码可以编写得漂亮而优雅。编程是要解决问题的，设计良好、高效而漂亮的解决方案都会让程序员心生敬意。随着你对 Python 的认识越来越深入，并使用它来编写越来越多的代码，有一天也许会有人站在你后面惊呼：“哇，代码编写得真是漂亮！”

```
Simple is better than complex.
```

如果有两个解决方案，一个简单，一个复杂，但都行之有效，就选择简单的解决方案吧。这样，你编写的代码将更容易维护，你或他人以后改进这些代码时也会更容易。

```
Complex is better than complicated.
```

现实是复杂的，有时候可能没有简单的解决方案。在这种情况下，就选择最简单可行的解决方案吧。

```
Readability counts.
```

即便是复杂的代码，也要让它易于理解。开发的项目涉及复杂代码时，一定要为这些代码编写有益的注释。

```
There should be one-- and preferably only one --obvious way to do it.
```

如果让两名 Python 程序员去解决同一个问题，他们提供的解决方案应大致相同。这并不是说编程没有创意空间，而是恰恰相反！然而，大部分编程工作都是使用常见解决方案来解决简单的小问题，但这些小问题都包含在更庞大、更有创意空间的项目中。在你的程序中，各种具体细节对其他 Python 程序员来说都应易于理解。

```
Now is better than never.
```

你可以将余生都用来学习 Python 和编程的纷繁难懂之处，但这样你什么项目都完不成。不要企图编写完美无缺的代码；先编写行之有效的代码，再决定是对其做进一步改进，还是转而去编写新代码。

等你进入下一章，开始研究更复杂的主题时，务必牢记这种简约而清晰的理念。如此，经验丰富的程序员定将对你编写的代码心生敬意，进而乐意向你提供反馈，并与你合作开发有趣的项目。

> **动手试一试**
>
> **2-11 Python 之禅**：在 Python 终端会话中执行命令`import this`，并粗略地浏览一下其他的指导原则。

### **2.7　小结**

在本章中，你学习了：如何使用变量；如何创建描述性变量名以及如何消除名称错误和语法错误；字符串是什么，以及如何使用小写、大写和首字母大写方式显示字符串；使用空白来显示整洁的输出，以及如何剔除字符串中多余的空白；如何使用整数和浮点数；使用数值数据时需要注意的意外行为。你还学习了如何编写说明性注释，让代码对你和其他人来说更容易理解。最后，你了解了让代码尽可能简单的理念。

在第3章，你将学习如何在被称为**列表**的变量中存储信息集，以及如何通过遍历列表来操作其中的信息。

------



## 第3章　列表简介

### **老齐导读**

列表是 Python 中很重要的一种对象类型。本章是对列表的初步介绍。

3.1 节中介绍“列表是什么”，其中第一句话值得同学牢记：“列表由一系列按特定顺序排列的元素组成”。为了便于理解，我把这句话分解如下：

“元素”——这句话没有特别限定元素是什么，那么可以理解为所有的 Python 对象都可以作为列表中的元素。所以，读者按照后面的代码操作时，不妨自己尝试一下列表中元素不是字符串和数字的情况，比如：[range, [], [1,2]]。

“特定顺序”——说明列表中的元素是具有顺序的，这就可以引出后面关于列表的索引和切片。

根据本章内容敲完代码之后，请按照下图方式，总结本章重点内容，并参阅推荐书籍做适当拓展。

![enter image description here](https://images.gitbook.cn/0585db20-8815-11e9-b6f4-77ea8c81f44e)

PS：导图橙色内容为相对本书中的拓展知识技能，有兴趣的同学可以深入研究。

> 在本章和下一章中，你将学习列表是什么以及如何使用列表元素。列表让你能够在一个地方存储成组的信息，其中可以只包含几个元素，也可以包含数百万个元素。列表是新手可直接使用的最强大的 Python 功能之一，它融合了众多重要的编程概念。

### **3.1　列表是什么**

**列表**由一系列按特定顺序排列的元素组成。你可以创建包含字母表中所有字母、数字 0~9 或所有家庭成员姓名的列表；也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如`letters`、`digits`或`names`）是个不错的主意。

在 Python 中，用方括号（`[]`）来表示列表，并用逗号来分隔其中的元素。下面是一个简单的列表示例，这个列表包含几种自行车：

**bicycles.py**

```
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
print(bicycles)
```

如果你让 Python 将列表打印出来，Python 将打印列表的内部表示，包括方括号：

```
['trek', 'cannondale', 'redline', 'specialized']
```

鉴于这不是你要让用户看到的输出，下面来学习如何访问列表元素。

#### **3.1.1　访问列表元素**

列表是有序集合，因此要访问列表的任何元素，只需将该元素的位置或索引告诉 Python 即可。要访问列表元素，可指出列表的名称，再指出元素的索引，并将其放在方括号内。

例如，下面的代码从列表`bicycles`中提取第一款自行车：

```
  bicycles = ['trek', 'cannondale', 'redline', 'specialized']
❶ print(bicycles[0])
```

❶处演示了访问列表元素的语法。当你请求获取列表元素时，Python 只返回该元素，而不包括方括号和引号：

```
trek
```

这正是你要让用户看到的结果——整洁、干净的输出。

你还可以对任何列表元素调用第2章介绍的字符串方法。例如，可使用方法`title()`让元素`'trek'`的格式更整洁：

```
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
print(bicycles[0].title())
```

这个示例的输出与前一个示例相同，只是首字母 T 是大写的。

#### **3.1.2　索引从0而不是1开始**

在 Python 中，第一个列表元素的索引为0，而不是1。在大多数编程语言中都是如此，这与列表操作的底层实现相关。如果结果出乎意料，请看看你是否犯了简单的差一错误。

第二个列表元素的索引为1。根据这种简单的计数方式，要访问列表的任何元素，都可将其位置减1，并将结果作为索引。例如，要访问第四个列表元素，可使用索引3。

下面的代码访问索引`1`和`3`处的自行车：

```
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
print(bicycles[1])
print(bicycles[3])
```

这些代码返回列表中的第二个和第四个元素：

```
cannondale
specialized
```

Python 为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为`-1`，可让 Python 返回最后一个列表元素：

```
bicycles = ['trek', 'cannondale', 'redline', 'specialized']
print(bicycles[-1])
```

这些代码返回`'specialized'`。这种语法很有用，因为你经常需要在不知道列表长度的情况下访问最后的元素。这种约定也适用于其他负数索引，例如，索引`-2`返回倒数第二个列表元素，索引`-3`返回倒数第三个列表元素，以此类推。

#### **3.1.3　使用列表中的各个值**

可像使用其他变量一样使用列表中的各个值。例如，你可以使用拼接根据列表中的值来创建消息。

下面来尝试从列表中提取第一款自行车，并使用这个值来创建一条消息：

```
  bicycles = ['trek', 'cannondale', 'redline', 'specialized']
❶ message = "My first bicycle was a " + bicycles[0].title() + "."

  print(message)
```

我们使用`bicycles[0]`的值生成了一个句子，并将其存储在变量`message`中（见❶）。输出是一个简单的句子，其中包含列表中的第一款自行车：

```
My first bicycle was a Trek.
```

> **动手试一试**
>
> 请尝试编写一些简短的程序来完成下面的练习，以获得一些使用 Python 列表的第一手经验。你可能需要为每章的练习创建一个文件夹，以整洁有序的方式存储为完成各章的练习而编写的程序。
>
> **3-1 姓名**：将一些朋友的姓名存储在一个列表中，并将其命名为`names`。依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来。
>
> **3-2 问候语**：继续使用练习3-1中的列表，但不打印每个朋友的姓名，而为每人打印一条消息。每条消息都包含相同的问候语，但抬头为相应朋友的姓名。
>
> **3-3 自己的列表**：想想你喜欢的通勤方式，如骑摩托车或开汽车，并创建一个包含多种通勤方式的列表。根据该列表打印一系列有关这些通勤方式的宣言，如“I would like to own a Honda motorcycle”。

### **3.2　修改、添加和删除元素**

你创建的大多数列表都将是动态的，这意味着列表创建后，将随着程序的运行增删元素。例如，你创建一个游戏，要求玩家射杀从天而降的外星人；为此，可在开始时将一些外星人存储在列表中，然后每当有外星人被射杀时，都将其从列表中删除，而每次有新的外星人出现在屏幕上时，都将其添加到列表中。在整个游戏运行期间，外星人列表的长度将不断变化。

#### **3.2.1　修改列表元素**

修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。

例如，假设有一个摩托车列表，其中的第一个元素为`'honda'`，如何修改它的值呢？

**motorcycles.py**

```
❶ motorcycles = ['honda', 'yamaha', 'suzuki']
  print(motorcycles)

❷ motorcycles[0] = 'ducati'
  print(motorcycles)
```

我们首先定义一个摩托车列表，其中的第一个元素为`'honda'`（见❶）。接下来，我们将第一个元素的值改为`'ducati'`（见❷）。输出表明，第一个元素的值确实变了，但其他列表元素的值没变：

```
['honda', 'yamaha', 'suzuki']
['ducati', 'yamaha', 'suzuki']
```

你可以修改任何列表元素的值，而不仅仅是第一个元素的值。

#### **3.2.2　在列表中添加元素**

你可能出于众多原因要在列表中添加新元素，例如，你可能希望游戏中出现新的外星人、添加可视化数据或给网站添加新注册的用户。Python 提供了多种在既有列表中添加新数据的方式。

**1. 在列表末尾添加元素**

在列表中添加新元素时，最简单的方式是将元素附加到列表末尾。给列表附加元素时，它将添加到列表末尾。继续使用前一个示例中的列表，在其末尾添加新元素`'ducati'`：

```
  motorcycles = ['honda', 'yamaha', 'suzuki']
  print(motorcycles)

❶ motorcycles.append('ducati')
  print(motorcycles)
```

方法`append()`将元素`'ducati'`添加到了列表末尾（见❶ ），而不影响列表中的其他所有元素：

```
['honda', 'yamaha', 'suzuki']
['honda', 'yamaha', 'suzuki', 'ducati']
```

方法`append()`让动态地创建列表易如反掌，例如，你可以先创建一个空列表，再使用一系列的`append()`语句添加元素。下面来创建一个空列表，再在其中添加元素`'honda'`、`'yamaha'`和`'suzuki'`：

```
motorcycles = []

motorcycles.append('honda')
motorcycles.append('yamaha')
motorcycles.append('suzuki')

print(motorcycles)
```

最终的列表与前述示例中的列表完全相同：

```
['honda', 'yamaha', 'suzuki']
```

这种创建列表的方式极其常见，因为经常要等程序运行后，你才知道用户要在程序中存储哪些数据。为控制用户，可首先创建一个空列表，用于存储用户将要输入的值，然后将用户提供的每个新值附加到列表中。

**2. 在列表中插入元素**

使用方法`insert()`可在列表的任何位置添加新元素。为此，你需要指定新元素的索引和值。

```
  motorcycles = ['honda', 'yamaha', 'suzuki']

❶ motorcycles.insert(0, 'ducati')
  print(motorcycles)
```

在这个示例中，值`'ducati'`被插入到了列表开头（见❶）；方法`insert()`在索引`0`处添加空间，并将值`'ducati'`存储到这个地方。这种操作将列表中既有的每个元素都右移一个位置：

```
['ducati', 'honda', 'yamaha', 'suzuki']
```

#### **3.2.3　从列表中删除元素**

你经常需要从列表中删除一个或多个元素。例如，玩家将空中的一个外星人射杀后，你很可能要将其从存活的外星人列表中删除；当用户在你创建的 Web 应用中注销其账户时，你需要将该用户从活跃用户列表中删除。你可以根据位置或值来删除列表中的元素。

**1. 使用del语句删除元素**

如果知道要删除的元素在列表中的位置，可使用`del`语句。

```
  motorcycles = ['honda', 'yamaha', 'suzuki']
  print(motorcycles)

❶ del motorcycles[0]
  print(motorcycles)
```

❶ 处的代码使用`del`删除了列表`motorcycles`中的第一个元素——`'honda'`：

```
['honda', 'yamaha', 'suzuki']
['yamaha', 'suzuki']
```

使用`del`可删除任何位置处的列表元素，条件是知道其索引。下例演示了如何删除前述列表中的第二个元素——`'yamaha'`：

```
motorcycles = ['honda', 'yamaha', 'suzuki']
print(motorcycles)

del motorcycles[1]
print(motorcycles)
```

下面的输出表明，已经将第二款摩托车从列表中删除了：

```
['honda', 'yamaha', 'suzuki']
['honda', 'suzuki']
```

在这两个示例中，使用`del`语句将值从列表中删除后，你就无法再访问它了。

**2. 使用方法pop()删除元素**

有时候，你要将元素从列表中删除，并接着使用它的值。例如，你可能需要获取刚被射杀的外星人的 *x* 和 *y* 坐标，以便在相应的位置显示爆炸效果；在 Web 应用程序中，你可能要将用户从活跃成员列表中删除，并将其加入到非活跃成员列表中。

方法`pop()`可删除列表末尾的元素，并让你能够接着使用它。术语**弹出**（pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。

下面从列表`motorcycles`中弹出一款摩托车：

```
❶ motorcycles = ['honda', 'yamaha', 'suzuki']
  print(motorcycles)

❷ popped_motorcycle = motorcycles.pop()
❸ print(motorcycles)
❹ print(popped_motorcycle)
```

我们首先定义并打印了列表`motorcycles`（见❶）。接下来，我们从这个列表中弹出一个值，并将其存储到变量`popped_motorcycle`中（见❷）。然后我们打印这个列表，以核实从其中删除了一个值（见❸）。最后，我们打印弹出的值，以证明我们依然能够访问被删除的值（见❹）。

输出表明，列表末尾的值`'suzuki'`已删除，它现在存储在变量`popped_motorcycle`中：

```
['honda', 'yamaha', 'suzuki']
['honda', 'yamaha']
suzuki
```

方法`pop()`是怎么起作用的呢？假设列表中的摩托车是按购买时间存储的，就可使用方法`pop()`打印一条消息，指出最后购买的是哪款摩托车：

```
motorcycles = ['honda', 'yamaha', 'suzuki']

last_owned = motorcycles.pop()
print("The last motorcycle I owned was a " + last_owned.title() + ".")
```

输出是一个简单的句子，指出了最新购买的是哪款摩托车：

```
The last motorcycle I owned was a Suzuki.
```

**3. 弹出列表中任何位置处的元素**

实际上，你可以使用`pop()`来删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可。

```
  motorcycles = ['honda', 'yamaha', 'suzuki']

❶ first_owned = motorcycles.pop(0)
❷ print('The first motorcycle I owned was a ' + first_owned.title() + '.')
```

首先，我们弹出了列表中的第一款摩托车（见❶），然后打印了一条有关这辆摩托车的消息（见❷）。输出是一个简单的句子，描述了我购买的第一辆摩托车：

```
The first motorcycle I owned was a Honda.
```

别忘了，每当你使用`pop()`时，被弹出的元素就不再在列表中了。

如果你不确定该使用`del`语句还是`pop()`方法，下面是一个简单的判断标准：如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用`del`语句；如果你要在删除元素后还能继续使用它，就使用方法`pop()`。

**4. 根据值删除元素**

有时候，你不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使用方法`remove()`。

例如，假设我们要从列表`motorcycles`中删除值`'ducati'`。

```
  motorcycles = ['honda', 'yamaha', 'suzuki', 'ducati']
  print(motorcycles)

❶ motorcycles.remove('ducati')
  print(motorcycles)
```

❶ 处的代码让 Python 确定`'ducati'`出现在列表的什么地方，并将该元素删除：

```
['honda', 'yamaha', 'suzuki', 'ducati']
['honda', 'yamaha', 'suzuki']
```

使用`remove()`从列表中删除元素时，也可接着使用它的值。下面删除值`'ducati'`，并打印一条消息，指出要将其从列表中删除的原因：

```
❶ motorcycles = ['honda', 'yamaha', 'suzuki', 'ducati']
  print(motorcycles)

❷ too_expensive = 'ducati'
❸ motorcycles.remove(too_expensive)
  print(motorcycles)
❹ print("\nA " + too_expensive.title() + " is too expensive for me.")
```

在❶处定义列表后，我们将值`'ducati'`存储在变量`too_expensive`中（见❷）。接下来，我们使用这个变量来告诉 Python 将哪个值从列表中删除（见❸）。最后，值`'ducati'`已经从列表中删除，但它还存储在变量`too_expensive`中（见❹），让我们能够打印一条消息，指出将`'ducati'`从列表`motorcycles`中删除的原因：

```
['honda', 'yamaha', 'suzuki', 'ducati']
['honda', 'yamaha', 'suzuki']

A Ducati is too expensive for me.
```

> **注意**　
>
> 方法`remove()`只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。你将在第7章学习如何这样做。

> **动手试一试**
>
> 下面的练习比第2章的练习要复杂些，但让你有机会以前面介绍过的各种方式使用列表。
>
> **3-4 嘉宾名单**：如果你可以邀请任何人一起共进晚餐（无论是在世的还是故去的），你会邀请哪些人？请创建一个列表，其中包含至少3个你想邀请的人；然后，使用这个列表打印消息，邀请这些人来与你共进晚餐。
>
> **3-5 修改嘉宾名单**：你刚得知有位嘉宾无法赴约，因此需要另外邀请一位嘉宾。
>
> - 以完成练习3-4时编写的程序为基础，在程序末尾添加一条`print`语句，指出哪位嘉宾无法赴约。
> - 修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。
> - 再次打印一系列消息，向名单中的每位嘉宾发出邀请。
>
> **3-6 添加嘉宾**：你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。
>
> - 以完成练习3-4或练习3-5时编写的程序为基础，在程序末尾添加一条`print`语句，指出你找到了一个更大的餐桌。
> - 使用`insert()`将一位新嘉宾添加到名单开头。
> - 使用`insert()`将另一位新嘉宾添加到名单中间。
> - 使用`append()`将最后一位新嘉宾添加到名单末尾。
> - 打印一系列消息，向名单中的每位嘉宾发出邀请。
>
> **3-7 缩减名单**：你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。
>
> - 以完成练习3-6时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息。
> - 使用`pop()`不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐。
> - 对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列。
> - 使用`del`将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的。

### **3.3　组织列表**

在你创建的列表中，元素的排列顺序常常是无法预测的，因为你并非总能控制用户提供数据的顺序。这虽然在大多数情况下都是不可避免的，但你经常需要以特定的顺序呈现信息。有时候，你希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python 提供了很多组织列表的方式，可根据具体情况选用。

#### **3.3.1　使用方法 sort() 对列表进行永久性排序**

Python 方法`sort()`让你能够较为轻松地对列表进行排序。假设你有一个汽车列表，并要让其中的汽车按字母顺序排列。为简化这项任务，我们假设该列表中的所有值都是小写的。

**cars.py**

```
  cars = ['bmw', 'audi', 'toyota', 'subaru']
❶ cars.sort()
  print(cars)
```

方法`sort()`（见❶）永久性地修改了列表元素的排列顺序。现在，汽车是按字母顺序排列的，再也无法恢复到原来的排列顺序：

```
['audi', 'bmw', 'subaru', 'toyota']
```

你还可以按与字母顺序相反的顺序排列列表元素，为此，只需向`sort()`方法传递参数`reverse=True`。下面的示例将汽车列表按与字母顺序相反的顺序排列：

```
cars = ['bmw', 'audi', 'toyota', 'subaru']
cars.sort(reverse=True)
print(cars)
```

同样，对列表元素排列顺序的修改是永久性的：

```
['toyota', 'subaru', 'bmw', 'audi']
```

#### **3.3.2　使用函数 sorted() 对列表进行临时排序**

要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数`sorted()`。函数`sorted()`让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。

下面尝试对汽车列表调用这个函数。

```
  cars = ['bmw', 'audi', 'toyota', 'subaru']

❶ print("Here is the original list:")
  print(cars)

❷ print("\nHere is the sorted list:")
  print(sorted(cars))

❸ print("\nHere is the original list again:")
  print(cars)
```

我们首先按原始顺序打印列表（见❶），再按字母顺序显示该列表（见❷）。以特定顺序显示列表后，我们进行核实，确认列表元素的排列顺序与以前相同（见❸）。

```
  Here is the original list:
  ['bmw', 'audi', 'toyota', 'subaru']

  Here is the sorted list:
  ['audi', 'bmw', 'subaru', 'toyota']

❹ Here is the original list again:
  ['bmw', 'audi', 'toyota', 'subaru']
```

注意，调用函数`sorted()`后，列表元素的排列顺序并没有变（见❹）。如果你要按与字母顺序相反的顺序显示列表，也可向函数`sorted()`传递参数`reverse=True`。

> **注意**　
>
> 在并非所有的值都是小写时，按字母顺序排列列表要复杂些。决定排列顺序时，有多种解读大写字母的方式，要指定准确的排列顺序，可能比我们这里所做的要复杂。然而，大多数排序方式都基于本节介绍的知识。

#### **3.3.3　倒着打印列表**

要反转列表元素的排列顺序，可使用方法`reverse()`。假设汽车列表是按购买时间排列的，可轻松地按相反的顺序排列其中的汽车：

```
cars = ['bmw', 'audi', 'toyota', 'subaru']
print(cars)

cars.reverse()
print(cars)
```

注意，`reverse()`不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序：

```
['bmw', 'audi', 'toyota', 'subaru']
['subaru', 'toyota', 'audi', 'bmw']
```

方法`reverse()`永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用`reverse()`即可。

#### **3.3.4　确定列表的长度**

使用函数`len()`可快速获悉列表的长度。在下面的示例中，列表包含4个元素，因此其长度为4：

```
>>> cars = ['bmw', 'audi', 'toyota', 'subaru']
>>> len(cars)
4
```

在你需要完成如下任务时，`len()`很有用：确定还有多少个外星人未被射杀，需要管理多少项可视化数据，网站有多少注册用户等。

> **注意**　
>
> Python 计算列表元素数时从1开始，因此确定列表长度时，你应该不会遇到差一错误。

> **动手试一试**
>
> **3-8 放眼世界**：想出至少5个你渴望去旅游的地方。
>
> - 将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的。
> - 按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始 Python 列表。
> - 使用`sorted()`按字母顺序打印这个列表，同时不要修改它。
> - 再次打印该列表，核实排列顺序未变。
> - 使用`sorted()`按与字母顺序相反的顺序打印这个列表，同时不要修改它。
> - 再次打印该列表，核实排列顺序未变。
> - 使用`reverse()`修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了。
> - 使用`reverse()`再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序。
> - 使用`sort()`修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了。
> - 使用`sort()`修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了。
>
> **3-9 晚餐嘉宾**：在完成练习3-4~练习3-7时编写的程序之一中，使用`len()`打印一条消息，指出你邀请了多少位嘉宾来与你共进晚餐。
>
> **3-10 尝试使用各个函数**：想想可存储到列表中的东西，如山岳、河流、国家、城市、语言或你喜欢的任何东西。编写一个程序，在其中创建一个包含这些元素的列表，然后，对于本章介绍的每个函数，都至少使用一次来处理这个列表。

### **3.4　使用列表时避免索引错误**

刚开始使用列表时，经常会遇到一种错误。假设你有一个包含三个元素的列表，却要求获取第四个元素：

```
motorcycles = ['honda', 'yamaha', 'suzuki']
print(motorcycles[3])
```

这将导致**索引错误**：

```
Traceback (most recent call last):
  File "motorcycles.py", line 3, in <module>
    print(motorcycles[3])
IndexError: list index out of range
```

Python 试图向你提供位于索引3处的元素，但它搜索列表`motorcycles`时，却发现索引3处没有元素。鉴于列表索引差一的特征，这种错误很常见。有些人从1开始数，因此以为第三个元素的索引为3；但在 Python 中，第三个元素的索引为2，因为索引是从0开始的。

索引错误意味着 Python 无法理解你指定的索引。程序发生索引错误时，请尝试将你指定的索引减1，然后再次运行程序，看看结果是否正确。

别忘了，每当需要访问最后一个列表元素时，都可使用索引`-1`。这在任何情况下都行之有效，即便你最后一次访问列表后，其长度发生了变化：

```
motorcycles = ['honda', 'yamaha', 'suzuki']
print(motorcycles[-1])
```

索引`-1`总是返回最后一个列表元素，这里为值`'suzuki'`：

```
'suzuki'
```

仅当列表为空时，这种访问最后一个元素的方式才会导致错误：

```
motorcycles = []
print(motorcycles[-1])
```

列表`motorcycles`不包含任何元素，因此 Python 返回一条索引错误消息：

```
Traceback (most recent call last):
  File "motorcyles.py", line 3, in <module>
    print(motorcycles[-1])
IndexError: list index out of range
```

> **注意**　
>
> 发生索引错误却找不到解决办法时，请尝试将列表或其长度打印出来。列表可能与你以为的截然不同，在程序对其进行了动态处理时尤其如此。通过查看列表或其包含的元素数，可帮助你找出这种逻辑错误。

> **动手试一试**
>
> **3-11 有意引发错误**：如果你还没有在程序中遇到过索引错误，就尝试引发一个这种错误。在你的一个程序中，修改其中的索引，以引发索引错误。关闭程序前，务必消除这个错误。

### **3.5　小结**

在本章中，你学习了：列表是什么以及如何使用其中的元素；如何定义列表以及如何增删元素；如何对列表进行永久性排序，以及如何为展示列表而进行临时排序；如何确定列表的长度，以及在使用列表时如何避免索引错误。

在第4章，你将学习如何以更高效的方式处理列表元素。通过使用为数不多的几行代码来遍历列表元素，你就能高效地处理它们，即便列表包含数千乃至数百万个元素。

------



## 第4章　操作列表

### **老齐导读**

操作列表，最主要的操作就是遍历列表中的每个元素，常用的是 for 循环语句。书中对此语句做了比较细致的讲述，在阅读的时候，请你总结出如下方面：

- for 循环语句的基本格式
- 循环体相对 for 关键词要缩进四个空格
- 循环体结束之后，后面的语句不要再缩进

本章还引入了一个跟列表相似的对象：元组。请注意区别元组和列表，建议参考有关资料，将二者的异同进行总结。

![enter image description here](https://images.gitbook.cn/ae27b780-8815-11e9-9a9c-451c1f88314a)

> 在第3章，你学习了如何创建简单的列表，还学习了如何操作列表元素。在本章中，你将学习如何**遍历**整个列表，这只需要几行代码，无论列表有多长。循环让你能够对列表的每个元素都采取一个或一系列相同的措施，从而高效地处理任何长度的列表，包括包含数千乃至数百万个元素的列表。

### **4.1　遍历整个列表**

你经常需要遍历列表的所有元素，对每个元素执行相同的操作。例如，在游戏中，可能需要将每个界面元素平移相同的距离；对于包含数字的列表，可能需要对每个元素执行相同的统计运算；在网站中，可能需要显示文章列表中的每个标题。需要对列表中的每个元素都执行相同的操作时，可使用 Python 中的`for`循环。

假设我们有一个魔术师名单，需要将其中每个魔术师的名字都打印出来。为此，我们可以分别获取名单中的每个名字，但这种做法会导致多个问题。例如，如果名单很长，将包含大量重复的代码。另外，每当名单的长度发生变化时，都必须修改代码。通过使用`for`循环，可让 Python 去处理这些问题。

下面使用`for`循环来打印魔术师名单中的所有名字：

**magicians.py**

```
❶ magicians = ['alice', 'david', 'carolina']
❷ for magician in magicians:
❸     print(magician)
```

首先，我们像第3章那样定义了一个列表（见❶）。接下来，我们定义了一个`for`循环（见❷）；这行代码让 Python 从列表`magicians`中取出一个名字，并将其存储在变量`magician`中。最后，我们让 Python 打印前面存储到变量`magician`中的名字（见❸）。这样，对于列表中的每个名字，Python 都将重复执行❷处和❸处的代码行。你可以这样解读这些代码：对于列表`magicians`中的每位魔术师，都将其名字打印出来。输出很简单，就是列表中所有的姓名：

```
alice
david
carolina
```

#### **4.1.1　深入地研究循环**

循环这种概念很重要，因为它是让计算机自动完成重复工作的常见方式之一。例如，在前面的 magicians.py 中使用的简单循环中，Python 将首先读取其中的第一行代码：

```
for magician in magicians:
```

这行代码让 Python 获取列表`magicians`中的第一个值（`'alice'`），并将其存储到变量`magician`中。接下来，Python 读取下一行代码：

```
    print(magician)
```

它让 Python 打印`magician`的值——依然是`'alice'`。鉴于该列表还包含其他值，Python 返回到循环的第一行：

```
for magician in magicians:
```

Python 获取列表中的下一个名字——`'david'`，并将其存储到变量`magician`中，再执行下面这行代码：

```
    print(magician)
```

Python 再次打印变量`magician`的值——当前为`'david'`。接下来，Python 再次执行整个循环，对列表中的最后一个值——`'carolina'`进行处理。至此，列表中没有其他的值了，因此 Python 接着执行程序的下一行代码。在这个示例中，`for`循环后面没有其他的代码，因此程序就此结束。

刚开始使用循环时请牢记，对列表中的每个元素，都将执行循环指定的步骤，而不管列表包含多少个元素。如果列表包含一百万个元素，Python 就重复执行指定的步骤一百万次，且通常速度非常快。

另外，编写`for`循环时，对于用于存储列表中每个值的临时变量，可指定任何名称。然而，选择描述单个列表元素的有意义的名称大有帮助。例如，对于小猫列表、小狗列表和一般性列表，像下面这样编写`for`循环的第一行代码是不错的选择：

```
for cat in cats:
for dog in dogs:
for item in list_of_items:
```

这些命名约定有助于你明白`for`循环中将对每个元素执行的操作。使用单数和复数式名称，可帮助你判断代码段处理的是单个列表元素还是整个列表。

#### **4.1.2　在 for 循环中执行更多的操作**

在`for`循环中，可对每个元素执行任何操作。下面来扩展前面的示例，对于每位魔术师，都打印一条消息，指出他的表演太精彩了。

```
  magicians = ['alice', 'david', 'carolina']
  for magician in magicians:
❶     print(magician.title() + ", that was a great trick!")
```

相比于前一个示例，唯一的不同是对于每位魔术师，都打印了一条以其名字为抬头的消息（见❶）。这个循环第一次迭代时，变量`magician`的值为`'alice'`，因此 Python 打印的第一条消息的抬头为`'Alice'`。第二次迭代时，消息的抬头为`'David'`，而第三次迭代时，抬头为`'Carolina'`。

下面的输出表明，对于列表中的每位魔术师，都打印了一条个性化消息：

```
Alice, that was a great trick!
David, that was a great trick!
Carolina, that was a great trick!
```

在`for`循环中，想包含多少行代码都可以。在代码行`for magician in magicians`后面，每个缩进的代码行都是循环的一部分，且将针对列表中的每个值都执行一次。因此，可对列表中的每个值执行任意次数的操作。

下面再添加一行代码，告诉每位魔术师，我们期待他的下一次表演：

```
  magicians = ['alice', 'david', 'carolina']
  for magician in magicians:
      print(magician.title() + ", that was a great trick!")
❶     print("I can't wait to see your next trick, " + magician.title() + ".\n")
```

由于两条`print`语句都缩进了，因此它们都将针对列表中的每位魔术师执行一次。第二条`print`语句中的换行符`"\n"`（见❶）在每次迭代结束后都插入一个空行，从而整洁地将针对各位魔术师的消息编组：

```
Alice, that was a great trick!
I can't wait to see your next trick, Alice.

David, that was a great trick!
I can't wait to see your next trick, David.

Carolina, that was a great trick!
I can't wait to see your next trick, Carolina.
```

在`for`循环中，想包含多少行代码都可以。实际上，你会发现使用`for`循环对每个元素执行众多不同的操作很有用。

#### **4.1.3　在 for 循环结束后执行一些操作**

`for`循环结束后再怎么做呢？通常，你需要提供总结性输出或接着执行程序必须完成的其他任务。

在`for`循环后面，没有缩进的代码都只执行一次，而不会重复执行。下面来打印一条向全体魔术师致谢的消息，感谢他们的精彩表演。想要在打印给各位魔术师的消息后面打印一条给全体魔术师的致谢消息，需要将相应的代码放在`for`循环后面，且不缩进：

```
  magicians = ['alice', 'david', 'carolina']
  for magician in magicians:
      print(magician.title() + ", that was a great trick!")
      print("I can't wait to see your next trick, " + magician.title() + ".\n")

❶ print("Thank you, everyone. That was a great magic show!")
```

你在前面看到了，开头两条`print`语句针对列表中每位魔术师重复执行。然而，由于第三条`print`语句没有缩进，因此只执行一次：

```
Alice, that was a great trick!
I can't wait to see your next trick, Alice.

David, that was a great trick!
I can't wait to see your next trick, David.

Carolina, that was a great trick!
I can't wait to see your next trick, Carolina.

Thank you, everyone. That was a great magic show!
```

使用`for`循环处理数据是一种对数据集执行整体操作的不错的方式。例如，你可能使用`for`循环来初始化游戏——遍历角色列表，将每个角色都显示到屏幕上；再在循环后面添加一个不缩进的代码块，在屏幕上绘制所有角色后显示一个 Play Now 按钮。

### **4.2　避免缩进错误**

Python 根据缩进来判断代码行与前一个代码行的关系。在前面的示例中，向各位魔术师显示消息的代码行是`for`循环的一部分，因为它们缩进了。Python 通过使用缩进让代码更易读；简单地说，它要求你使用缩进让代码整洁而结构清晰。在较长的 Python 程序中，你将看到缩进程度各不相同的代码块，这让你对程序的组织结构有大致的认识。

当你开始编写必须正确缩进的代码时，需要注意一些常见的**缩进错误**。例如，有时候，程序员会将不需要缩进的代码块缩进，而对于必须缩进的代码块却忘了缩进。通过查看这样的错误示例，有助于你以后避开它们，以及在它们出现在程序中时进行修复。

下面来看一些较为常见的缩进错误。

#### **4.2.1　忘记缩进**

对于位于`for`语句后面且属于循环组成部分的代码行，一定要缩进。如果你忘记缩进，Python 会提醒你：

**magicians.py**

```
  magicians = ['alice', 'david', 'carolina']
  for magician in magicians:
❶ print(magician)
```

`print`语句（见❶）应缩进却没有缩进。Python 没有找到期望缩进的代码块时，会让你知道哪行代码有问题。

```
  File "magicians.py", line 3
    print(magician)
        ^
IndentationError: expected an indented block
```

通常，将紧跟在`for`语句后面的代码行缩进，可消除这种缩进错误。

#### **4.2.2　忘记缩进额外的代码行**

有时候，循环能够运行而不会报告错误，但结果可能会出乎意料。试图在循环中执行多项任务，却忘记缩进其中的一些代码行时，就会出现这种情况。

例如，如果忘记缩进循环中的第2行代码（它告诉每位魔术师，我们期待他的下一次表演），就会出现这种情况：

```
  magicians = ['alice', 'david', 'carolina']
  for magician in magicians:
      print(magician.title() + ", that was a great trick!")
❶ print("I can't wait to see your next trick, " + magician.title() + ".\n")
```

第二条`print`语句（见❶）原本需要缩进，但 Python 发现`for`语句后面有一行代码是缩进的，因此它没有报告错误。最终的结果是，对于列表中的每位魔术师，都执行了第一条`print`语句，因为它缩进了；而第二条`print`语句没有缩进，因此它只在循环结束后执行一次。由于变量`magician`的终值为`'carolina'`，因此只有她收到了消息“looking forward to the next trick”：

```
Alice, that was a great trick!
David, that was a great trick!
Carolina, that was a great trick!
I can't wait to see your next trick, Carolina.
```

这是一个**逻辑错误**。从语法上看，这些 Python 代码是合法的，但由于存在逻辑错误，结果并不符合预期。如果你预期某项操作将针对每个列表元素都执行一次，但它却只执行了一次，请确定是否需要将一行或多行代码缩进。

#### **4.2.3　不必要的缩进**

如果你不小心缩进了无需缩进的代码行，Python 将指出这一点：

**hello_world.py**

```
  message = "Hello Python world!"
❶     print(message)
```

`print`语句（见❶）无需缩进，因为它并不属于前一行代码，因此 Python 将指出这种错误：

```
  File "hello_world.py", line 2
    print(message)
    ^
IndentationError: unexpected indent
```

为避免意外缩进错误，请只缩进需要缩进的代码。在前面编写的程序中，只有要在`for`循环中对每个元素执行的代码需要缩进。

#### **4.2.4　循环后不必要的缩进**

如果你不小心缩进了应在循环结束后执行的代码，这些代码将针对每个列表元素重复执行。在有些情况下，这可能导致 Python 报告语法错误，但在大多数情况下，这只会导致逻辑错误。

例如，如果不小心缩进了感谢全体魔术师精彩表演的代码行，结果将如何呢？

```
  magicians = ['alice', 'david', 'carolina']
  for magician in magicians:
      print(magician.title() + ", that was a great trick!")
      print("I can't wait to see your next trick, " + magician.title() + ".\n")

❶     print("Thank you everyone, that was a great magic show!")
```

由于❶处的代码行被缩进，它将针对列表中的每位魔术师执行一次，如❷所示：

```
  Alice, that was a great trick!
  I can't wait to see your next trick, Alice.

❷ Thank you everyone, that was a great magic show!
  David, that was a great trick!
  I can't wait to see your next trick, David.

❷ Thank you everyone, that was a great magic show!
  Carolina, that was a great trick!
  I can't wait to see your next trick, Carolina.

❷ Thank you everyone, that was a great magic show!
```

这也是一个逻辑错误，与4.2.2节的错误类似。Python 不知道你的本意，只要代码符合语法，它就会运行。如果原本只应执行一次的操作执行了多次，请确定你是否不应该缩进执行该操作的代码。

#### **4.2.5　遗漏了冒号**

`for`语句末尾的冒号告诉 Python，下一行是循环的第一行。

```
  magicians = ['alice', 'david', 'carolina']
❶ for magician in magicians
      print(magician)
```

如果你不小心遗漏了冒号，如❶所示，将导致语法错误，因为 Python 不知道你意欲何为。这种错误虽然易于消除，但并不那么容易发现。程序员为找出这样的单字符错误，花费的时间多得令人惊讶。这样的错误之所以难以发现，是因为通常在我们的意料之外。

> **动手试一试**
>
> **4-1 比萨**：想出至少三种你喜欢的比萨，将其名称存储在一个列表中，再使用`for`循环将每种比萨的名称都打印出来。
>
> - 修改这个`for`循环，使其打印包含比萨名称的句子，而不仅仅是比萨的名称。对于每种比萨，都显示一行输出，如“I like pepperoni pizza”。
> - 在程序末尾添加一行代码，它不在`for`循环中，指出你有多喜欢比萨。输出应包含针对每种比萨的消息，还有一个总结性句子，如“I really love pizza!”。
>
> **4-2 动物**：想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用`for`循环将每种动物的名称都打印出来。
>
> - 修改这个程序，使其针对每种动物都打印一个句子，如“A dog would make a great pet”。
> - 在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如“Any of these animals would make a great pet!”这样的句子。

### **4.3　创建数值列表**

需要存储一组数字的原因有很多，例如，在游戏中，需要跟踪每个角色的位置，还可能需要跟踪玩家的几个最高得分。在数据可视化中，处理的几乎都是由数字（如温度、距离、人口数量、经度和纬度等）组成的集合。

列表非常适合用于存储数字集合，而 Python 提供了很多工具，可帮助你高效地处理数字列表。明白如何有效地使用这些工具后，即便列表包含数百万个元素，你编写的代码也能运行得很好。

#### **4.3.1　使用函数 range()**

Python 函数`range()`让你能够轻松地生成一系列的数字。例如，可以像下面这样使用函数`range()`来打印一系列的数字：

**numbers.py**

```
for value in range(1,5):
    print(value)
```

上述代码好像应该打印数字1~5，但实际上它不会打印数字5：

```
1
2
3
4
```

在这个示例中，`range()`只是打印数字1~4，这是你在编程语言中经常看到的差一行为的结果。函数`range()`让 Python 从你指定的第一个值开始数，并在到达你指定的第二个值后停止，因此输出不包含第二个值（这里为5）。

要打印数字1~5，需要使用`range(1,6)`：

```
for value in range(1,6):
    print(value)
```

这样，输出将从1开始，到5结束：

```
1
2
3
4
5
```

使用`range()`时，如果输出不符合预期，请尝试将指定的值加1或减1。

#### **4.3.2　使用 range() 创建数字列表**

要创建数字列表，可使用函数`list()`将`range()`的结果直接转换为列表。如果将`range()`作为`list()`的参数，输出将为一个数字列表。

在前一节的示例中，我们打印了一系列数字。要将这些数字转换为一个列表，可使用`list()`：

```
numbers = list(range(1,6))
print(numbers)
```

结果如下：

```
[1, 2, 3, 4, 5]
```

使用函数`range()`时，还可指定步长。例如，下面的代码打印1~10内的偶数：

**even_numbers.py**

```
even_numbers = list(range(2,11,2))
print(even_numbers)
```

在这个示例中，函数`range()`从2开始数，然后不断地加2，直到达到或超过终值（11），因此输出如下：

```
[2, 4, 6, 8, 10]
```

使用函数`range()`几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前10个整数（即1~10）的平方呢？在 Python 中，两个星号（`**`）表示乘方运算。下面的代码演示了如何将前10个整数的平方加入到一个列表中：

**squares.py**

```
❶ squares = []
❷ for value in range(1,11):
❸     square = value**2
❹     squares.append(square)

❺ print(squares)
```

首先，我们创建了一个空列表（见❶）；接下来，使用函数`range()`让 Python 遍历1~10的值（见❷）。在循环中，计算当前值的平方，并将结果存储到变量`square`中（见❸）。然后，将新计算得到的平方值附加到列表`squares`末尾（见❹）。最后，循环结束后，打印列表`squares`（见❺）：

```
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

为让这些代码更简洁，可不使用临时变量`square`，而直接将每个计算得到的值附加到列表末尾：

```
  squares = []
  for value in range(1,11):
❶     squares.append(value**2)

  print(squares)
```

❶处的代码与 squares.py 中❸处和❹处的代码等效。在循环中，计算每个值的平方，并立即将结果附加到列表`squares`的末尾。

创建更复杂的列表时，可使用上述两种方法中的任何一种。有时候，使用临时变量会让代码更易读；而在其他情况下，这样做只会让代码无谓地变长。你首先应该考虑的是，编写清晰易懂且能完成所需功能的代码；等到审核代码时，再考虑采用更高效的方法。

#### **4.3.3　对数字列表执行简单的统计计算**

有几个专门用于处理数字列表的 Python 函数。例如，你可以轻松地找出数字列表的最大值、最小值和总和：

```
>>> digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
>>> min(digits)
0
>>> max(digits)
9
>>> sum(digits)
45
```

> **注意**　
>
> 出于版面考虑，本节使用的数字列表都很短，但这里介绍的知识也适用于包含数百万个数字的列表。

#### **4.3.4　列表解析**

前面介绍的生成列表`squares`的方式包含三四行代码，而列表解析让你只需编写一行代码就能生成这样的列表。**列表解析**将`for`循环和创建新元素的代码合并成一行，并自动附加新元素。面向初学者的书籍并非都会介绍列表解析，这里之所以介绍列表解析，是因为等你开始阅读他人编写的代码时，很可能会遇到它们。

下面的示例使用列表解析创建你在前面看到的平方数列表：

**squares.py**

```
squares = [value**2 for value in range(1,11)]
print(squares)
```

要使用这种语法，首先指定一个描述性的列表名，如`squares`；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为`value**2`，它计算平方值。接下来，编写一个`for`循环，用于给表达式提供值，再加上右方括号。在这个示例中，`for`循环为`for value in range(1,11)`，它将值1~10提供给表达式`value**2`。请注意，这里的`for`语句末尾没有冒号。

结果与你在前面看到的平方数列表相同：

```
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

要创建自己的列表解析，需要经过一定的练习，但能够熟练地创建常规列表后，你会发现这样做是完全值得的。当你觉得编写三四行代码来生成列表有点繁复时，就应考虑创建列表解析了。

> **动手试一试**
>
> **4-3 数到20**：使用一个`for`循环打印数字1~20（含）。
>
> **4-4 一百万**：创建一个列表，其中包含数字1~1000000，再使用一个`for`循环将这些数字打印出来（如果输出的时间太长，按 Ctrl+C 停止输出，或关闭输出窗口）。
>
> **4-5 计算1~1000000的总和**：创建一个列表，其中包含数字1~1000000，再使用`min()`和`max()`核实该列表确实是从1开始，到1000000结束的。另外，对这个列表调用函数`sum()`，看看 Python 将一百万个数字相加需要多长时间。
>
> **4-6 奇数**：通过给函数`range()`指定第三个参数来创建一个列表，其中包含1~20的奇数；再使用一个`for`循环将这些数字都打印出来。
>
> **4-7 3的倍数**：创建一个列表，其中包含3~30内能被3整除的数字；再使用一个`for`循环将这个列表中的数字都打印出来。
>
> **4-8 立方**：将同一个数字乘三次称为立方。例如，在 Python 中，2的立方用`2**3`表示。请创建一个列表，其中包含前10个整数（即1~10）的立方，再使用一个`for`循环将这些立方数都打印出来。
>
> **4-9 立方解析**：使用列表解析生成一个列表，其中包含前10个整数的立方。

### **4.4　使用列表的一部分**

在第3章中，你学习了如何访问单个列表元素。在本章中，你一直在学习如何处理列表的所有元素。你还可以处理列表的部分元素——Python 称之为**切片**。

#### **4.4.1　切片**

要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数`range()`一样，Python 在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3，这将输出分别为`0`、`1`和`2`的元素。

下面的示例处理的是一个运动队成员列表：

**players.py**

```
  players = ['charles', 'martina', 'michael', 'florence', 'eli']
❶ print(players[0:3])
```

❶处的代码打印该列表的一个切片，其中只包含三名队员。输出也是一个列表，其中包含前三名队员：

```
['charles', 'martina', 'michael']
```

你可以生成列表的任何子集，例如，如果你要提取列表的第2~4个元素，可将起始索引指定为`1`，并将终止索引指定为`4`：

```
players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[1:4])
```

这一次，切片始于`'martina'`，终于`'florence'`：

```
['martina', 'michael', 'florence']
```

如果你没有指定第一个索引，Python 将自动从列表开头开始：

```
players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[:4])
```

由于没有指定起始索引，Python 从列表开头开始提取：

```
['charles', 'martina', 'michael', 'florence']
```

要让切片终止于列表末尾，也可使用类似的语法。例如，如果要提取从第3个元素到列表末尾的所有元素，可将起始索引指定为`2`，并省略终止索引：

```
players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[2:])
```

Python 将返回从第3个元素到列表末尾的所有元素：

```
['michael', 'florence', 'eli']
```

无论列表多长，这种语法都能够让你输出从特定位置到列表末尾的所有元素。本书前面说过，负数索引返回离列表末尾相应距离的元素，因此你可以输出列表末尾的任何切片。例如，如果你要输出名单上的最后三名队员，可使用切片`players[-3:]`：

```
players = ['charles', 'martina', 'michael', 'florence', 'eli']
print(players[-3:])
```

上述代码打印最后三名队员的名字，即便队员名单的长度发生变化，也依然如此。

#### **4.4.2　遍历切片**

如果要遍历列表的部分元素，可在`for`循环中使用切片。在下面的示例中，我们遍历前三名队员，并打印他们的名字：

```
  players = ['charles', 'martina', 'michael', 'florence', 'eli']

  print("Here are the first three players on my team:")
❶ for player in players[:3]:
      print(player.title())
```

❶处的代码没有遍历整个队员列表，而只遍历前三名队员：

```
Here are the first three players on my team:
Charles
Martina
Michael
```

在很多情况下，切片都很有用。例如，编写游戏时，你可以在玩家退出游戏时将其最终得分加入到一个列表中。然后，为获取该玩家的三个最高得分，你可以将该列表按降序排列，再创建一个只包含前三个得分的切片。处理数据时，可使用切片来进行批量处理；编写 Web 应用程序时，可使用切片来分页显示信息，并在每页显示数量合适的信息。

#### **4.4.3　复制列表**

你经常需要根据既有列表创建全新的列表。下面来介绍复制列表的工作原理，以及复制列表可提供极大帮助的一种情形。

要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（`[:]`）。这让 Python 创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。

例如，假设有一个列表，其中包含你最喜欢的三种食品，而你还想创建另一个列表，在其中包含一位朋友喜欢的所有食品。不过，你喜欢的食品，这位朋友都喜欢，因此你可以通过复制来创建这个列表：

**foods.py**

```
❶ my_foods = ['pizza', 'falafel', 'carrot cake']
❷ friend_foods = my_foods[:]

  print("My favorite foods are:")
  print(my_foods)

  print("\nMy friend's favorite foods are:")
  print(friend_foods)
```

我们首先创建了一个名为`my_foods`的食品列表（见❶），然后创建了一个名为`friend_foods`的新列表（见❷）。我们在不指定任何索引的情况下从列表`my_foods`中提取一个切片，从而创建了这个列表的副本，再将该副本存储到变量`friend_foods`中。打印每个列表后，我们发现它们包含的食品相同：

```
My favorite foods are:
['pizza', 'falafel', 'carrot cake']

My friend's favorite foods are:
['pizza', 'falafel', 'carrot cake']
```

为核实我们确实有两个列表，下面在每个列表中都添加一种食品，并核实每个列表都记录了相应人员喜欢的食品：

```
  my_foods = ['pizza', 'falafel', 'carrot cake']
❶ friend_foods = my_foods[:]

❷ my_foods.append('cannoli')
❸ friend_foods.append('ice cream')

  print("My favorite foods are:")
  print(my_foods)

  print("\nMy friend's favorite foods are:")
  print(friend_foods)
```

与前一个示例一样，我们首先将`my_foods`的元素复制到新列表`friend_foods`中（见❶）。接下来，在每个列表中都添加一种食品：在列表`my_foods`中添加`'cannoli'`（见❷），而在`friend_foods`中添加`'ice cream'`（见❸）。最后，打印这两个列表，核实这两种食品包含在正确的列表中。

```
  My favorite foods are:
❹ ['pizza', 'falafel', 'carrot cake', 'cannoli']

  My friend's favorite foods are:
❺ ['pizza', 'falafel', 'carrot cake', 'ice cream']
```

❹处的输出表明，`'cannoli'`包含在你喜欢的食品列表中，而`'ice cream'`没有。❺处的输出表明，`'ice cream'`包含在你朋友喜欢的食品列表中，而`'cannoli'`没有。倘若我们只是简单地将`my_foods`赋给`friend_foods`，就不能得到两个列表。例如，下例演示了在不使用切片的情况下复制列表的情况：

```
  my_foods = ['pizza', 'falafel', 'carrot cake']

  #这行不通
❶ friend_foods = my_foods

  my_foods.append('cannoli')
  friend_foods.append('ice cream')

  print("My favorite foods are:")
  print(my_foods)

  print("\nMy friend's favorite foods are:")
  print(friend_foods)
```

这里将`my_foods`赋给`friend_foods`，而不是将`my_foods`的副本存储到`friend_foods`（见❶）。这种语法实际上是让 Python 将新变量`friend_foods`关联到包含在`my_foods`中的列表，因此这两个变量都指向同一个列表。鉴于此，当我们将`'cannoli'`添加到`my_foods`中时，它也将出现在`friend_foods`中；同样，虽然`'ice cream'`好像只被加入到了`friend_foods`中，但它也将出现在这两个列表中。

输出表明，两个列表是相同的，这并非我们想要的结果：

```
My favorite foods are:
['pizza', 'falafel', 'carrot cake', 'cannoli', 'ice cream']

My friend's favorite foods are:
['pizza', 'falafel', 'carrot cake', 'cannoli', 'ice cream']
```

> **注意**　
>
> 现在暂时不要考虑这个示例中的细节。基本上，当你试图使用列表的副本时，如果结果出乎意料，请确认你像第一个示例那样使用切片复制了列表。

> **动手试一试**
>
> **4-10 切片**：选择你在本章编写的一个程序，在末尾添加几行代码，以完成如下任务。
>
> - 打印消息“The first three items in the list are:”，再使用切片来打印列表的前三个元素。
> - 打印消息“Three items from the middle of the list are:”，再使用切片来打印列表中间的三个元素。
> - 打印消息“The last three items in the list are:”，再使用切片来打印列表末尾的三个元素。
>
> **4-11 你的比萨和我的比萨**：在你为完成练习4-1而编写的程序中，创建比萨列表的副本，并将其存储到变量`friend_pizzas`中，再完成如下任务。
>
> - 在原来的比萨列表中添加一种比萨。
> - 在列表`friend_pizzas`中添加另一种比萨。
> - 核实你有两个不同的列表。为此，打印消息“My favorite pizzas are:”，再使用一个`for`循环来打印第一个列表；打印消息“My friend's favorite pizzas are:”，再使用一个`for`循环来打印第二个列表。核实新增的比萨被添加到了正确的列表中。
>
> **4-12 使用多个循环**：在本节中，为节省篇幅，程序 foods.py 的每个版本都没有使用`for`循环来打印列表。请选择一个版本的 foods.py，在其中编写两个`for`循环，将各个食品列表都打印出来。

### **4.5　元组**

列表非常适合用于存储在程序运行期间可能变化的数据集。列表是可以修改的，这对处理网站的用户列表或游戏中的角色列表至关重要。然而，有时候你需要创建一系列不可修改的元素，元组可以满足这种需求。Python 将不能修改的值称为**不可变的**，而不可变的列表被称为**元组**。

#### **4.5.1　定义元组**

元组看起来犹如列表，但使用圆括号而不是方括号来标识。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。

例如，如果有一个大小不应改变的矩形，可将其长度和宽度存储在一个元组中，从而确保它们是不能修改的：

**dimensions.py**

```
❶ dimensions = (200, 50)
❷ print(dimensions[0])
  print(dimensions[1])
```

我们首先定义了元组`dimensions`（见❶），为此我们使用了圆括号而不是方括号。接下来，我们分别打印该元组的各个元素，使用的语法与访问列表元素时使用的语法相同（见❷）：

```
200
50
```

下面来尝试修改元组`dimensions`中的一个元素，看看结果如何：

```
  dimensions = (200, 50)
❶ dimensions[0] = 250
```

❶处的代码试图修改第一个元素的值，导致 Python 返回类型错误消息。由于试图修改元组的操作是被禁止的，因此 Python 指出不能给元组的元素赋值：

```
Traceback (most recent call last):
  File "dimensions.py", line 3, in <module>
    dimensions[0] = 250
TypeError: 'tuple' object does not support item assignment
```

代码试图修改矩形的尺寸时，Python 报告错误，这很好，因为这正是我们希望的。

#### **4.5.2　遍历元组中的所有值**

像列表一样，也可以使用`for`循环来遍历元组中的所有值：

```
dimensions = (200, 50)
for dimension in dimensions:
    print(dimension)
```

就像遍历列表时一样，Python 返回元组中所有的元素：

```
200
50
```

#### **4.5.3　修改元组变量**

虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组：

```
❶ dimensions = (200, 50)
  print("Original dimensions:")
  for dimension in dimensions:
      print(dimension)

❷ dimensions = (400, 100)
❸ print("\nModified dimensions:")
  for dimension in dimensions:
      print(dimension)
```

我们首先定义了一个元组，并将其存储的尺寸打印了出来（见❶）；接下来，将一个新元组存储到变量`dimensions`中（见❷）；然后，打印新的尺寸（见❸）。这次，Python 不会报告任何错误，因为给元组变量赋值是合法的：

```
Original dimensions:
200
50

Modified dimensions:
400
100
```

相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，可使用元组。

> **动手试一试**
>
> **4-13 自助餐**：有一家自助式餐馆，只提供五种简单的食品。请想出五种简单的食品，并将其存储在一个元组中。
>
> - 使用一个`for`循环将该餐馆提供的五种食品都打印出来。
> - 尝试修改其中的一个元素，核实 Python 确实会拒绝你这样做。
> - 餐馆调整了菜单，替换了它提供的其中两种食品。请编写一个这样的代码块：给元组变量赋值，并使用一个`for`循环将新元组的每个元素都打印出来。

### **4.6　设置代码格式**

随着你编写的程序越来越长，有必要了解一些代码格式设置约定。请花时间让你的代码尽可能易于阅读；让代码易于阅读有助于你掌握程序是做什么的，也可以帮助他人理解你编写的代码。

为确保所有人编写的代码的结构都大致一致，Python 程序员都遵循一些格式设置约定。学会编写整洁的 Python 后，就能明白他人编写的 Python 代码的整体结构——只要他们和你遵循相同的指南。要成为专业程序员，应从现在开始就遵循这些指南，以养成良好的习惯。

#### **4.6.1　格式设置指南**

若要提出 Python 语言修改建议，需要编写 Python **改进提案**（Python Enhancement Proposal，PEP）。PEP 8 是最古老的 PEP 之一，它向 Python 程序员提供了代码格式设置指南。PEP 8 的篇幅很长，但大都与复杂的编码结构相关。

Python 格式设置指南的编写者深知，代码被阅读的次数比编写的次数多。代码编写出来后，调试时你需要阅读它；给程序添加新功能时，需要花很长的时间阅读代码；与其他程序员分享代码时，这些程序员也将阅读它们。

如果一定要在让代码易于编写和易于阅读之间做出选择，Python 程序员几乎总是会选择后者。下面的指南可帮助你从一开始就编写出清晰的代码。

#### **4.6.2　缩进**

PEP 8 建议每级缩进都使用四个空格，这既可提高可读性，又留下了足够的多级缩进空间。

在字处理文档中，大家常常使用制表符而不是空格来缩进。对于字处理文档来说，这样做的效果很好，但混合使用制表符和空格会让 Python 解释器感到迷惑。每款文本编辑器都提供了一种设置，可将输入的制表符转换为指定数量的空格。你在编写代码时应该使用制表符键，但一定要对编辑器进行设置，使其在文档中插入空格而不是制表符。

在程序中混合使用制表符和空格可能导致极难解决的问题。如果你混合使用了制表符和空格，可将文件中所有的制表符转换为空格，大多数编辑器都提供了这样的功能。

#### **4.6.3　行长**

很多 Python 程序员都建议每行不超过80字符。最初制定这样的指南时，在大多数计算机中，终端窗口每行只能容纳79字符；当前，计算机屏幕每行可容纳的字符数多得多，为何还要使用79字符的标准行长呢？这里有别的原因。专业程序员通常会在同一个屏幕上打开多个文件，使用标准行长可以让他们在屏幕上并排打开两三个文件时能同时看到各个文件的完整行。PEP 8 还建议注释的行长都不超过72字符，因为有些工具为大型项目自动生成文档时，会在每行注释开头添加格式化字符。

PEP 8 中有关行长的指南并非不可逾越的红线，有些小组将最大行长设置为99字符。在学习期间，你不用过多地考虑代码的行长，但别忘了，协作编写程序时，大家几乎都遵守 PEP 8 指南。在大多数编辑器中，都可设置一个视觉标志——通常是一条竖线，让你知道不能越过的界线在什么地方。

> **注意**　
>
> 附录 B 介绍了如何配置文本编辑器，以使其：在你按制表符键时插入四个空格；显示一条垂直参考线，帮助你遵守行长不能超过79字符的约定。

#### **4.6.4　空行**

要将程序的不同部分分开，可使用空行。你应该使用空行来组织程序文件，但也不能滥用；只要按本书的示例展示的那样做，就能掌握其中的平衡。例如，如果你有5行创建列表的代码，还有3行处理该列表的代码，那么用一个空行将这两部分隔开是合适的。然而，你不应使用三四个空行将它们隔开。

空行不会影响代码的运行，但会影响代码的可读性。Python 解释器根据水平缩进情况来解读代码，但不关心垂直间距。

#### **4.6.5　其他格式设置指南**

PEP 8 还有很多其他的格式设置建议，但这些指南针对的程序大都比目前为止本书提到的程序复杂。等介绍更复杂的 Python 结构时，我们再来分享相关的 PEP 8 指南。

> **动手试一试**
>
> **4-14 PEP 8**：请访问 <https://python.org/dev/peps/pep-0008/>，阅读 PEP 8 格式设置指南。当前，这些指南适用的不多，但你可以大致浏览一下。
>
> **4-15 代码审核**：从本章编写的程序中选择三个，根据 PEP 8 指南对它们进行修改。
>
> - 每级缩进都使用四个空格。对你使用的文本编辑器进行设置，使其在你按 Tab 键时都插入四个空格；如果你还没有这样做，现在就去做吧（有关如何设置，请参阅附录 B）。
> - 每行都不要超过80字符。对你使用的编辑器进行设置，使其在第80个字符处显示一条垂直参考线。
> - 不要在程序文件中过多地使用空行。

### **4.7　小结**

在本章中，你学习了：如何高效地处理列表中的元素；如何使用`for`循环遍历列表，Python 如何根据缩进来确定程序的结构以及如何避免一些常见的缩进错误；如何创建简单的数字列表，以及可对数字列表执行的一些操作；如何通过切片来使用列表的一部分和复制列表。你还学习了元组（它对不应变化的值提供了一定程度的保护），以及在代码变得越来越复杂时如何设置格式，使其易于阅读。

在第5章中，你将学习如何使用`if`语句在不同的条件下采取不同的措施；学习如何将一组较复杂的条件测试组合起来，并在满足特定条件时采取相应的措施。你还将学习如何在遍历列表时，通过使用`if`语句对特定元素采取特定的措施。

------



## 第5章　if 语句

### **老齐导读**

本章重点理解 if 语句的结构（如下图所示），并且能够与 for 循环语句配合使用。

建议按照书中所讲逐行写代码。

再有，对比较运算和逻辑运算的学习，不妨拓展一下，对相关的内容做深入研习。

![enter image description here](https://images.gitbook.cn/b29ccf70-8816-11e9-9a9c-451c1f88314a)

> 编程时经常需要检查一系列条件，并据此决定采取什么措施。在 Python 中，`if`语句让你能够检查程序的当前状态，并据此采取相应的措施。
>
> 在本章中，你将学习条件测试，以检查感兴趣的任何条件。你将学习简单的`if`语句，以及创建一系列复杂的`if`语句来确定当前到底处于什么情形。接下来，你将把学到的知识应用于列表，以编写`for`循环，以一种方式处理列表中的大多数元素，并以另一种不同的方式处理包含特定值的元素。

### **5.1　一个简单示例**

下面是一个简短的示例，演示了如何使用`if`语句来正确地处理特殊情形。假设你有一个汽车列表，并想将其中每辆汽车的名称打印出来。对于大多数汽车，都应以首字母大写的方式打印其名称，但对于汽车名`'bmw'`，应以全大写的方式打印。下面的代码遍历一个列表，并以首字母大写的方式打印其中的汽车名，但对于汽车名`'bmw'`，以全大写的方式打印：

**cars.py**

```
  cars = ['audi', 'bmw', 'subaru', 'toyota']

  for car in cars:
❶     if car == 'bmw':
          print(car.upper())
      else:
          print(car.title())
```

这个示例中的循环首先检查当前的汽车名是否是`'bmw'`（见❶）。如果是，就以全大写的方式打印它；否则就以首字母大写的方式打印：

```
Audi
BMW
Subaru
Toyota
```

这个示例涵盖了本章将介绍的很多概念。下面先来介绍可用来在程序中检查条件的测试。

### **5.2　条件测试**

每条`if`语句的核心都是一个值为`True`或`False`的表达式，这种表达式被称为**条件测试**。Python 根据条件测试的值为`True`还是`False`来决定是否执行`if`语句中的代码。如果条件测试的值为`True`，Python 就执行紧跟在`if`语句后面的代码；如果为`False`，Python 就忽略这些代码。

#### **5.2.1　检查是否相等**

大多数条件测试都将一个变量的当前值同特定值进行比较。最简单的条件测试检查变量的值是否与特定值相等：

```
❶ >>> car = 'bmw'
❷ >>> car == 'bmw'
  True
```

我们首先使用一个等号将`car`的值设置为`'bmw'`（见❶），这种做法你已见过很多次。接下来，使用两个等号（`==`）检查`car`的值是否为`'bmw'`。这个**相等运算符**在它两边的值相等时返回`True`，否则返回`False`。在这个示例中，两边的值相等，因此 Python 返回`True`。

如果变量`car`的值不是`'bmw'`，上述测试将返回`False`：

```
❶ >>> car = 'audi'
❷ >>> car == 'bmw'
  False
```

一个等号是陈述；对于❶处的代码，可解读为“将变量`car`的值设置为`'audi'`”。两个等号是发问；对于❷处的代码，可解读为“变量`car`的值是`'bmw'`吗？”。大多数编程语言使用等号的方式都与这里演示的相同。

#### **5.2.2　检查是否相等时不考虑大小写**

在 Python 中检查是否相等时区分大小写，例如，两个大小写不同的值会被视为不相等：

```
>>> car = 'Audi'
>>> car == 'audi'
False
```

如果大小写很重要，这种行为有其优点。但如果大小写无关紧要，而只想检查变量的值，可将变量的值转换为小写，再进行比较：

```
>>> car = 'Audi'
>>> car.lower() == 'audi'
True
```

无论值`'Audi'`的大小写如何，上述测试都将返回`True`，因为该测试不区分大小写。函数`lower()`不会修改存储在变量`car`中的值，因此进行这样的比较时不会影响原来的变量：

```
❸ >>> car = 'Audi'
❷ >>> car.lower() == 'audi'
  True
❸ >>> car
  'Audi'
```

在❶处，我们将首字母大写的字符串`'Audi'`存储在变量`car`中；在❷处，我们获取变量`car`的值并将其转换为小写，再将结果与字符串`'audi'`进行比较。这两个字符串相同，因此 Python 返回`True`。从❸处的输出可知，这个条件测试并没有影响存储在变量`car`中的值。

网站采用类似的方式让用户输入的数据符合特定的格式。例如，网站可能使用类似的测试来确保用户名是独一无二的，而并非只是与另一个用户名的大小写不同。用户提交新的用户名时，将把它转换为小写，并与所有既有用户名的小写版本进行比较。执行这种检查时，如果已经有用户名`'john'`（不管大小写如何），则用户提交用户名`'John'`时将遭到拒绝。

#### **5.2.3　检查是否不相等**

要判断两个值是否不等，可结合使用惊叹号和等号（`!=`），其中的惊叹号表示**不**，在很多编程语言中都如此。

下面再使用一条`if`语句来演示如何使用不等运算符。我们将把要求的比萨配料存储在一个变量中，再打印一条消息，指出顾客要求的配料是否是意式小银鱼（anchovies）：

**toppings.py**

```
  requested_topping = 'mushrooms'

❶ if requested_topping != 'anchovies':
      print("Hold the anchovies!")
```

❶处的代码行将`requested_topping`的值与`'anchovies'`进行比较，如果它们不相等，Python 将返回`True`，进而执行紧跟在`if`语句后面的代码；如果这两个值相等，Python 将返回`False`，因此不执行紧跟在`if`语句后面的代码。

由于`requested_topping`的值不是`'anchovies'`，因此执行`print`语句：

```
Hold the anchovies!
```

你编写的大多数条件表达式都检查两个值是否相等，但有时候检查两个值是否不等的效率更高。

#### **5.2.4　比较数字**

检查数值非常简单，例如，下面的代码检查一个人是否是18岁：

```
>>> age = 18
>>> age == 18
True
```

你还可以检查两个数字是否不等，例如，下面的代码在提供的答案不正确时打印一条消息：

**magic_number.py**

```
  answer = 17

❶ if answer != 42:
      print("That is not the correct answer. Please try again!")
```

`answer`（`17`）不是`42`，❶处的条件得到满足，因此缩进的代码块得以执行：

```
That is not the correct answer. Please try again!
```

条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于：

```
>>> age = 19
>>> age < 21
True
>>> age <= 21
True
>>> age > 21
False
>>> age >= 21
False
```

在`if`语句中可使用各种数学比较，这让你能够直接检查关心的条件。

#### **5.2.5　检查多个条件**

你可能想同时检查多个条件，例如，有时候你需要在两个条件都为`True`时才执行相应的操作，而有时候你只要求一个条件为`True`时就执行相应的操作。在这些情况下，关键字`and`和`or`可助你一臂之力。

**1. 使用and检查多个条件**

要检查是否两个条件都为`True`，可使用关键字`and`将两个条件测试合而为一；如果每个测试都通过了，整个表达式就为`True`；如果至少有一个测试没有通过，整个表达式就为`False`。

例如，要检查是否两个人都不小于21岁，可使用下面的测试：

```
❶ >>> age_0 = 22
  >>> age_1 = 18
❷ >>> age_0 >= 21 and age_1 >= 21
  False
❸ >>> age_1 = 22
  >>> age_0 >= 21 and age_1 >= 21
  True
```

在❶处，我们定义了两个用于存储年龄的变量：`age_0`和`age_1`。在❷处，我们检查这两个变量是否都大于或等于21；左边的测试通过了，但右边的测试没有通过，因此整个条件表达式的结果为`False`。在❸处，我们将`age_1`改为22，这样`age_1`的值大于21，因此两个测试都通过了，导致整个条件表达式的结果为`True`。

为改善可读性，可将每个测试都分别放在一对括号内，但并非必须这样做。如果你使用括号，测试将类似于下面这样：

```
(age_0 >= 21) and (age_1 >= 21)
```

**2. 使用or检查多个条件**

关键字`or`也能够让你检查多个条件，但只要至少有一个条件满足，就能通过整个测试。仅当两个测试都没有通过时，使用`or`的表达式才为`False`。

下面再次检查两个人的年龄，但检查的条件是至少有一个人的年龄不小于21岁：

```
❶ >>> age_0 = 22
  >>> age_1 = 18
❷ >>> age_0 >= 21 or age_1 >= 21
  True
❸ >>> age_0 = 18
  >>> age_0 >= 21 or age_1 >= 21
  False
```

同样，我们首先定义了两个用于存储年龄的变量（见❶）。由于❷处对`age_0`的测试通过了，因此整个表达式的结果为`True`。接下来，我们将`age_0`减小为18；在❸处的测试中，两个测试都没有通过，因此整个表达式的结果为`False`。

#### **5.2.6　检查特定值是否包含在列表中**

有时候，执行操作前必须检查列表是否包含特定的值。例如，结束用户的注册过程前，可能需要检查他提供的用户名是否已包含在用户名列表中。在地图程序中，可能需要检查用户提交的位置是否包含在已知位置列表中。

要判断特定的值是否已包含在列表中，可使用关键字`in`。来看你可能为比萨店编写的一些代码；这些代码首先创建一个列表，其中包含用户点的比萨配料，然后检查特定的配料是否包含在该列表中。

```
  >>> requested_toppings = ['mushrooms', 'onions', 'pineapple']
❶ >>> 'mushrooms' in requested_toppings
  True
❷ >>> 'pepperoni' in requested_toppings
  False
```

在❶处和❷处，关键字`in`让 Python 检查列表`requested_toppings`是否包含`'mushrooms'`和`'pepperoni'`。这种技术很有用，它让你能够在创建一个列表后，轻松地检查其中是否包含特定的值。

#### **5.2.7　检查特定值是否不包含在列表中**

还有些时候，确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字`not in`。例如，如果有一个列表，其中包含被禁止在论坛上发表评论的用户，就可在允许用户提交评论前检查他是否被禁言：

**banned_users.py**

```
  banned_users = ['andrew', 'carolina', 'david']
  user = 'marie'

❶ if user not in banned_users:
      print(user.title() + ", you can post a response if you wish.")
```

❶处的代码行明白易懂：如果`user`的值未包含在列表`banned_users`中，Python 将返回`True`，进而执行缩进的代码行。

用户`'marie'`未包含在列表`banned_users`中，因此她将看到一条邀请她发表评论的消息：

```
Marie, you can post a response if you wish.
```

#### **5.2.8　布尔表达式**

随着你对编程的了解越来越深入，将遇到术语**布尔表达式**，它不过是条件测试的别名。与条件表达式一样，布尔表达式的结果要么为`True`，要么为`False`。

布尔值通常用于记录条件，如游戏是否正在运行，或用户是否可以编辑网站的特定内容：

```
game_active = True
can_edit = False
```

在跟踪程序状态或程序中重要的条件方面，布尔值提供了一种高效的方式。

> **动手试一试**
>
> **5-1 条件测试**：编写一系列条件测试；将每个测试以及你对其结果的预测和实际结果都打印出来。你编写的代码应类似于下面这样：
>
> ```
> car = 'subaru'
> print("Is car == 'subaru'? I predict True.")
> print(car == 'subaru')
>    　
> print("\nIs car == 'audi'? I predict False.")
> print(car == 'audi')
> ```
>
> - 详细研究实际结果，直到你明白了它为何为`True`或`False`。
> - 创建至少10个测试，且其中结果分别为`True`和`False`的测试都至少有5个。
>
> **5-2 更多的条件测试**：你并非只能创建10个测试。如果你想尝试做更多的比较，可再编写一些测试，并将它们加入到 conditional_tests.py 中。对于下面列出的各种测试，至少编写一个结果为`True`和`False`的测试。
>
> - 检查两个字符串相等和不等。
> - 使用函数`lower()`的测试。
> - 检查两个数字相等、不等、大于、小于、大于等于和小于等于。
> - 使用关键字`and`和`or`的测试。
> - 测试特定的值是否包含在列表中。
> - 测试特定的值是否未包含在列表中。

### **5.3　if 语句**

理解条件测试后，就可以开始编写`if`语句了。`if`语句有很多种，选择使用哪种取决于要测试的条件数。前面讨论条件测试时，列举了多个`if`语句示例，下面更深入地讨论这个主题。

#### **5.3.1　简单的 if 语句**

最简单的`if`语句只有一个测试和一个操作：

```
if conditional_test:
     do something
```

在第1行中，可包含任何条件测试，而在紧跟在测试后面的缩进代码块中，可执行任何操作。如果条件测试的结果为`True`，Python 就会执行紧跟在`if`语句后面的代码；否则 Python 将忽略这些代码。

假设有一个表示某人年龄的变量，而你想知道这个人是否够投票的年龄，可使用如下代码：

**voting.py**

```
  age = 19
❶ if age >= 18:
❷     print("You are old enough to vote!")
```

在❶处，Python 检查变量`age`的值是否大于或等于18；答案是肯定的，因此 Python 执行❷处缩进的`print`语句：

```
You are old enough to vote!
```

在`if`语句中，缩进的作用与`for`循环中相同。如果测试通过了，将执行`if`语句后面所有缩进的代码行，否则将忽略它们。

在紧跟在`if`语句后面的代码块中，可根据需要包含任意数量的代码行。下面在一个人够投票的年龄时再打印一行输出，问他是否登记了：

```
age = 19
if age >= 18:
    print("You are old enough to vote!")
    print("Have you registered to vote yet?")
```

条件测试通过了，而两条`print`语句都缩进了，因此它们都将执行：

```
You are old enough to vote!
Have you registered to vote yet?
```

如果`age`的值小于18，这个程序将不会有任何输出。

#### **5.3.2　if-else 语句**

经常需要在条件测试通过了时执行一个操作，并在没有通过时执行另一个操作；在这种情况下，可使用 Python 提供的`if-else`语句。`if-else`语句块类似于简单的`if`语句，但其中的`else`语句让你能够指定条件测试未通过时要执行的操作。

下面的代码在一个人够投票的年龄时显示与前面相同的消息，同时在这个人不够投票的年龄时也显示一条消息：

```
  age = 17
❶ if age >= 18:
      print("You are old enough to vote!")
      print("Have you registered to vote yet?")
❷ else:
      print("Sorry, you are too young to vote.")
      print("Please register to vote as soon as you turn 18!")
```

如果❶处的条件测试通过了，就执行第一个缩进的`print`语句块；如果测试结果为`False`，就执行❷处的`else`代码块。这次`age`小于18，条件测试未通过，因此执行`else`代码块中的代码：

```
Sorry, you are too young to vote.
Please register to vote as soon as you turn 18!
```

上述代码之所以可行，是因为只存在两种情形：要么够投票的年龄，要么不够。`if-else`结构非常适合用于要让 Python 执行两种操作之一的情形。在这种简单的`if-else`结构中，总是会执行两个操作中的一个。

#### **5.3.3　if-elif-else 结构**

经常需要检查超过两个的情形，为此可使用 Python 提供的`if-elif-else`结构。Python 只执行`if-elif-else`结构中的一个代码块，它依次检查每个条件测试，直到遇到通过了的条件测试。测试通过后，Python 将执行紧跟在它后面的代码，并跳过余下的测试。

在现实世界中，很多情况下需要考虑的情形都超过两个。例如，来看一个根据年龄段收费的游乐场：

- 4岁以下免费；
- 4~18岁收费5美元；
- 18岁（含）以上收费10美元。

如果只使用一条`if`语句，如何确定门票价格呢？下面的代码确定一个人所属的年龄段，并打印一条包含门票价格的消息：

**amusement_park.py**

```
 age = 12

❶ if age < 4:
      print("Your admission cost is $0.")
❷ elif age < 18:
      print("Your admission cost is $5.")
❸ else:
      print("Your admission cost is $10.")
```

❶处的`if`测试检查一个人是否不满4岁，如果是这样，Python 就打印一条合适的消息，并跳过余下的测试。❷处的`elif`代码行其实是另一个`if`测试，它仅在前面的测试未通过时才会运行。在这里，我们知道这个人不小于4岁，因为第一个测试未通过。如果这个人未满18岁，Python 将打印相应的消息，并跳过`else`代码块。如果`if`测试和`elif`测试都未通过，Python 将运行❸处`else`代码块中的代码。

在这个示例中，❶处测试的结果为`False`，因此不执行其代码块。然而，第二个测试的结果为`True`（12小于18），因此将执行其代码块。输出为一个句子，向用户指出了门票价格：

```
Your admission cost is $5.
```

只要年龄超过17岁，前两个测试就都不能通过。在这种情况下，将执行`else`代码块，指出门票价格为10美元。

为让代码更简洁，可不在`if-elif-else`代码块中打印门票价格，而只在其中设置门票价格，并在它后面添加一条简单的`print`语句：

```
  age = 12

  if age < 4:
❶     price = 0
  elif age < 18:
❷     price = 5
  else:
❸     price = 10

❹ print("Your admission cost is $" + str(price) + ".")
```

❶处、❷处和❸处的代码行像前一个示例那样，根据人的年龄设置变量`price`的值。在`if-elif-else`结构中设置`price`的值后，一条未缩进的`print`语句❹会根据这个变量的值打印一条消息，指出门票的价格。

这些代码的输出与前一个示例相同，但`if-elif-else`结构的作用更小，它只确定门票价格，而不是在确定门票价格的同时打印一条消息。除效率更高外，这些修订后的代码还更容易修改：要调整输出消息的内容，只需修改一条而不是三条`print`语句。

#### **5.3.4　使用多个 elif 代码块**

可根据需要使用任意数量的`elif`代码块，例如，假设前述游乐场要给老年人打折，可再添加一个条件测试，判断顾客是否符合打折条件。下面假设对于65岁（含）以上的老人，可以半价（即5美元）购买门票：

```
  age = 12

  if age < 4:
      price = 0
  elif age < 18:
      price = 5
❶ elif age < 65:
      price = 10
❷ else:
      price = 5

  print("Your admission cost is $" + str(price) + ".")
```

这些代码大都未变。第二个`elif`代码块（见❶）通过检查确定年龄不到65岁后，才将门票价格设置为全票价格——10美元。请注意，在`else`代码块（见❷）中，必须将所赋的值改为5，因为仅当年龄超过65（含）时，才会执行这个代码块。

#### **5.3.5　省略 else 代码块**

Python 并不要求`if-elif`结构后面必须有`else`代码块。在有些情况下，`else`代码块很有用；而在其他一些情况下，使用一条`elif`语句来处理特定的情形更清晰：

```
  age = 12

  if age < 4:
      price = 0
  elif age < 18:
      price = 5
  elif age < 65:
      price = 10
❶ elif age >= 65:
      price = 5

  print("Your admission cost is $" + str(price) + ".")
```

❶处的`elif`代码块在顾客的年龄超过65（含）时，将价格设置为5美元，这比使用`else`代码块更清晰些。经过这样的修改后，每个代码块都仅在通过了相应的测试时才会执行。

`else`是一条包罗万象的语句，只要不满足任何`if`或`elif`中的条件测试，其中的代码就会执行，这可能会引入无效甚至恶意的数据。如果知道最终要测试的条件，应考虑使用一个`elif`代码块来代替`else`代码块。这样，你就可以肯定，仅当满足相应的条件时，你的代码才会执行。

#### **5.3.6　测试多个条件**

`if-elif-else`结构功能强大，但仅适合用于只有一个条件满足的情况：遇到通过了的测试后，Python 就跳过余下的测试。这种行为很好，效率很高，让你能够测试一个特定的条件。

然而，有时候必须检查你关心的所有条件。在这种情况下，应使用一系列不包含`elif`和`else`代码块的简单`if`语句。在可能有多个条件为`True`，且你需要在每个条件为`True`时都采取相应措施时，适合使用这种方法。

下面再来看前面的比萨店示例。如果顾客点了两种配料，就需要确保在其比萨中包含这些配料：

**toppings.py**

```
❶ requested_toppings = ['mushrooms', 'extra cheese']

❷ if 'mushrooms' in requested_toppings:
      print("Adding mushrooms.")
❸ if 'pepperoni' in requested_toppings:
      print("Adding pepperoni.")
❹ if 'extra cheese' in requested_toppings:
      print("Adding extra cheese.")

  print("\nFinished making your pizza!")
```

我们首先创建了一个列表，其中包含顾客点的配料（见❶）。❷处的`if`语句检查顾客是否点了配料蘑菇（`'mushrooms'`），如果点了，就打印一条确认消息。❸处检查配料辣香肠（`'pepperoni'`）的代码也是一个简单的`if`语句，而不是`elif`或`else`语句；因此不管前一个测试是否通过，都将进行这个测试。❹处的代码检查顾客是否要求多加芝士（`'extra cheese'`）；不管前两个测试的结果如何，都会执行这些代码。每当这个程序运行时，都会进行这三个独立的测试。

在这个示例中，会检查每个条件，因此将在比萨中添加蘑菇并多加芝士：

```
Adding mushrooms.
Adding extra cheese.

Finished making your pizza!
```

如果像下面这样转而使用`if-elif-else`结构，代码将不能正确地运行，因为有一个测试通过后，就会跳过余下的测试：

```
requested_toppings = ['mushrooms', 'extra cheese']

if 'mushrooms' in requested_toppings:
    print("Adding mushrooms.")
elif 'pepperoni' in requested_toppings:
    print("Adding pepperoni.")
elif 'extra cheese' in requested_toppings:
    print("Adding extra cheese.")

print("\nFinished making your pizza!")
```

第一个测试检查列表中是否包含`'mushrooms'`，它通过了，因此将在比萨中添加蘑菇。然而，Python 将跳过`if-elif-else`结构中余下的测试，不再检查列表中是否包含`'extra cheese'`和`'pepperoni'`。其结果是，将添加顾客点的第一种配料，但不会添加其他的配料：

```
Adding mushrooms.

Finished making your pizza!
```

总之，如果你只想执行一个代码块，就使用`if-elif-else`结构；如果要运行多个代码块，就使用一系列独立的`if`语句。

> **动手试一试**
>
> **5-3 外星人颜色#1**：假设在游戏中刚射杀了一个外星人，请创建一个名为`alien_color`的变量，并将其设置为`'green'`、`'yellow'`或`'red'`。
>
> - 编写一条`if`语句，检查外星人是否是绿色的；如果是，就打印一条消息，指出玩家获得了5个点。
> - 编写这个程序的两个版本，在一个版本中上述测试通过了，而在另一个版本中未通过（未通过测试时没有输出）。
>
> **5-4 外星人颜色#2**：像练习5-3那样设置外星人的颜色，并编写一个`if-else`结构。
>
> - 如果外星人是绿色的，就打印一条消息，指出玩家因射杀该外星人获得了5个点。
> - 如果外星人不是绿色的，就打印一条消息，指出玩家获得了10个点。
> - 编写这个程序的两个版本，在一个版本中执行`if`代码块，而在另一个版本中执行`else`代码块。
>
> **5-5 外星人颜色#3**：将练习5-4中的`if-else`结构改为`if-elif-else`结构。
>
> - 如果外星人是绿色的，就打印一条消息，指出玩家获得了5个点。
> - 如果外星人是黄色的，就打印一条消息，指出玩家获得了10个点。
> - 如果外星人是红色的，就打印一条消息，指出玩家获得了15个点。
> - 编写这个程序的三个版本，它们分别在外星人为绿色、黄色和红色时打印一条消息。
>
> **5-6 人生的不同阶段**：设置变量`age`的值，再编写一个`if-elif-else`结构，根据`age`的值判断处于人生的哪个阶段。
>
> - 如果一个人的年龄小于2岁，就打印一条消息，指出他是婴儿。
> - 如果一个人的年龄为2（含）～4岁，就打印一条消息，指出他正蹒跚学步。
> - 如果一个人的年龄为4（含）～13岁，就打印一条消息，指出他是儿童。
> - 如果一个人的年龄为13（含）～20岁，就打印一条消息，指出他是青少年。
> - 如果一个人的年龄为20（含）～65岁，就打印一条消息，指出他是成年人。
> - 如果一个人的年龄超过65（含）岁，就打印一条消息，指出他是老年人。
>
> **5-7 喜欢的水果**：创建一个列表，其中包含你喜欢的水果，再编写一系列独立的`if`语句，检查列表中是否包含特定的水果。
>
> - 将该列表命名为`favorite_fruits`，并在其中包含三种水果。
> - 编写5条`if`语句，每条都检查某种水果是否包含在列表中，如果包含在列表中，就打印一条消息，如“You really like bananas!”。

### **5.4　使用 if 语句处理列表**

通过结合使用`if`语句和列表，可完成一些有趣的任务：对列表中特定的值做特殊处理；高效地管理不断变化的情形，如餐馆是否还有特定的食材；证明代码在各种情形下都将按预期那样运行。

#### **5.4.1　检查特殊元素**

本章开头通过一个简单示例演示了如何处理特殊值`'bmw'`——它需要采用不同的格式进行打印。既然你对条件测试和`if`语句有了大致的认识，下面来进一步研究如何检查列表中的特殊值，并对其做合适的处理。

继续使用前面的比萨店示例。这家比萨店在制作比萨时，每添加一种配料都打印一条消息。通过创建一个列表，在其中包含顾客点的配料，并使用一个循环来指出添加到比萨中的配料，可以以极高的效率编写这样的代码：

**toppings.py**

```
requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']

for requested_topping in requested_toppings:
    print("Adding " + requested_topping + ".")

print("\nFinished making your pizza!")
```

输出很简单，因为上述代码不过是一个简单的`for`循环：

```
Adding mushrooms.
Adding green peppers.
Adding extra cheese.

Finished making your pizza!
```

然而，如果比萨店的青椒用完了，该如何处理呢？为妥善地处理这种情况，可在`for`循环中包含一条`if`语句：

```
  requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']

  for requested_topping in requested_toppings:
❶     if requested_topping == 'green peppers':
          print("Sorry, we are out of green peppers right now.")
❷     else:
          print("Adding " + requested_topping + ".")

  print("\nFinished making your pizza!")
```

这里在比萨中添加每种配料前都进行检查。❶处的代码检查顾客点的是否是青椒，如果是，就显示一条消息，指出不能点青椒的原因。❷处的`else`代码块确保其他配料都将添加到比萨中。

输出表明，妥善地处理了顾客点的每种配料：

```
Adding mushrooms.
Sorry, we are out of green peppers right now.
Adding extra cheese.

Finished making your pizza!
```

#### **5.4.2　确定列表不是空的**

到目前为止，对于处理的每个列表都做了一个简单的假设，即假设它们都至少包含一个元素。我们马上就要让用户来提供存储在列表中的信息，因此不能再假设循环运行时列表不是空的。有鉴于此，在运行`for`循环前确定列表是否为空很重要。

下面在制作比萨前检查顾客点的配料列表是否为空。如果列表是空的，就向顾客确认他是否要点普通比萨；如果列表不为空，就像前面的示例那样制作比萨：

```
❶ requested_toppings = []

❷ if requested_toppings:
      for requested_topping in requested_toppings:
          print("Adding " + requested_topping + ".")
      print("\nFinished making your pizza!")
❸ else:
      print("Are you sure you want a plain pizza?")
```

在这里，我们首先创建了一个空列表，其中不包含任何配料（见❶）。在❷处我们进行了简单检查，而不是直接执行`for`循环。在`if`语句中将列表名用在条件表达式中时，Python 将在列表至少包含一个元素时返回`True`，并在列表为空时返回`False`。如果`requested_toppings`不为空，就运行与前一个示例相同的`for`循环；否则，就打印一条消息，询问顾客是否确实要点不加任何配料的普通比萨（见❸）。

在这里，这个列表为空，因此输出如下——询问顾客是否确实要点普通比萨：

```
Are you sure you want a plain pizza?
```

如果这个列表不为空，将显示在比萨中添加的各种配料的输出。

#### **5.4.3　使用多个列表**

顾客的要求往往五花八门，在比萨配料方面尤其如此。如果顾客要在比萨中添加炸薯条，该怎么办呢？可使用列表和`if`语句来确定能否满足顾客的要求。

来看看在制作比萨前如何拒绝怪异的配料要求。下面的示例定义了两个列表，其中第一个列表包含比萨店供应的配料，而第二个列表包含顾客点的配料。这次对于`requested_toppings`中的每个元素，都检查它是否是比萨店供应的配料，再决定是否在比萨中添加它：

```
❶ available_toppings = ['mushrooms', 'olives', 'green peppers',
                        'pepperoni', 'pineapple', 'extra cheese']

❷ requested_toppings = ['mushrooms', 'french fries', 'extra cheese']

❸ for requested_topping in requested_toppings:
❹     if requested_topping in available_toppings:
          print("Adding " + requested_topping + ".")
❺     else:
          print("Sorry, we don't have " + requested_topping + ".")

  print("\nFinished making your pizza!")
```

在❶处，我们定义了一个列表，其中包含比萨店供应的配料。请注意，如果比萨店供应的配料是固定的，也可使用一个元组来存储它们。在❷处，我们又创建了一个列表，其中包含顾客点的配料，请注意那个不同寻常的配料——`'french fries'`。在❸处，我们遍历顾客点的配料列表。在这个循环中，对于顾客点的每种配料，我们都检查它是否包含在供应的配料列表中（见❹）；如果答案是肯定的，就将其加入到比萨中，否则将运行`else`代码块（见❺）：打印一条消息，告诉顾客不供应这种配料。

这些代码的输出整洁而详实：

```
Adding mushrooms.
Sorry, we don't have french fries.
Adding extra cheese.

Finished making your pizza!
```

通过为数不多的几行代码，我们高效地处理了一种真实的情形！

> **动手试一试**
>
> **5-8 以特殊方式跟管理员打招呼**：创建一个至少包含5个用户名的列表，且其中一个用户名为`'admin'`。想象你要编写代码，在每位用户登录网站后都打印一条问候消息。遍历用户名列表，并向每位用户打印一条问候消息。
>
> - 如果用户名为`'admin'`，就打印一条特殊的问候消息，如“Hello admin, would you like to see a status report?”。
> - 否则，打印一条普通的问候消息，如“Hello Eric, thank you for logging in again”。
>
> **5-9 处理没有用户的情形**：在为完成练习5-8编写的程序中，添加一条`if`语句，检查用户名列表是否为空。
>
> - 如果为空，就打印消息“We need to find some users!”。
> - 删除列表中的所有用户名，确定将打印正确的消息。
>
> **5-10 检查用户名**：按下面的说明编写一个程序，模拟网站确保每位用户的用户名都独一无二的方式。
>
> - 创建一个至少包含5个用户名的列表，并将其命名为`current_users`。
> - 再创建一个包含5个用户名的列表，将其命名为`new_users`，并确保其中有一两个用户名也包含在列表`current_users`中。
> - 遍历列表`new_users`，对于其中的每个用户名，都检查它是否已被使用。如果是这样，就打印一条消息，指出需要输入别的用户名；否则，打印一条消息，指出这个用户名未被使用。
> - 确保比较时不区分大小写；换句话说，如果用户名`'John'`已被使用，应拒绝用户名`'JOHN'`。
>
> **5-11 序数**：序数表示位置，如 1st 和 2nd。大多数序数都以 th 结尾，只有1、2和3例外。
>
> - 在一个列表中存储数字1~9。
> - 遍历这个列表。
> - 在循环中使用一个`if-elif-else`结构，以打印每个数字对应的序数。输出内容应为`1st`、`2nd`、`3rd`、`4th`、`5th`、`6th`、`7th`、`8th`和`9th`，但每个序数都独占一行。

### **5.5　设置 if 语句的格式**

本章的每个示例都展示了良好的格式设置习惯。在条件测试的格式设置方面，PEP 8 提供的唯一建议是，在诸如`==`、`>=`和`<=`等比较运算符两边各添加一个空格，例如，`if age < 4:`要比`if age<4:`好。

这样的空格不会影响 Python 对代码的解读，而只是让代码阅读起来更容易。

> **动手试一试**
>
> **5-12 设置if语句的格式**：审核你在本章编写的程序，确保正确地设置了条件测试的格式。
>
> **5-13 自己的想法**：与刚拿起本书时相比，现在你是一名能力更强的程序员了。鉴于你对如何在程序中模拟现实情形有了更深入的认识，你可以考虑使用程序来解决一些问题。随着编程技能不断提高，你可能想解决一些问题，请将这方面的想法记录下来。想想你可能想编写的游戏、想研究的数据集以及想创建的 Web 应用程序。

### **5.6　小结**

在本章中，你学习了如何编写结果要么为`True`要么为`False`的条件测试。你学习了如何编写简单的`if`语句、`if-else`语句和`if-elif-else`结构。在程序中，你使用了这些结构来测试特定的条件，以确定这些条件是否满足。你学习了如何在利用高效的`for`循环的同时，以不同于其他元素的方式对特定的列表元素进行处理。你还再次学习了 Python 就代码格式方面提出的建议，这可确保即便你编写的程序越来越复杂，其代码依然易于阅读和理解。

在第6章，你将学习 Python 字典。字典类似于列表，但让你能够将不同的信息关联起来。你将学习如何创建和遍历字典，以及如何将字典同列表和`if`语句结合起来使用。学习字典让你能够模拟更多现实世界的情形。

------



## 第6章　字典

### **老齐导读**

字典是一种不同于列表的对象类型，它是以“键值对”为元素，每个键值对可以理解为一种映射关系。

通过书中的操作示例，并对如下内容给予总结：

- 创建字典
- 访问字典
- 增加、删除、修改键值对

上一章，用 for 循环可以遍历列表，本章用 for 循环也可以遍历字典的“键”。

参照前面已经强调的一种学习方法，即使用`dir`和`help`两个函数查看对象方法和属性，也对字典的方法和属性进行研究，并且与书中有关操作对比。

![enter image description here](https://images.gitbook.cn/2910e830-8817-11e9-b6f4-77ea8c81f44e)

> 在本章中，你将学习能够将相关信息关联起来的 Python 字典。你将学习如何访问和修改字典中的信息。鉴于字典可存储的信息量几乎不受限制，因此我们会演示如何遍历字典中的数据。另外，你还将学习存储字典的列表、存储列表的字典和存储字典的字典。
>
> 理解字典后，你就能够更准确地为各种真实物体建模。你可以创建一个表示人的字典，然后想在其中存储多少信息就存储多少信息：姓名、年龄、地址、职业以及要描述的任何方面。你还能够存储任意两种相关的信息，如一系列单词及其含义，一系列人名及其喜欢的数字，以及一系列山脉及其海拔等。

### **6.1　一个简单的字典**

来看一个游戏，其中包含一些外星人，这些外星人的颜色和点数各不相同。下面是一个简单的字典，存储了有关特定外星人的信息：

**alien.py**

```
alien_0 = {'color': 'green', 'points': 5}

print(alien_0['color'])
print(alien_0['points'])
```

字典`alien_0`存储了外星人的颜色和点数。使用两条`print`语句来访问并打印这些信息，如下所示：

```
green
5
```

与大多数编程概念一样，要熟练使用字典，也需要一段时间的练习。使用字典一段时间后，你就会明白为何它们能够高效地模拟现实世界中的情形。

### **6.2　使用字典**

在 Python 中，**字典**是一系列**键—值对**。每个**键**都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何 Python 对象用作字典中的值。

在 Python 中，字典用放在花括号`{}`中的一系列键—值对表示，如前面的示例所示：

```
alien_0 = {'color': 'green', 'points': 5}
```

**键—值**对是两个相关联的值。指定键时，Python 将返回与之相关联的值。键和值之间用冒号分隔，而键—值对之间用逗号分隔。在字典中，你想存储多少个键—值对都可以。

最简单的字典只有一个键—值对，如下述修改后的字典`alien_0`所示：

```
alien_0 = {'color': 'green'}
```

这个字典只存储了一项有关`alien_0`的信息，具体地说是这个外星人的颜色。在这个字典中，字符串`'color'`是一个键，与之相关联的值为`'green'`。

#### **6.2.1　访问字典中的值**

要获取与键相关联的值，可依次指定字典名和放在方括号内的键，如下所示：

```
alien_0 = {'color': 'green'}
print(alien_0['color'])
```

这将返回字典`alien_0`中与键`'color'`相关联的值：

```
green
```

字典中可包含任意数量的键—值对。例如，下面是最初的字典`alien_0`，其中包含两个键—值对：

```
alien_0 = {'color': 'green', 'points': 5}
```

现在，你可以访问外星人`alien_0`的颜色和点数。如果玩家射杀了这个外星人，你就可以使用下面的代码来确定玩家应获得多少个点：

```
  alien_0 = {'color': 'green', 'points': 5}

❶ new_points = alien_0['points']
❷ print("You just earned " + str(new_points) + " points!")
```

上述代码首先定义了一个字典，然后从这个字典中获取与键`'points'`相关联的值（见❶），并将这个值存储在变量`new_points`中。接下来，将这个整数转换为字符串，并打印一条消息，指出玩家获得了多少个点（见❷）：

```
You just earned 5 points!
```

如果你在有外星人被射杀时都运行这段代码，就会获取该外星人的点数。

#### **6.2.2　添加键—值对**

字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用方括号括起的键和相关联的值。

下面在字典`alien_0`中添加两项信息：外星人的 *x* 坐标和 *y* 坐标，让我们能够在屏幕的特定位置显示该外星人。我们将这个外星人放在屏幕左边缘，且离屏幕上边缘25像素的地方。由于屏幕坐标系的原点通常为左上角，因此要将该外星人放在屏幕左边缘，可将 *x* 坐标设置为0；要将该外星人放在离屏幕顶部25像素的地方，可将 *y* 坐标设置为25，如下所示：

```
  alien_0 = {'color': 'green', 'points': 5}
  print(alien_0)

❶ alien_0['x_position'] = 0
❷ alien_0['y_position'] = 25
  print(alien_0)
```

我们首先定义了前面一直在使用的字典，然后打印这个字典，以显示其信息快照。在❶处，我们在这个字典中新增了一个键—值对，其中的键为`'x_position'`，而值为`0`。在❷处，我们重复这样的操作，但使用的键为`'y_position'`。打印修改后的字典时，将看到这两个新增的键—值对：

```
{'color': 'green', 'points': 5}
{'color': 'green', 'points': 5, 'y_position': 25, 'x_position': 0}
```

这个字典的最终版本包含四个键—值对，其中原来的两个指定外星人的颜色和点数，而新增的两个指定位置。注意，键—值对的排列顺序与添加顺序不同。Python 不关心键—值对的添加顺序，而只关心键和值之间的关联关系。

#### **6.2.3　先创建一个空字典**

有时候，在空字典中添加键—值对是为了方便，而有时候必须这样做。为此，可先使用一对空的花括号定义一个字典，再分行添加各个键—值对。例如，下例演示了如何以这种方式创建字典`alien_0`：

```
alien_0 = {}

alien_0['color'] = 'green'
alien_0['points'] = 5

print(alien_0)
```

这里首先定义了空字典`alien_0`，再在其中添加颜色和点数，得到前述示例一直在使用的字典：

```
{'color': 'green', 'points': 5}
```

使用字典来存储用户提供的数据或在编写能自动生成大量键—值对的代码时，通常都需要先定义一个空字典。

#### **6.2.4　修改字典中的值**

要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。例如，假设随着游戏的进行，需要将一个外星人从绿色改为黄色：

```
alien_0 = {'color': 'green'}
print("The alien is " + alien_0['color'] + ".")

alien_0['color'] = 'yellow'
print("The alien is now " + alien_0['color'] + ".")
```

我们首先定义了一个表示外星人`alien_0`的字典，其中只包含这个外星人的颜色。接下来，我们将与键`'color'`相关联的值改为`'yellow'`。输出表明，这个外星人确实从绿色变成了黄色：

```
The alien is green.
The alien is now yellow.
```

来看一个更有趣的例子：对一个能够以不同速度移动的外星人的位置进行跟踪。为此，我们将存储该外星人的当前速度，并据此确定该外星人将向右移动多远：

```
  alien_0 = {'x_position': 0, 'y_position': 25, 'speed': 'medium'}
  print("Original x-position: " + str(alien_0['x_position']))

  # 向右移动外星人
  # 据外星人当前速度决定将其移动多远
❶ if alien_0['speed'] == 'slow':
      x_increment = 1
  elif alien_0['speed'] == 'medium':
      x_increment = 2
  else:
      # 这个外星人的速度一定很快
      x_increment = 3

  # 新位置等于老位置加上增量
❷ alien_0['x_position'] = alien_0['x_position'] + x_increment

  print("New x-position: " + str(alien_0['x_position']))
```

我们首先定义了一个外星人，其中包含初始的 *x* 坐标和 *y* 坐标，还有速度`'medium'`。出于简化考虑，我们省略了颜色和点数，但即便包含这些键-值对，这个示例的工作原理也不会有任何变化。我们还打印了`x_position`的初始值，旨在让用户知道这个外星人向右移动了多远。

在❶处，使用了一个`if-elif-else`结构来确定外星人应向右移动多远，并将这个值存储在变量`x_increment`中。如果外星人的速度为`'slow'`，它将向右移动一个单位；如果速度为`'medium'`，将向右移动两个单位；如果为`'fast'`，将向右移动三个单位。确定移动量后，将其与`x_position`的当前值相加（见❷），再将结果关联到字典中的键`x_position`。

由于这是一个速度中等的外星人，因此其位置将向右移动两个单位：

```
Original x-position: 0
New x-position: 2
```

这种技术很棒：通过修改外星人字典中的值，可改变外星人的行为。例如，要将这个速度中等的外星人变成速度很快的外星人，可添加如下代码行：

```
alien_0['speed'] = 'fast'
```

这样，再次运行这些代码时，其中的`if-elif-else`结构将把一个更大的值赋给变量`x_increment`。

#### **6.2.5　删除键—值对**

对于字典中不再需要的信息，可使用`del`语句将相应的键—值对彻底删除。使用`del`语句时，必须指定字典名和要删除的键。

例如，下面的代码从字典`alien_0`中删除键`'points'`及其值：

```
  alien_0 = {'color': 'green', 'points': 5}
  print(alien_0)

❶ del alien_0['points']
  print(alien_0)
```

❶处的代码行让 Python 将键`'points'`从字典`alien_0`中删除，同时删除与这个键相关联的值。输出表明，键`'points'`及其值`5`已从字典中删除，但其他键—值对未受影响：

```
{'color': 'green', 'points': 5}
{'color': 'green'}
```

> **注意**　
>
> 删除的键—值对永远消失了。

#### **6.2.6　由类似对象组成的字典**

在前面的示例中，字典存储的是一个对象（游戏中的一个外星人）的多种信息，但你也可以使用字典来存储众多对象的同一种信息。例如，假设你要调查很多人，询问他们最喜欢的编程语言，可使用一个字典来存储这种简单调查的结果，如下所示：

```
favorite_languages = {
    'jen': 'python',
    'sarah': 'c',
    'edward': 'ruby',
    'phil': 'python',
    }
```

正如你看到的，我们将一个较大的字典放在了多行中。其中每个键都是一个被调查者的名字，而每个值都是被调查者喜欢的语言。确定需要使用多行来定义字典时，在输入左花括号后按回车键，再在下一行缩进四个空格，指定第一个键—值对，并在它后面加上一个逗号。此后你再次按回车键时，文本编辑器将自动缩进后续键—值对，且缩进量与第一个键—值对相同。

定义好字典后，在最后一个键—值对的下一行添加一个右花括号，并缩进四个空格，使其与字典中的键对齐。另外一种不错的做法是在最后一个键—值对后面也加上逗号，为以后在下一行添加键—值对做好准备。

> **注意**　
>
> 对于较长的列表和字典，大多数编辑器都有以类似方式设置其格式的功能。对于较长的字典，还有其他一些可行的格式设置方式，因此在你的编辑器或其他源代码中，你可能会看到稍微不同的格式设置方式。

给定被调查者的名字，可使用这个字典轻松地获悉他喜欢的语言：

**favorite_languages.py**

```
  favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'ruby',
      'phil': 'python',
      }

❶ print("Sarah's favorite language is " +
❷     favorite_languages['sarah'].title() +
❸     ".")
```

为获悉`Sarah`喜欢的语言，我们使用如下代码：

```
favorite_languages['sarah']
```

在`print`语句中，我们使用了这种语法（见❷）；输出指出了 Sarah 喜欢的语言：

```
Sarah's favorite language is C.
```

这个示例还演示了如何将较长的`print`语句分成多行。单词`print`比大多数字典名都短，因此让输出的第一部分紧跟在左括号后面是合理的（见❶）。请选择在合适的地方拆分要打印的内容，并在第一行末尾（见❷）加上一个拼接运算符（`+`）。按回车键进入`print`语句的后续各行，并使用 Tab 键将它们对齐并缩进一级。指定要打印的所有内容后，在`print`语句的最后一行末尾加上右括号（见❸）。

> **动手试一试**
>
> **6-1 人**：使用一个字典来存储一个熟人的信息，包括名、姓、年龄和居住的城市。该字典应包含键`first_name`、`last_name`、`age`和`city`。将存储在该字典中的每项信息都打印出来。
>
> **6-2 喜欢的数字**：使用一个字典来存储一些人喜欢的数字。请想出5个人的名字，并将这些名字用作字典中的键；想出每个人喜欢的一个数字，并将这些数字作为值存储在字典中。打印每个人的名字和喜欢的数字。为让这个程序更有趣，通过询问朋友确保数据是真实的。
>
> **6-3 词汇表**：Python 字典可用于模拟现实生活中的字典，但为避免混淆，我们将后者称为词汇表。
>
> - 想出你在前面学过的5个编程词汇，将它们用作词汇表中的键，并将它们的含义作为值存储在词汇表中。
> - 以整洁的方式打印每个词汇及其含义。为此，你可以先打印词汇，在它后面加上一个冒号，再打印词汇的含义；也可在一行打印词汇，再使用换行符（`\n`）插入一个空行，然后在下一行以缩进的方式打印词汇的含义。

### **6.3　遍历字典**

一个 Python 字典可能只包含几个键—值对，也可能包含数百万个键—值对。鉴于字典可能包含大量的数据，Python 支持对字典遍历。字典可用于以各种方式存储信息，因此有多种遍历字典的方式：可遍历字典的所有键—值对、键或值。

#### **6.3.1　遍历所有的键—值对**

探索各种遍历方法前，先来看一个新字典，它用于存储有关网站用户的信息。下面的字典存储一名用户的用户名、名和姓：

```
user_0 = {
    'username': 'efermi',
    'first': 'enrico',
    'last': 'fermi',
    }
```

利用本章前面介绍过的知识，可访问`user_0`的任何一项信息，但如果要获悉该用户字典中的所有信息，该怎么办呢？可以使用一个`for`循环来遍历这个字典：

**user.py**

```
  user_0 = {
      'username': 'efermi',
      'first': 'enrico',
      'last': 'fermi',
      }

❶ for key, value in user_0.items():
❷     print("\nKey: " + key)
❸     print("Value: " + value)
```

如❶所示，要编写用于遍历字典的`for`循环，可声明两个变量，用于存储键—值对中的键和值。对于这两个变量，可使用任何名称。下面的代码使用了简单的变量名，这完全可行：

```
for k, v in user_0.items()
```

`for`语句的第二部分包含字典名和方法`items()`（见❶），它返回一个键—值对列表。接下来，`for`循环依次将每个键—值对存储到指定的两个变量中。在前面的示例中，我们使用这两个变量来打印每个键（见❷）及其相关联的值（见❸）。第一条`print`语句中的`"\n"`确保在输出每个键—值对前都插入一个空行：

```
Key: last
Value: fermi

Key: first
Value: enrico

Key: username
Value: efermi
```

注意，即便遍历字典时，键—值对的返回顺序也与存储顺序不同。Python 不关心键—值对的存储顺序，而只跟踪键和值之间的关联关系。

在6.2.6节的示例 favorite_languages.py 中，字典存储的是不同人的同一种信息；对于类似这样的字典，遍历所有的键—值对很合适。如果遍历字典`favorite_languages`，将得到其中每个人的姓名和喜欢的编程语言。由于其中的键都是人名，而值都是语言，因此我们在循环中使用变量`name`和`language`，而不是`key`和`value`，这让人更容易明白循环的作用：

**favorite_languages.py**

```
  favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'ruby',
      'phil': 'python',
      }

❶ for name, language in favorite_languages.items():
❷     print(name.title() + "'s favorite language is " +
          language.title() + ".")
```

❶处的代码让 Python 遍历字典中的每个键—值对，并将键存储在变量`name`中，而将值存储在变量`language`中。这些描述性名称能够让人非常轻松地明白`print`语句（见❷）是做什么的。

仅使用几行代码，我们就将全部调查结果显示出来了：

```
Jen's favorite language is Python.
Sarah's favorite language is C.
Phil's favorite language is Python.
Edward's favorite language is Ruby.
```

即便字典存储的是上千乃至上百万人的调查结果，这种循环也管用。

#### **6.3.2　遍历字典中的所有键**

在不需要使用字典中的值时，方法`keys()`很有用。下面来遍历字典`favorite_languages`，并将每个被调查者的名字都打印出来：

```
  favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'ruby',
      'phil': 'python',
      }

❶ for name in favorite_languages.keys():
      print(name.title())
```

❶处的代码行让 Python 提取字典`favorite_languages`中的所有键，并依次将它们存储到变量`name`中。输出列出了每个被调查者的名字：

```
Jen
Sarah
Phil
Edward
```

遍历字典时，会默认遍历所有的键，因此，如果将上述代码中的`for name in favorite_languages.keys():`替换为`for name in favorite_languages:`，输出将不变。

如果显式地使用方法`keys()`可让代码更容易理解，你可以选择这样做，但如果你愿意，也可省略它。

在这种循环中，可使用当前键来访问与之相关联的值。下面来打印两条消息，指出两位朋友喜欢的语言。我们像前面一样遍历字典中的名字，但在名字为指定朋友的名字时，打印一条消息，指出其喜欢的语言：

```
  favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'ruby',
      'phil': 'python',
      }

❶ friends = ['phil', 'sarah']
  for name in favorite_languages.keys():
      print(name.title())

❷     if name in friends:
          print("  Hi " + name.title() +
              ", I see your favorite language is " +
❸             favorite_languages[name].title() + "!")
```

在❶处，我们创建了一个列表，其中包含我们要通过打印消息，指出其喜欢的语言的朋友。在循环中，我们打印每个人的名字，并检查当前的名字是否在列表`friends`中（见❷）。如果在列表中，就打印一句特殊的问候语，其中包含这位朋友喜欢的语言。为访问喜欢的语言，我们使用了字典名，并将变量`name`的当前值作为键（见❸）。每个人的名字都会被打印，但只对朋友打印特殊消息：

```
Edward
Phil
  Hi Phil, I see your favorite language is Python!
Sarah
  Hi Sarah, I see your favorite language is C!
Jen
```

你还可以使用`keys()`确定某个人是否接受了调查。下面的代码确定 Erin 是否接受了调查：

```
  favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'ruby',
      'phil': 'python',
      }

❶ if 'erin' not in favorite_languages.keys():
      print("Erin, please take our poll!")
```

方法`keys()`并非只能用于遍历；实际上，它返回一个列表，其中包含字典中的所有键，因此❶处的代码行只是核实`'erin'`是否包含在这个列表中。由于她并不包含在这个列表中，因此打印一条消息，邀请她参加调查：

```
Erin, please take our poll!
```

#### **6.3.3　按顺序遍历字典中的所有键**

字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。这不是问题，因为通常你想要的只是获取与键相关联的正确的值。

要以特定的顺序返回元素，一种办法是在`for`循环中对返回的键进行排序。为此，可使用函数`sorted()`来获得按特定顺序排列的键列表的副本：

```
favorite_languages = {
    'jen': 'python',
    'sarah': 'c',
    'edward': 'ruby',
    'phil': 'python',
    }

for name in sorted(favorite_languages.keys()):
    print(name.title() + ", thank you for taking the poll.")
```

这条`for`语句类似于其他`for`语句，但对方法`dictionary.keys()`的结果调用了函数`sorted()`。这让 Python 列出字典中的所有键，并在遍历前对这个列表进行排序。输出表明，按顺序显示了所有被调查者的名字：

```
Edward, thank you for taking the poll.
Jen, thank you for taking the poll.
Phil, thank you for taking the poll.
Sarah, thank you for taking the poll.
```

#### **6.3.4　遍历字典中的所有值**

如果你感兴趣的主要是字典包含的值，可使用方法`values()`，它返回一个值列表，而不包含任何键。例如，如果我们想获得一个这样的列表，即其中只包含被调查者选择的各种语言，而不包含被调查者的名字，可以这样做：

```
favorite_languages = {
    'jen': 'python',
    'sarah': 'c',
    'edward': 'ruby',
    'phil': 'python',
    }

print("The following languages have been mentioned:")
for language in favorite_languages.values():
    print(language.title())
```

这条`for`语句提取字典中的每个值，并将它们依次存储到变量`language`中。通过打印这些值，就获得了一个列表，其中包含被调查者选择的各种语言：

```
The following languages have been mentioned:
Python
C
Python
Ruby
```

这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量的重复项。为剔除重复项，可使用集合（set）。**集合**类似于列表，但每个元素都必须是独一无二的：

```
  favorite_languages = {
      'jen': 'python',
      'sarah': 'c',
      'edward': 'ruby',
      'phil': 'python',
      }

  print("The following languages have been mentioned:")
❶ for language in set(favorite_languages.values()):
      print(language.title())
```

通过对包含重复元素的列表调用`set()`，可让 Python 找出列表中独一无二的元素，并使用这些元素来创建一个集合。在❶处，我们使用了`set()`来提取`favorite_languages.values()`中不同的语言。

结果是一个不重复的列表，其中列出了被调查者提及的所有语言：

```
The following languages have been mentioned:
Python
C
Ruby
```

随着你更深入地学习 Python，经常会发现它内置的功能可帮助你以希望的方式处理数据。

> **动手试一试**
>
> **6-4 词汇表2**：既然你知道了如何遍历字典，现在请整理你为完成练习6-3而编写的代码，将其中的一系列`print`语句替换为一个遍历字典中的键和值的循环。确定该循环正确无误后，再在词汇表中添加5个 Python 术语。当你再次运行这个程序时，这些新术语及其含义将自动包含在输出中。
>
> **6-5 河流**：创建一个字典，在其中存储三条大河流及其流经的国家。其中一个键—值对可能是`'nile': 'egypt'`。
>
> - 使用循环为每条河流打印一条消息，如“The Nile runs through Egypt.”。
> - 使用循环将该字典中每条河流的名字都打印出来。
> - 使用循环将该字典包含的每个国家的名字都打印出来。
>
> **6-6 调查**：在6.3.1节编写的程序 favorite_languages.py 中执行以下操作。
>
> - 创建一个应该会接受调查的人员名单，其中有些人已包含在字典中，而其他人未包含在字典中。
> - 遍历这个人员名单，对于已参与调查的人，打印一条消息表示感谢。对于还未参与调查的人，打印一条消息邀请他参与调查。

### **6.4　嵌套**

有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为**嵌套**。你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。正如下面的示例将演示的，嵌套是一项强大的功能。

#### **6.4.1　字典列表**

字典`alien_0`包含一个外星人的各种信息，但无法存储第二个外星人的信息，更别说屏幕上全部外星人的信息了。如何管理成群结队的外星人呢？一种办法是创建一个外星人列表，其中每个外星人都是一个字典，包含有关该外星人的各种信息。例如，下面的代码创建一个包含三个外星人的列表：

**aliens.py**

```
  alien_0 = {'color': 'green', 'points': 5}
  alien_1 = {'color': 'yellow', 'points': 10}
  alien_2 = {'color': 'red', 'points': 15}

❶ aliens = [alien_0, alien_1, alien_2]

  for alien in aliens:
      print(alien)
```

我们首先创建了三个字典，其中每个字典都表示一个外星人。在❶处，我们将这些字典都放到一个名为`aliens`的列表中。最后，我们遍历这个列表，并将每个外星人都打印出来：

```
{'color': 'green', 'points': 5}
{'color': 'yellow', 'points': 10}
{'color': 'red', 'points': 15}
```

更符合现实的情形是，外星人不止三个，且每个外星人都是使用代码自动生成的。在下面的示例中，我们使用`range()`生成了30个外星人：

```
  # 创建一个用于存储外星人的空列表
  aliens = []

  # 创建30个绿色的外星人
❶ for alien_number in range(30):
❷     new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
❸     aliens.append(new_alien)

  # 显示前五个外星人
❹ for alien in aliens[:5]:
      print(alien)
  print("...")

  # 显示创建了多少个外星人
❺ print("Total number of aliens: " + str(len(aliens)))
```

在这个示例中，首先创建了一个空列表，用于存储接下来将创建的所有外星人。在❶处，`range()`返回一系列数字，其唯一的用途是告诉 Python 我们要重复这个循环多少次。每次执行这个循环时，都创建一个外星人（见❷），并将其附加到列表`aliens`末尾（见❸）。在❹处，使用一个切片来打印前五个外星人；在❺处，打印列表的长度，以证明确实创建了30个外星人：

```
{'speed': 'slow', 'color': 'green', 'points': 5}
{'speed': 'slow', 'color': 'green', 'points': 5}
{'speed': 'slow', 'color': 'green', 'points': 5}
{'speed': 'slow', 'color': 'green', 'points': 5}
{'speed': 'slow', 'color': 'green', 'points': 5}
...

Total number of aliens: 30
```

这些外星人都具有相同的特征，但在 Python 看来，每个外星人都是独立的，这让我们能够独立地修改每个外星人。

在什么情况下需要处理成群结队的外星人呢？想象一下，可能随着游戏的进行，有些外星人会变色且移动速度会加快。必要时，我们可以使用`for`循环和`if`语句来修改某些外星人的颜色。例如，要将前三个外星人修改为黄色的、速度为中等且值10个点，可以这样做：

```
# 创建一个用于存储外星人的空列表
aliens = []

# 创建30个绿色的外星人
for alien_number in range (0,30):
    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
    aliens.append(new_alien)

for alien in aliens[0:3]:
    if alien['color'] == 'green':
        alien['color'] = 'yellow'
        alien['speed'] = 'medium'
        alien['points'] = 10

# 显示前五个外星人
for alien in aliens[0:5]:
    print(alien)
print("...")
```

鉴于我们要修改前三个外星人，需要遍历一个只包含这些外星人的切片。当前，所有外星人都是绿色的，但情况并非总是如此，因此我们编写了一条`if`语句来确保只修改绿色外星人。如果外星人是绿色的，我们就将其颜色改为`'yellow'`，将其速度改为`'medium'`，并将其点数改为`10`，如下面的输出所示：

```
{'speed': 'medium', 'color': 'yellow', 'points': 10}
{'speed': 'medium', 'color': 'yellow', 'points': 10}
{'speed': 'medium', 'color': 'yellow', 'points': 10}
{'speed': 'slow', 'color': 'green', 'points': 5}
{'speed': 'slow', 'color': 'green', 'points': 5}
...
```

你可以进一步扩展这个循环，在其中添加一个`elif`代码块，将黄色外星人改为移动速度快且值15个点的红色外星人，如下所示（这里只列出了循环，而没有列出整个程序）：

```
for alien in aliens[0:3]:
    if alien['color'] == 'green':
        alien['color'] = 'yellow'
        alien['speed'] = 'medium'
        alien['points'] = 10
    elif alien['color'] == 'yellow':
        alien['color'] = 'red'
        alien['speed'] = 'fast'
        alien['points'] = 15
```

经常需要在列表中包含大量的字典，而其中每个字典都包含特定对象的众多信息。例如，你可能需要为网站的每个用户创建一个字典（就像6.3.1节的 user.py 中那样），并将这些字典存储在一个名为`users`的列表中。在这个列表中，所有字典的结构都相同，因此你可以遍历这个列表，并以相同的方式处理其中的每个字典。

#### **6.4.2　在字典中存储列表**

有时候，需要将列表存储在字典中，而不是将字典存储在列表中。例如，你如何描述顾客点的比萨呢？如果使用列表，只能存储要添加的比萨配料；但如果使用字典，就不仅可在其中包含配料列表，还可包含其他有关比萨的描述。

在下面的示例中，存储了比萨的两方面信息：外皮类型和配料列表。其中的配料列表是一个与键`'toppings'`相关联的值。要访问该列表，我们使用字典名和键`'toppings'`，就像访问字典中的其他值一样。这将返回一个配料列表，而不是单个值：

**pizza.py**

```
  # 存储所点比萨的信息
❶ pizza = {
      'crust': 'thick',
      'toppings': ['mushrooms', 'extra cheese'],
      }

  # 概述所点的比萨
❷ print("You ordered a " + pizza['crust'] + "-crust pizza " +
      "with the following toppings:")

❸ for topping in pizza['toppings']:
      print("\t" + topping)
```

我们首先创建了一个字典，其中存储了有关顾客所点比萨的信息（见❶）。在这个字典中，一个键是`'crust'`，与之相关联的值是字符串`'thick'`；下一个键是`'toppings'`，与之相关联的值是一个列表，其中存储了顾客要求添加的所有配料。制作前我们概述了顾客所点的比萨（见❷）。为打印配料，我们编写了一个`for`循环（见❸）。为访问配料列表，我们使用了键`'toppings'`，这样 Python 将从字典中提取配料列表。

下面的输出概述了要制作的比萨：

```
You ordered a thick-crust pizza with the following toppings:
    mushrooms
    extra cheese
```

每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。在本章前面有关喜欢的编程语言的示例中，如果将每个人的回答都存储在一个列表中，被调查者就可选择多种喜欢的语言。在这种情况下，当我们遍历字典时，与每个被调查者相关联的都是一个语言列表，而不是一种语言；因此，在遍历该字典的`for`循环中，我们需要再使用一个`for`循环来遍历与被调查者相关联的语言列表：

**favorite_languages.py**

```
❶ favorite_languages = {
      'jen': ['python', 'ruby'],
      'sarah': ['c'],
      'edward': ['ruby', 'go'],
      'phil': ['python', 'haskell'],
      }

❷ for name, languages in favorite_languages.items():
      print("\n" + name.title() + "'s favorite languages are:")
❸     for language in languages:
          print("\t" + language.title())
```

正如你看到的，现在与每个名字相关联的值都是一个列表（见❶）。请注意，有些人喜欢的语言只有一种，而有些人有多种。遍历字典时（见❷），我们使用了变量`languages`来依次存储字典中的每个值，因为我们知道这些值都是列表。在遍历字典的主循环中，我们又使用了一个`for`循环来遍历每个人喜欢的语言列表（见❸）。现在，每个人想列出多少种喜欢的语言都可以：

```
Jen's favorite languages are:
    Python
    Ruby

Sarah's favorite languages are:
    C

Phil's favorite languages are:
    Python
    Haskell

Edward's favorite languages are:
    Ruby
    Go
```

为进一步改进这个程序，可在遍历字典的`for`循环开头添加一条`if`语句，通过查看`len(languages)`的值来确定当前的被调查者喜欢的语言是否有多种。如果他喜欢的语言有多种，就像以前一样显示输出；如果只有一种，就相应修改输出的措辞，如显示`Sarah's favorite language is C`。

> **注意**　
>
> 列表和字典的嵌套层级不应太多。如果嵌套层级比前面的示例多得多，很可能有更简单的解决问题的方案。

#### **6.4.3　在字典中存储字典**

可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。例如，如果有多个网站用户，每个都有独特的用户名，可在字典中将用户名作为键，然后将每位用户的信息存储在一个字典中，并将该字典作为与用户名相关联的值。在下面的程序中，对于每位用户，我们都存储了其三项信息：名、姓和居住地；为访问这些信息，我们遍历所有的用户名，并访问与每个用户名相关联的信息字典：

**many_users.py**

```
  users = {
      'aeinstein': {
          'first': 'albert',
          'last': 'einstein',
          'location': 'princeton',
          },

      'mcurie': {
          'first': 'marie',
          'last': 'curie',
          'location': 'paris',
          },

      }

❶ for username, user_info in users.items():
❷     print("\nUsername: " + username)
❸     full_name = user_info['first'] + " " + user_info['last']
      location = user_info['location']

❹     print("\tFull name: " + full_name.title())
      print("\tLocation: " + location.title())
```

我们首先定义了一个名为`users`的字典，其中包含两个键：用户名`'aeinstein'`和`'mcurie'`；与每个键相关联的值都是一个字典，其中包含用户的名、姓和居住地。在❶处，我们遍历字典`users`，让 Python 依次将每个键存储在变量`username`中，并依次将与当前键相关联的字典存储在变量`user_info`中。在主循环内部的❷处，我们将用户名打印出来。

在❸处，我们开始访问内部的字典。变量`user_info`包含用户信息字典，而该字典包含三个键：`'first'`、`'last'`和`'location'`；对于每位用户，我们都使用这些键来生成整洁的姓名和居住地，然后打印有关用户的简要信息（见❹）：

```
Username: aeinstein
    Full name: Albert Einstein
    Location: Princeton

Username: mcurie
    Full name: Marie Curie
    Location: Paris
```

请注意，表示每位用户的字典的结构都相同，虽然 Python 并没有这样的要求，但这使得嵌套的字典处理起来更容易。倘若表示每位用户的字典都包含不同的键，`for`循环内部的代码将更复杂。

> **动手试一试**
>
> **6-7 人**：在为完成练习6-1而编写的程序中，再创建两个表示人的字典，然后将这三个字典都存储在一个名为`people`的列表中。遍历这个列表，将其中每个人的所有信息都打印出来。
>
> **6-8 宠物**：创建多个字典，对于每个字典，都使用一个宠物的名称来给它命名；在每个字典中，包含宠物的类型及其主人的名字。将这些字典存储在一个名为`pets`的列表中，再遍历该列表，并将宠物的所有信息都打印出来。
>
> **6-9 喜欢的地方**：创建一个名为`favorite_places`的字典。在这个字典中，将三个人的名字用作键；对于其中的每个人，都存储他喜欢的1~3个地方。为让这个练习更有趣些，可让一些朋友指出他们喜欢的几个地方。遍历这个字典，并将其中每个人的名字及其喜欢的地方打印出来。
>
> **6-10 喜欢的数字**：修改为完成练习6-2而编写的程序，让每个人都可以有多个喜欢的数字，然后将每个人的名字及其喜欢的数字打印出来。
>
> **6-11 城市**：创建一个名为`cities`的字典，其中将三个城市名用作键；对于每座城市，都创建一个字典，并在其中包含该城市所属的国家、人口约数以及一个有关该城市的事实。在表示每座城市的字典中，应包含`country`、`population`和`fact`等键。将每座城市的名字以及有关它们的信息都打印出来。
>
> **6-12 扩展**：本章的示例足够复杂，可以以很多方式进行扩展了。请对本章的一个示例进行扩展：添加键和值、调整程序要解决的问题或改进输出的格式。

### **6.5　小结**

在本章中，你学习了：如何定义字典，以及如何使用存储在字典中的信息；如何访问和修改字典中的元素，以及如何遍历字典中的所有信息；如何遍历字典中所有的键-值对、所有的键和所有的值；如何在列表中嵌套字典、在字典中嵌套列表以及在字典中嵌套字典。

在下一章中，你将学习`while`循环以及如何从用户那里获取输入。这是激动人心的一章，让你知道如何将程序变成交互性的——能够对用户输入作出响应。

------



## 第7章　用户输入和 while 循环

### **老齐导读**

input 是用于接收键盘输入的函数，为了更深刻理解书中的操作，建议使用 help（input）查看官方文档，并且与操作对照，理解其使用技巧。

while 循环是 Python 中的另外一种循环语句（前面学过 for 循环）。除了要掌握 while 循环的基本结构之外，建议参考书中代码，自己写一个 while 循环的示例。

认真实践书中的案例，并且修改相关代码，实现自己的想法，这是提升自己编程能力的有效途径。

![enter image description here](https://images.gitbook.cn/937f0030-8817-11e9-b1c9-d994bc31f268)

> 大多数程序都旨在解决最终用户的问题，为此通常需要从用户那里获取一些信息。例如，假设有人要判断自己是否到了投票的年龄，要编写回答这个问题的程序，就需要知道用户的年龄，这样才能给出答案。因此，这种程序需要让用户**输入**其年龄，再将其与投票年龄进行比较，以判断用户是否到了投票的年龄，再给出结果。
>
> 在本章中，你将学习如何接受用户输入，让程序能够对其进行处理。在程序需要一个名字时，你需要提示用户输入该名字；程序需要一个名单时，你需要提示用户输入一系列名字。为此，你需要使用函数`input()`。
>
> 你还将学习如何让程序不断地运行，让用户能够根据需要输入信息，并在程序中使用这些信息。为此，你需要使用`while`循环让程序不断地运行，直到指定的条件不满足为止。
>
> 通过获取用户输入并学会控制程序的运行时间，可编写出交互式程序。

### **7.1　函数 input() 的工作原理**

函数`input()`让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python 将其存储在一个变量中，以方便你使用。

例如，下面的程序让用户输入一些文本，再将这些文本呈现给用户：

**parrot.py**

```
message = input("Tell me something, and I will repeat it back to you: ")
print(message)
```

函数`input()`接受一个参数：即要向用户显示的**提示**或说明，让用户知道该如何做。在这个示例中，Python 运行第1行代码时，用户将看到提示`Tell me something, and I will repeat it back to you:`。程序等待用户输入，并在用户按回车键后继续运行。输入存储在变量`message`中，接下来的`print(message)`将输入呈现给用户：

```
Tell me something, and I will repeat it back to you: Hello everyone!
Hello everyone!
```

> **注意**　
>
> Sublime Text 不能运行提示用户输入的程序。你可以使用 Sublime Text 来编写提示用户输入的程序，但必须从终端运行它们。详情请参阅1.4节。

#### **7.1.1　编写清晰的程序**

每当你使用函数`input()`时，都应指定清晰而易于明白的提示，准确地指出你希望用户提供什么样的信息——指出用户该输入任何信息的提示都行，如下所示：

**greeter.py**

```
name = input("Please enter your name: ")
print("Hello, " + name + "!")
```

通过在提示末尾（这里是冒号后面）包含一个空格，可将提示与用户输入分开，让用户清楚地知道其输入始于何处，如下所示：

```
Please enter your name: Eric
Hello, Eric!
```

有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示存储在一个变量中，再将该变量传递给函数`input()`。这样，即便提示超过一行，`input()`语句也非常清晰。

**greeter.py**

```
prompt = "If you tell us who you are, we can personalize the messages you see."
prompt += "\nWhat is your first name? "

name = input(prompt)
print("\nHello, " + name + "!")
```

这个示例演示了一种创建多行字符串的方式。第1行将消息的前半部分存储在变量`prompt`中；在第2行中，运算符`+=`在存储在`prompt`中的字符串末尾附加一个字符串。

最终的提示横跨两行，并在问号后面包含一个空格，这也是出于清晰考虑：

```
If you tell us who you are, we can personalize the messages you see.
What is your first name? Eric

Hello, Eric!
```

#### **7.1.2　使用 int() 来获取数值输入**

使用函数`input()`时，Python 将用户输入解读为字符串。请看下面让用户输入其年龄的解释器会话：

```
>>> age = input("How old are you? ")
How old are you? 21
>>> age
'21'
```

用户输入的是数字21，但我们请求 Python 提供变量`age`的值时，它返回的是`'21'`——用户输入的数值的字符串表示。我们怎么知道 Python 将输入解读成了字符串呢？因为这个数字用引号括起了。如果我们只想打印输入，这一点问题都没有；但如果你试图将输入作为数字使用，就会引发错误：

```
  >>> age = input("How old are you? ")
  How old are you? 21
❶ >>> age >= 18
  Traceback (most recent call last):
    File "", line 1, in 
❷ TypeError: unorderable types: str() >= int()
```

你试图将输入用于数值比较时（见❶），Python 会引发错误，因为它无法将字符串和整数进行比较：不能将存储在`age`中的字符串`'21'`与数值`18`进行比较（见❷）。

为解决这个问题，可使用函数`int()`，它让 Python 将输入视为数值。函数`int()`将数字的字符串表示转换为数值表示，如下所示：

```
  >>> age = input("How old are you? ")
  How old are you? 21
❶ >>> age = int(age)
  >>> age >= 18
  True
```

在这个示例中，我们在提示时输入`21`后，Python 将这个数字解读为字符串，但随后`int()`将这个字符串转换成了数值表示（见❶）。这样 Python 就能运行条件测试了：将变量`age`（它现在包含数值21）同`18`进行比较，看它是否大于或等于18。测试结果为`True`。

如何在实际程序中使用函数`int()`呢？请看下面的程序，它判断一个人是否满足坐过山车的身高要求：

**rollercoaster.py**

```
height = input("How tall are you, in inches? ")
height = int(height)

if height >= 36:
    print("\nYou're tall enough to ride!")
else:
    print("\nYou'll be able to ride when you're a little older.")
```

在这个程序中，为何可以将`height`同`36`进行比较呢？因为在比较前，`height=int(height)`将输入转换成了数值表示。如果输入的数字大于或等于36，我们就告诉用户他满足身高条件：

```
How tall are you, in inches? 71

You're tall enough to ride!
```

将数值输入用于计算和比较前，务必将其转换为数值表示。

#### **7.1.3　求模运算符**

处理数值信息时，**求模运算符**（%）是一个很有用的工具，它将两个数相除并返回余数：

```
>>> 4 % 3
1
>>> 5 % 3
2
>>> 6 % 3
0
>>> 7 % 3
1
```

求模运算符不会指出一个数是另一个数的多少倍，而只指出余数是多少。

如果一个数可被另一个数整除，余数就为0，因此求模运算符将返回0。你可利用这一点来判断一个数是奇数还是偶数：

**evenorodd.py**

```
number = input("Enter a number, and I'll tell you if it's even or odd: ")
number = int(number)

if number % 2 == 0:
    print("\nThe number " + str(number) + " is even.")
else:
    print("\nThe number " + str(number) + " is odd.")
```

偶数都能被2整除，因此对一个数（`number`）和2执行求模运算的结果为零，即`number%2==0`，那么这个数就是偶数；否则就是奇数。

```
Enter a number, and I'll tell you if it's even or odd: 42

The number 42 is even.
```

#### **7.1.4　在 Python 2.7 中获取输入**

如果你使用的是 Python 2.7，应使用函数`raw_input()`来提示用户输入。这个函数与 Python 3 中的`input()`一样，也将输入解读为字符串。

Python 2.7 也包含函数`input()`，但它将用户输入解读为 Python 代码，并尝试运行它们。因此，最好的结果是出现错误，指出 Python 不明白输入的代码；而最糟的结果是，将运行你原本无意运行的代码。如果你使用的是 Python 2.7，请使用`raw_input()`而不是`input()`来获取输入。

> **动手试一试**
>
> **7-1 汽车租赁**：编写一个程序，询问用户要租赁什么样的汽车，并打印一条消息，如“Let me see if I can find you a Subaru”。
>
> **7-2 餐馆订位**：编写一个程序，询问用户有多少人用餐。如果超过8人，就打印一条消息，指出没有空桌；否则指出有空桌。
>
> **7-3 10的整数倍**：让用户输入一个数字，并指出这个数字是否是10的整数倍。

### **7.2　while 循环简介**

`for`循环用于针对集合中的每个元素的一个代码块，而`while`循环不断地运行，直到指定的条件不满足为止。

#### **7.2.1　使用 while 循环**

你可以使用`while`循环来数数，例如，下面的`while`循环从1数到5：

**counting.py**

```
current_number = 1
while current_number <= 5:
    print(current_number)
    current_number += 1
```

在第1行，我们将`current_number`设置为1，从而指定从1开始数。接下来的`while`循环被设置成这样：只要`current_number`小于或等于5，就接着运行这个循环。循环中的代码打印`current_number`的值，再使用代码`current_number+=1`（代码`current_number=current_number+1`的简写）将其值加1。

只要满足条件`current_number<=5`，Python 就接着运行这个循环。由于1小于5，因此 Python 打印`1`，并将`current_number`加1，使其为`2`；由于2小于5，因此 Python 打印`2`，并将`current_number`加`1`，使其为`3`，以此类推。一旦`current_number`大于5，循环将停止，整个程序也将到此结束：

```
1
2
3
4
5
```

你每天使用的程序很可能就包含`while`循环。例如，游戏使用`while`循环，确保在玩家想玩时不断运行，并在玩家想退出时停止运行。如果程序在用户没有让它停止时停止运行，或者在用户要退出时还继续运行，那就太没有意思了；有鉴于此，`while`循环很有用。

#### **7.2.2　让用户选择何时退出**

可使用`while`循环让程序在用户愿意时不断地运行，如下面的程序 parrot.py 所示。我们在其中定义了一个退出值，只要用户输入的不是这个值，程序就接着运行：

**parrot.py**

```
❶ prompt = "\nTell me something, and I will repeat it back to you:"
  prompt += "\nEnter 'quit' to end the program. "
❷ message = ""
❸ while message != 'quit':
      message = input(prompt)
      print(message)
```

在❶处，我们定义了一条提示消息，告诉用户他有两个选择：要么输入一条消息，要么输入退出值（这里为`'quit'`）。接下来，我们创建了一个变量——`message`（见❷），用于存储用户输入的值。我们将变量`message`的初始值设置为空字符串`""`，让 Python 首次执行`while`代码行时有可供检查的东西。Python 首次执行`while`语句时，需要将`message`的值与`'quit'`进行比较，但此时用户还没有输入。如果没有可供比较的东西，Python 将无法继续运行程序。为解决这个问题，我们必须给变量`message`指定一个初始值。虽然这个初始值只是一个空字符串，但符合要求，让 Python 能够执行`while`循环所需的比较。只要`message`的值不是`'quit'`，这个循环（见❸）就会不断运行。

首次遇到这个循环时，`message`是一个空字符串，因此 Python 进入这个循环。执行到代码行`message=input(prompt)`时，Python 显示提示消息，并等待用户输入。不管用户输入是什么，都将存储到变量`message`中并打印出来；接下来，Python 重新检查`while`语句中的条件。只要用户输入的不是单词`'quit'`，Python 就会再次显示提示消息并等待用户输入。等到用户终于输入`'quit'`后，Python 停止执行`while`循环，而整个程序也到此结束：

```
Tell me something, and I will repeat it back to you:
Enter 'quit' to end the program. Hello everyone!
Hello everyone!

Tell me something, and I will repeat it back to you:
Enter 'quit' to end the program. Hello again.
Hello again.

Tell me something, and I will repeat it back to you:
Enter 'quit' to end the program. quit
quit
```

这个程序很好，唯一美中不足的是，它将单词`'quit'`也作为一条消息打印了出来。为修复这种问题，只需使用一个简单的`if`测试：

```
prompt = "\nTell me something, and I will repeat it back to you:"
prompt += "\nEnter 'quit' to end the program. "

message = ""
while message != 'quit':
    message = input(prompt)

    if message != 'quit':
        print(message)
```

现在，程序在显示消息前将做简单的检查，仅在消息不是退出值时才打印它：

```
Tell me something, and I will repeat it back to you:
Enter 'quit' to end the program. Hello everyone!
Hello everyone!

Tell me something, and I will repeat it back to you:
Enter 'quit' to end the program. Hello again.
Hello again.

Tell me something, and I will repeat it back to you:
Enter 'quit' to end the program. quit
```

#### **7.2.3　使用标志**

在前一个示例中，我们让程序在满足指定条件时就执行特定的任务。但在更复杂的程序中，很多不同的事件都会导致程序停止运行；在这种情况下，该怎么办呢？

例如，在游戏中，多种事件都可能导致游戏结束，如玩家一艘飞船都没有了或要保护的城市都被摧毁了。导致程序结束的事件有很多时，如果在一条`while`语句中检查所有这些条件，将既复杂又困难。

在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为**标志**，充当了程序的交通信号灯。你可让程序在标志为`True`时继续运行，并在任何事件导致标志的值为`False`时让程序停止运行。这样，在`while`语句中就只需检查一个条件——标志的当前值是否为`True`，并将所有测试（是否发生了应将标志设置为`False`的事件）都放在其他地方，从而让程序变得更为整洁。

下面来在前一节的程序 parrot.py 中添加一个标志。我们把这个标志命名为`active`（可给它指定任何名称），它将用于判断程序是否应继续运行：

```
  prompt = "\nTell me something, and I will repeat it back to you:"
  prompt += "\nEnter 'quit' to end the program. "

❶ active = True
❷ while active:
      message = input(prompt)

❸     if message == 'quit':
          active = False
❹     else:
          print(message)
```

我们将变量`active`设置成了`True`（见❶），让程序最初处于活动状态。这样做简化了`while`语句，因为不需要在其中做任何比较——相关的逻辑由程序的其他部分处理。只要变量`active`为`True`，循环就将继续运行（见❷）。

在`while`循环中，我们在用户输入后使用一条`if`语句来检查变量`message`的值。如果用户输入的是`'quit'`（见❸），我们就将变量`active`设置为`False`，这将导致`while`循环不再继续执行。如果用户输入的不是`'quit'`（见❹），我们就将输入作为一条消息打印出来。

这个程序的输出与前一个示例相同。在前一个示例中，我们将条件测试直接放在了`while`语句中，而在这个程序中，我们使用了一个标志来指出程序是否处于活动状态，这样如果要添加测试（如`elif`语句）以检查是否发生了其他导致`active`变为`False`的事件，将很容易。在复杂的程序中，如很多事件都会导致程序停止运行的游戏中，标志很有用：在其中的任何一个事件导致活动标志变成`False`时，主游戏循环将退出，此时可显示一条游戏结束消息，并让用户选择是否要重新玩。

#### **7.2.4　使用 break 退出循环**

要立即退出`while`循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用`break`语句。`break`语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。

例如，来看一个让用户指出他到过哪些地方的程序。在这个程序中，我们可以在用户输入`'quit'`后使用`break`语句立即退出`while`循环：

**cities.py**

```
  prompt = "\nPlease enter the name of a city you have visited:"
  prompt += "\n(Enter 'quit' when you are finished.) "

❶ while True:
      city = input(prompt)

      if city == 'quit':
          break
      else:
          print("I'd love to go to " + city.title() + "!")
```

以`while True`打头的循环（见❶）将不断运行，直到遇到`break`语句。这个程序中的循环不断输入用户到过的城市的名字，直到他输入`'quit'`为止。用户输入`'quit'`后，将执行`break`语句，导致 Python 退出循环：

```
Please enter the name of a city you have visited:
(Enter 'quit' when you are finished.) New York
I'd love to go to New York!

Please enter the name of a city you have visited:
(Enter 'quit' when you are finished.) San Francisco
I'd love to go to San Francisco!

Please enter the name of a city you have visited:
(Enter 'quit' when you are finished.) quit
```

> **注意**　
>
> 在任何 Python 循环中都可使用`break`语句。例如，可使用`break`语句来退出遍历列表或字典的`for`循环。

#### **7.2.5　在循环中使用 continue**

要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用`continue`语句，它不像`break`语句那样不再执行余下的代码并退出整个循环。例如，来看一个从1数到10，但只打印其中奇数的循环：

**counting.py**

```
  current_number = 0
  while current_number < 10:
❶     current_number += 1
      if current_number % 2 == 0:
          continue

      print(current_number)
```

我们首先将`current_number`设置成了0，由于它小于10，Python 进入`while`循环。进入循环后，我们以步长1的方式往上数（见❶），因此`current_number`为1。接下来，`if`语句检查`current_number`与2的求模运算结果。如果结果为0（意味着`current_number`可被2整除），就执行`continue`语句，让 Python 忽略余下的代码，并返回到循环的开头。如果当前的数字不能被2整除，就执行循环中余下的代码，Python 将这个数字打印出来：

```
1
3
5
7
9
```

#### **7.2.6　避免无限循环**

每个`while`循环都必须有停止运行的途径，这样才不会没完没了地执行下去。例如，下面的循环从1数到5：

**counting.py**

```
x = 1
while x <= 5:
    print(x)
    x += 1
```

但如果你像下面这样不小心遗漏了代码行`x+=1`，这个循环将没完没了地运行：

```
# 这个循环将没完没了地运行！
x = 1
while x <= 5:
    print(x)
```

在这里，`x`的初始值为`1`，但根本不会变，因此条件测试`x<=5`始终为`True`，导致`while`循环没完没了地打印`1`，如下所示：

```
1
1
1
1
--snip--
```

每个程序员都会偶尔因不小心而编写出无限循环，在循环的退出条件比较微妙时尤其如此。如果程序陷入无限循环，可按 Ctrl+C，也可关闭显示程序输出的终端窗口。

要避免编写无限循环，务必对每个`while`循环进行测试，确保它按预期那样结束。如果你希望程序在用户输入特定值时结束，可运行程序并输入这样的值；如果在这种情况下程序没有结束，请检查程序处理这个值的方式，确认程序至少有一个这样的地方能让循环条件为`False`或让`break`语句得以执行。

> **注意**　
>
> 有些编辑器（如 Sublime Text）内嵌了输出窗口，这可能导致难以结束无限循环，因此不得不关闭编辑器来结束无限循环。

> **动手试一试**
>
> **7-4 比萨配料**：编写一个循环，提示用户输入一系列的比萨配料，并在用户输入`'quit'`时结束循环。每当用户输入一种配料后，都打印一条消息，说我们会在比萨中添加这种配料。
>
> **7-5 电影票**：有家电影院根据观众的年龄收取不同的票价：不到3岁的观众免费；3~12岁的观众为10美元；超过12岁的观众为15美元。请编写一个循环，在其中询问用户的年龄，并指出其票价。
>
> **7-6 三个出口**：以另一种方式完成练习7-4或练习7-5，在程序中采取如下所有做法。
>
> - 在`while`循环中使用条件测试来结束循环。
> - 使用变量`active`来控制循环结束的时机。
> - 使用`break`语句在用户输入`'quit'`时退出循环。
>
> **7-7 无限循环**：编写一个没完没了的循环，并运行它（要结束该循环，可按 Ctrl+C，也可关闭显示输出的窗口）。

### **7.3　使用 while 循环来处理列表和字典**

到目前为止，我们每次都只处理了一项用户信息：获取用户的输入，再将输入打印出来或作出应答；循环再次运行时，我们获悉另一个输入值并作出响应。然而，要记录大量的用户和信息，需要在`while`循环中使用列表和字典。

`for`循环是一种遍历列表的有效方式，但在`for`循环中不应修改列表，否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用`while`循环。通过将`while`循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。

#### **7.3.1　在列表之间移动元素**

假设有一个列表，其中包含新注册但还未验证的网站用户；验证这些用户后，如何将他们移到另一个已验证用户列表中呢？一种办法是使用一个`while`循环，在验证用户的同时将其从未验证用户列表中提取出来，再将其加入到另一个已验证用户列表中。代码可能类似于下面这样：

**confirmed_users.py**

```
  # 首先，创建一个待验证用户列表
  #  和一个用于存储已验证用户的空列表
❶ unconfirmed_users = ['alice', 'brian', 'candace']
  confirmed_users = []

  # 验证每个用户，直到没有未验证用户为止
  #  将每个经过验证的列表都移到已验证用户列表中
❷ while unconfirmed_users:
❸     current_user = unconfirmed_users.pop()

      print("Verifying user: " + current_user.title())
❹     confirmed_users.append(current_user)

  # 显示所有已验证的用户
  print("\nThe following users have been confirmed:")
  for confirmed_user in confirmed_users:
      print(confirmed_user.title())
```

我们首先创建了一个未验证用户列表（见❶），其中包含用户 Alice、Brian 和 Candace，还创建了一个空列表，用于存储已验证的用户。❷处的`while`循环将不断地运行，直到列表`unconfirmed_users`变成空的。在这个循环中，❸处的函数`pop()`以每次一个的方式从列表`unconfirmed_users`末尾删除未验证的用户。由于 Candace 位于列表`unconfirmed_users`末尾，因此其名字将首先被删除、存储到变量`current_user`中并加入到列表`confirmed_users`中（见❹）。接下来是 Brian，然后是 Alice。

为模拟用户验证过程，我们打印一条验证消息并将用户加入到已验证用户列表中。未验证用户列表越来越短，而已验证用户列表越来越长。未验证用户列表为空后结束循环，再打印已验证用户列表：

```
Verifying user: Candace
Verifying user: Brian
Verifying user: Alice

The following users have been confirmed:
Candace
Brian
Alice
```

#### **7.3.2　删除包含特定值的所有列表元素**

在第3章中，我们使用函数`remove()`来删除列表中的特定值，这之所以可行，是因为要删除的值在列表中只出现了一次。如果要删除列表中所有包含特定值的元素，该怎么办呢？

假设你有一个宠物列表，其中包含多个值为`'cat'`的元素。要删除所有这些元素，可不断运行一个`while`循环，直到列表中不再包含值`'cat'`，如下所示：

**pets.py**

```
pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
print(pets)

while 'cat' in pets:
    pets.remove('cat')

print(pets)
```

我们首先创建了一个列表，其中包含多个值为`'cat'`的元素。打印这个列表后，Python 进入`while`循环，因为它发现`'cat'`在列表中至少出现了一次。进入这个循环后，Python 删除第一个`'cat'`并返回到`while`代码行，然后发现`'cat'`还包含在列表中，因此再次进入循环。它不断删除`'cat'`，直到这个值不再包含在列表中，然后退出循环并再次打印列表：

```
['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
['dog', 'dog', 'goldfish', 'rabbit']
```

#### **7.3.3　使用用户输入来填充字典**

可使用 while 循环提示用户输入任意数量的信息。下面来创建一个调查程序，其中的循环每次执行时都提示输入被调查者的名字和回答。我们将收集的数据存储在一个字典中，以便将回答同被调查者关联起来：

**mountain_poll.py**

```
  responses = {}

  # 设置一个标志，指出调查是否继续
  polling_active = True

  while polling_active:
      # 提示输入被调查者的名字和回答
❶     name = input("\nWhat is your name? ")
      response = input("Which mountain would you like to climb someday? ")

      # 将答卷存储在字典中
❷     responses[name] = response

      # 看看是否还有人要参与调查
❸     repeat = input("Would you like to let another person respond? (yes/ no) ")
      if repeat == 'no':
          polling_active = False

  # 调查结束，显示结果
  print("\n--- Poll Results ---")
❹ for name, response in responses.items():
      print(name + " would like to climb " + response + ".")
```

这个程序首先定义了一个空字典（`responses`），并设置了一个标志（`polling_active`），用于指出调查是否继续。只要`polling_active`为`True`，Python 就运行`while`循环中的代码。

在这个循环中，提示用户输入其用户名及其喜欢爬哪座山（见❶）。将这些信息存储在字典`responses`中（见❷），然后询问用户调查是否继续（见❸）。如果用户输入`yes`，程序将再次进入`while`循环；如果用户输入`no`，标志`polling_active`将被设置为`False`，而`while`循环将就此结束。最后一个代码块（见❹）显示调查结果。

如果你运行这个程序，并输入一些名字和回答，输出将类似于下面这样：

```
What is your name? Eric
Which mountain would you like to climb someday? Denali
Would you like to let another person respond? (yes/ no) yes

What is your name? Lynn
Which mountain would you like to climb someday? Devil's Thumb
Would you like to let another person respond? (yes/ no) no

--- Poll Results ---
Lynn would like to climb Devil's Thumb.
Eric would like to climb Denali.
```

> **动手试一试**
>
> **7-8 熟食店**：创建一个名为`sandwich_orders`的列表，在其中包含各种三明治的名字；再创建一个名为`finished_sandwiches`的空列表。遍历列表`sandwich_orders`，对于其中的每种三明治，都打印一条消息，如`I made your tuna sandwich`，并将其移到列表`finished_sandwiches`。所有三明治都制作好后，打印一条消息，将这些三明治列出来。
>
> **7-9 五香烟熏牛肉（pastrami）卖完了**：使用为完成练习7-8而创建的列表`sandwich_orders`，并确保`'pastrami'`在其中至少出现了三次。在程序开头附近添加这样的代码：打印一条消息，指出熟食店的五香烟熏牛肉卖完了；再使用一个`while`循环将列表`sandwich_orders`中的`'pastrami'`都删除。确认最终的列表`finished_sandwiches`中不包含`'pastrami'`。
>
> **7-10 梦想的度假胜地**：编写一个程序，调查用户梦想的度假胜地。使用类似于“If you could visit one place in the world, where would you go?”的提示，并编写一个打印调查结果的代码块。

### **7.4　小结**

在本章中，你学习了：如何在程序中使用`input()`来让用户提供信息；如何处理文本和数字输入，以及如何使用`while`循环让程序按用户的要求不断地运行；多种控制`while`循环流程的方式：设置活动标志、使用`break`语句以及使用`continue`语句；如何使用`while`循环在列表之间移动元素，以及如何从列表中删除所有包含特定值的元素；如何结合使用`while`循环和字典。

在第8章中，你将学习函数。函数让你能够将程序分成多个很小的部分，其中每部分都负责完成一项具体任务。你可以根据需要调用同一个函数任意次，还可将函数存储在独立的文件中。使用函数可让你编写的代码效率更高，更容易维护和排除故障，还可在众多不同的程序中重用。

------



## 第8章　函数

### **老齐导读**

在学习本章的时候，请特别认同如下观点：

- 函数是 Python 中的重点技能
- Python 中的函数是对象

然后，把本章所有代码敲一遍，并对照图中总结的知识体系，自己体会每一部分的知识，特别是下图中橙色拓展的部分，建议读者通过“前言”中推荐的资料补充上，这部分是重点。

![enter image description here](https://images.gitbook.cn/d5730b70-8818-11e9-b6f4-77ea8c81f44e)

> 在本章中，你将学习编写**函数**。函数是带名字的代码块，用于完成具体的工作。
>
> 要执行函数定义的特定任务，可调用该函数。需要在程序中多次执行同一项任务时，你无需反复编写完成该任务的代码，而只需调用执行该任务的函数，让 Python 运行其中的代码。你将发现，通过使用函数，程序的编写、阅读、测试和修复都将更容易。
>
> 在本章中，你还会学习向函数传递信息的方式。你将学习如何编写主要任务是显示信息的函数，还有用于处理数据并返回一个或一组值的函数。最后，你将学习如何将函数存储在被称为**模块**的独立文件中，让主程序文件的组织更为有序。

### **8.1　定义函数**

下面是一个打印问候语的简单函数，名为`greet_user()`：

**greeter.py**

```
❶ def greet_user():
❷     """显示简单的问候语"""
❸     print("Hello!")

❹ greet_user()
```

这个示例演示了最简单的函数结构。❶处的代码行使用关键字`def`来告诉 Python 你要定义一个函数。这是**函数定义**，向 Python 指出了函数名，还可能在括号内指出函数为完成其任务需要什么样的信息。在这里，函数名为`greet_user()`，它不需要任何信息就能完成其工作，因此括号是空的（即便如此，括号也必不可少）。最后，定义以冒号结尾。

紧跟在`def greet_user():`后面的所有缩进行构成了函数体。❷处的文本是被称为**文档字符串**（docstring）的注释，描述了函数是做什么的。文档字符串用三引号括起，Python 使用它们来生成有关程序中函数的文档。

代码行`print("Hello!")`（见❸）是函数体内的唯一一行代码，`greet_user()`只做一项工作：打印`Hello!`。

要使用这个函数，可调用它。**函数调用**让 Python 执行函数的代码。要**调用**函数，可依次指定函数名以及用括号括起的必要信息，如❹处所示。由于这个函数不需要任何信息，因此调用它时只需输入`greet_user()`即可。和预期的一样，它打印`Hello!`：

```
Hello!
```

#### **8.1.1　向函数传递信息**

只需稍作修改，就可以让函数`greet_user()`不仅向用户显示`Hello!`，还将用户的名字用作抬头。为此，可在函数定义`def greet_user()`的括号内添加`username`。通过在这里添加`username`，就可让函数接受你给`username`指定的任何值。现在，这个函数要求你调用它时给`username`指定一个值。调用`greet_user()`时，可将一个名字传递给它，如下所示：

```
def greet_user(username):
    """显示简单的问候语"""
    print("Hello, " + username.title() + "!")

greet_user('jesse')
```

代码`greet_user('jesse')`调用函数`greet_user()`，并向它提供执行`print`语句所需的信息。这个函数接受你传递给它的名字，并向这个人发出问候：

```
Hello, Jesse!
```

同样，`greet_user('sarah')`调用函数`greet_user()`并向它传递`'sarah'`，打印`Hello, Sarah!`。你可以根据需要调用函数`greet_user()`任意次，调用时无论传入什么样的名字，都会生成相应的输出。

#### **8.1.2　实参和形参**

前面定义函数`greet_user()`时，要求给变量`username`指定一个值。调用这个函数并提供这种信息（人名）时，它将打印相应的问候语。

在函数`greet_user()`的定义中，变量`username`是一个**形参**——函数完成其工作所需的一项信息。在代码`greet_user('jesse')`中，值`'jesse'`是一个**实参**。实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在`greet_user('jesse')`中，将实参`'jesse'`传递给了函数`greet_user()`，这个值被存储在形参`username`中。

> **注意**　
>
> 大家有时候会形参、实参不分，因此如果你看到有人将函数定义中的变量称为实参或将函数调用中的变量称为形参，不要大惊小怪。

> **动手试一试**
>
> **8-1 消息**：编写一个名为`display_message()`的函数，它打印一个句子，指出你在本章学的是什么。调用这个函数，确认显示的消息正确无误。
>
> **8-2 喜欢的图书**：编写一个名为`favorite_book()`的函数，其中包含一个名为`title`的形参。这个函数打印一条消息，如`One of my favorite books is Alice in Wonderland`。调用这个函数，并将一本图书的名称作为实参传递给它。

### **8.2　传递实参**

鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用**位置实参**，这要求实参的顺序与形参的顺序相同；也可使用**关键字实参**，其中每个实参都由变量名和值组成；还可使用列表和字典。下面来依次介绍这些方式。

#### **8.2.1　位置实参**

你调用函数时，Python 必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为**位置实参**。

为明白其中的工作原理，来看一个显示宠物信息的函数。这个函数指出一个宠物属于哪种动物以及它叫什么名字，如下所示：

**pets.py**

```
❶ def describe_pet(animal_type, pet_name):
      """显示宠物的信息"""
      print("\nI have a " + animal_type + ".")
      print("My " + animal_type + "'s name is " + pet_name.title() + ".")

❷ describe_pet('hamster', 'harry')
```

这个函数的定义表明，它需要一种动物类型和一个名字（见❶）。调用`describe_pet()`时，需要按顺序提供一种动物类型和一个名字。例如，在前面的函数调用中，实参`'hamster'`存储在形参`animal_type`中，而实参`'harry'`存储在形参`pet_name`中（见❷）。在函数体内，使用了这两个形参来显示宠物的信息。

输出描述了一只名为 Harry 的仓鼠：

```
I have a hamster.
My hamster's name is Harry.
```

**1. 调用函数多次**

你可以根据需要调用函数任意次。要再描述一个宠物，只需再次调用`describe_pet()`即可：

```
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet('hamster', 'harry')
describe_pet('dog', 'willie')
```

第二次调用`describe_pet()`函数时，我们向它传递了实参`'dog'`和`'willie'`。与第一次调用时一样，Python 将实参`'dog'`关联到形参`animal_type`，并将实参`'willie'`关联到形参`pet_name`。与前面一样，这个函数完成其任务，但打印的是一条名为 Willie 的小狗的信息。至此，我们有一只名为 Harry 的仓鼠，还有一条名为 Willie 的小狗：

```
I have a hamster.
My hamster's name is Harry.

I have a dog.
My dog's name is Willie.
```

调用函数多次是一种效率极高的工作方式。我们只需在函数中编写描述宠物的代码一次，然后每当需要描述新宠物时，都可调用这个函数，并向它提供新宠物的信息。即便描述宠物的代码增加到了10行，你依然只需使用一行调用函数的代码，就可描述一个新宠物。

在函数中，可根据需要使用任意数量的位置实参，Python 将按顺序将函数调用中的实参关联到函数定义中相应的形参。

**2. 位置实参的顺序很重要**

使用位置实参来调用函数时，如果实参的顺序不正确，结果可能出乎意料：

```
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet('harry', 'hamster')
```

在这个函数调用中，我们先指定名字，再指定动物类型。由于实参`'harry'`在前，这个值将存储到形参`animal_type`中；同理，`'hamster'`将存储到形参`pet_name`中。结果是我们得到了一个名为`Hamster`的`harry`：

```
I have a harry.
My harry's name is Hamster.
```

如果结果像上面一样搞笑，请确认函数调用中实参的顺序与函数定义中形参的顺序一致。

#### **8.2.2　关键字实参**

**关键字实参**是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆（不会得到名为 Hamster 的 harry 这样的结果）。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。

下面来重新编写 pets.py，在其中使用关键字实参来调用`describe_pet()`：

```
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet(animal_type='hamster', pet_name='harry')
```

函数`describe_pet()`还是原来那样，但调用这个函数时，我们向 Python 明确地指出了各个实参对应的形参。看到这个函数调用时，Python 知道应该将实参`'hamster'`和`'harry'`分别存储在形参`animal_type`和`pet_name`中。输出正确无误，它指出我们有一只名为 Harry 的仓鼠。

关键字实参的顺序无关紧要，因为 Python 知道各个值该存储到哪个形参中。下面两个函数调用是等效的：

```
describe_pet(animal_type='hamster', pet_name='harry')
describe_pet(pet_name='harry', animal_type='hamster')
```

> **注意**　
>
> 使用关键字实参时，务必准确地指定函数定义中的形参名。

#### **8.2.3　默认值**

编写函数时，可给每个形参指定**默认值**。在调用函数中给形参提供了实参时，Python 将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。

例如，如果你发现调用`describe_pet()`时，描述的大都是小狗，就可将形参`animal_type`的默认值设置为`'dog'`。这样，调用`describe_pet()`来描述小狗时，就可不提供这种信息：

```
def describe_pet(pet_name, animal_type='dog'):
    """显示宠物的信息"""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet(pet_name='willie')
```

这里修改了函数`describe_pet()`的定义，在其中给形参`animal_type`指定了默认值`'dog'`。这样，调用这个函数时，如果没有给`animal_type`指定值，Python 将把这个形参设置为`'dog'`：

```
I have a dog.
My dog's name is Willie.
```

请注意，在这个函数的定义中，修改了形参的排列顺序。由于给`animal_type`指定了默认值，无需通过实参来指定动物类型，因此在函数调用中只包含一个实参——宠物的名字。然而，Python 依然将这个实参视为位置实参，因此如果函数调用中只包含宠物的名字，这个实参将关联到函数定义中的第一个形参。这就是需要将`pet_name`放在形参列表开头的原因所在。

现在，使用这个函数的最简单的方式是，在函数调用中只提供小狗的名字：

```
describe_pet('willie')
```

这个函数调用的输出与前一个示例相同。只提供了一个实参——`'willie'`，这个实参将关联到函数定义中的第一个形参——`pet_name`。由于没有给`animal_type`提供实参，因此 Python 使用其默认值`'dog'`。

如果要描述的动物不是小狗，可使用类似于下面的函数调用：

```
describe_pet(pet_name='harry', animal_type='hamster')
```

由于显式地给`animal_type`提供了实参，因此 Python 将忽略这个形参的默认值。

> **注意**　
>
> 使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的形参。这让 Python 依然能够正确地解读位置实参。

#### **8.2.4　等效的函数调用**

鉴于可混合使用位置实参、关键字实参和默认值，通常有多种等效的函数调用方式。请看下面的函数`describe_pet()`的定义，其中给一个形参提供了默认值：

```
def describe_pet(pet_name, animal_type='dog'):
```

基于这种定义，在任何情况下都必须给`pet_name`提供实参；指定该实参时可以使用位置方式，也可以使用关键字方式。如果要描述的动物不是小狗，还必须在函数调用中给`animal_type`提供实参；同样，指定该实参时可以使用位置方式，也可以使用关键字方式。

下面对这个函数的所有调用都可行：

```
# 一条名为 Willie 的小狗
describe_pet('willie')
describe_pet(pet_name='willie')

# 一只名为 Harry 的仓鼠
describe_pet('harry', 'hamster')
describe_pet(pet_name='harry', animal_type='hamster')
describe_pet(animal_type='hamster', pet_name='harry')
```

这些函数调用的输出与前面的示例相同。

> **注意**　
>
> 使用哪种调用方式无关紧要，只要函数调用能生成你希望的输出就行。使用对你来说最容易理解的调用方式即可。

#### **8.2.5　避免实参错误**

等你开始使用函数后，如果遇到实参不匹配错误，不要大惊小怪。你提供的实参多于或少于函数完成其工作所需的信息时，将出现实参不匹配错误。例如，如果调用函数`describe_pet()`时没有指定任何实参，结果将如何呢？

```
def describe_pet(animal_type, pet_name):
    """显示宠物的信息"""
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

describe_pet()
```

Python 发现该函数调用缺少必要的信息，而 traceback 指出了这一点：

```
  Traceback (most recent call last):
❶   File "pets.py", line 6, in <module>
❷     describe_pet()
❸ TypeError: describe_pet() missing 2 required positional arguments: 'animal_
  type' and 'pet_name'
```

在❶处，traceback 指出了问题出在什么地方，让我们能够回过头去找出函数调用中的错误。在❷处，指出了导致问题的函数调用。在❸处，traceback 指出该函数调用少两个实参，并指出了相应形参的名称。如果这个函数存储在一个独立的文件中，我们也许无需打开这个文件并查看函数的代码，就能重新正确地编写函数调用。

Python 读取函数的代码，并指出我们需要为哪些形参提供实参，这提供了极大的帮助。这也是应该给变量和函数指定描述性名称的另一个原因；如果你这样做了，那么无论对于你，还是可能使用你编写的代码的其他任何人来说，Python 提供的错误消息都将更有帮助。

如果提供的实参太多，将出现类似的 traceback，帮助你确保函数调用和函数定义匹配。

> **动手试一试**
>
> **8-3 T 恤**：编写一个名为`make_shirt()`的函数，它接受一个尺码以及要印到 T 恤上的字样。这个函数应打印一个句子，概要地说明 T 恤的尺码和字样。
>
> 使用位置实参调用这个函数来制作一件 T 恤；再使用关键字实参来调用这个函数。
>
> **8-4 大号 T 恤**：修改函数`make_shirt()`，使其在默认情况下制作一件印有字样“I love Python”的大号 T 恤。调用这个函数来制作如下 T 恤：一件印有默认字样的大号 T 恤、一件印有默认字样的中号 T 恤和一件印有其他字样的 T 恤（尺码无关紧要）。
>
> **8-5 城市**：编写一个名为`describe_city()`的函数，它接受一座城市的名字以及该城市所属的国家。这个函数应打印一个简单的句子，如`Reykjavik is in Iceland`。给用于存储国家的形参指定默认值。为三座不同的城市调用这个函数，且其中至少有一座城市不属于默认国家。

### **8.3　返回值**

函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为**返回值**。在函数中，可使用`return`语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。

#### **8.3.1　返回简单值**

下面来看一个函数，它接受名和姓并返回整洁的姓名：

**formatted_name.py**

```
❶ def get_formatted_name(first_name, last_name):
      """返回整洁的姓名"""
❷     full_name = first_name + ' ' + last_name
❸     return full_name.title()

❹ musician = get_formatted_name('jimi', 'hendrix')
  print(musician)
```

函数`get_formatted_name()`的定义通过形参接受名和姓（见❶）。它将姓和名合而为一，在它们之间加上一个空格，并将结果存储在变量`full_name`中（见❷）。然后，将`full_name`的值转换为首字母大写格式，并将结果返回到函数调用行（见❸）。

调用返回值的函数时，需要提供一个变量，用于存储返回的值。在这里，将返回值存储在了变量`musician`中（见❹）。输出为整洁的姓名：

```
Jimi Hendrix
```

我们原本只需编写下面的代码就可输出整洁的姓名，相比于此，前面做的工作好像太多了：

```
print("Jimi Hendrix")
```

但在需要分别存储大量名和姓的大型程序中，像`get_formatted_name()`这样的函数非常有用。你分别存储名和姓，每当需要显示姓名时都调用这个函数。

#### **8.3.2　让实参变成可选的**

有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。

例如，假设我们要扩展函数`get_formatted_name()`，使其还处理中间名。为此，可将其修改成类似于下面这样：

```
def get_formatted_name(first_name, middle_name, last_name):
    """返回整洁的姓名"""
    full_name = first_name + ' ' + middle_name + ' ' + last_name
    return full_name.title()

musician = get_formatted_name('john', 'lee', 'hooker')
print(musician)
```

只要同时提供名、中间名和姓，这个函数就能正确地运行。它根据这三部分创建一个字符串，在适当的地方加上空格，并将结果转换为首字母大写格式：

```
John Lee Hooker
```

然而，并非所有的人都有中间名，但如果你调用这个函数时只提供了名和姓，它将不能正确地运行。为让中间名变成可选的，可给实参`middle_name`指定一个默认值——空字符串，并在用户没有提供中间名时不使用这个实参。为让`get_formatted_name()`在没有提供中间名时依然可行，可给实参`middle_name`指定一个默认值——空字符串，并将其移到形参列表的末尾：

```
❶ def get_formatted_name(first_name, last_name, middle_name=''):
      """返回整洁的姓名"""
❷     if middle_name:
          full_name = first_name + ' ' + middle_name + ' ' + last_name
❸     else:
          full_name = first_name + ' ' + last_name
      return full_name.title()

  musician = get_formatted_name('jimi', 'hendrix')
  print(musician)

❹ musician = get_formatted_name('john', 'hooker', 'lee')
  print(musician)
```

在这个示例中，姓名是根据三个可能提供的部分创建的。由于人都有名和姓，因此在函数定义中首先列出了这两个形参。中间名是可选的，因此在函数定义中最后列出该形参，并将其默认值设置为空字符串（见❶）。

在函数体中，我们检查是否提供了中间名。Python 将非空字符串解读为`True`，因此如果函数调用中提供了中间名，`if middle_name`将为`True`（见❷）。如果提供了中间名，就将名、中间名和姓合并为姓名，然后将其修改为首字母大写格式，并返回到函数调用行。在函数调用行，将返回的值存储在变量`musician`中；然后将这个变量的值打印出来。如果没有提供中间名，`middle_name`将为空字符串，导致`if`测试未通过，进而执行`else`代码块（见❸）：只使用名和姓来生成姓名，并将设置好格式的姓名返回给函数调用行。在函数调用行，将返回的值存储在变量`musician`中；然后将这个变量的值打印出来。

调用这个函数时，如果只想指定名和姓，调用起来将非常简单。如果还要指定中间名，就必须确保它是最后一个实参，这样 Python 才能正确地将位置实参关联到形参（见❹）。

这个修改后的版本适用于只有名和姓的人，也适用于还有中间名的人：

```
Jimi Hendrix
John Lee Hooker
```

可选值让函数能够处理各种不同情形的同时，确保函数调用尽可能简单。

#### **8.3.3　返回字典**

函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。例如，下面的函数接受姓名的组成部分，并返回一个表示人的字典：

**person.py**

```
  def build_person(first_name, last_name):
      """返回一个字典，其中包含有关一个人的信息"""
❶     person = {'first': first_name, 'last': last_name}
❷     return person

  musician = build_person('jimi', 'hendrix')
❸ print(musician)
```

函数`build_person()`接受名和姓，并将这些值封装到字典中（见❶）。存储`first_name`的值时，使用的键为`'first'`，而存储`last_name`的值时，使用的键为`'last'`。最后，返回表示人的整个字典（见❷）。在❸处，打印这个返回的值，此时原来的两项文本信息存储在一个字典中：

```
{'first': 'jimi', 'last': 'hendrix'}
```

这个函数接受简单的文本信息，将其放在一个更合适的数据结构中，让你不仅能打印这些信息，还能以其他方式处理它们。当前，字符串`'jimi'`和`'hendrix'`被标记为名和姓。你可以轻松地扩展这个函数，使其接受可选值，如中间名、年龄、职业或你要存储的其他任何信息。例如，下面的修改让你还能存储年龄：

```
def build_person(first_name, last_name, age=''):
    """返回一个字典，其中包含有关一个人的信息"""
    person = {'first': first_name, 'last': last_name}
    if age:
        person['age'] = age
    return person

musician = build_person('jimi', 'hendrix', age=27)
print(musician)
```

在函数定义中，我们新增了一个可选形参`age`，并将其默认值设置为空字符串。如果函数调用中包含这个形参的值，这个值将存储到字典中。在任何情况下，这个函数都会存储人的姓名，但可对其进行修改，使其也存储有关人的其他信息。

#### **8.3.4　结合使用函数和 while 循环**

可将函数同本书前面介绍的任何 Python 结构结合起来使用。例如，下面将结合使用函数`get_formatted_name()`和`while`循环，以更正规的方式问候用户。下面尝试使用名和姓跟用户打招呼：

**greeter.py**

```
  def get_formatted_name(first_name, last_name):
      """返回整洁的姓名"""
      full_name = first_name + ' ' + last_name
      return full_name.title()

  # 这是一个无限循环!
  while True:
❶      print("\nPlease tell me your name:")
       f_name = input("First name: ")
       l_name = input("Last name: ")

       formatted_name = get_formatted_name(f_name, l_name)
       print("\nHello, " + formatted_name + "!")
```

在这个示例中，我们使用的是`get_formatted_name()`的简单版本，不涉及中间名。其中的`while`循环让用户输入姓名：依次提示用户输入名和姓（见❶）。

但这个`while`循环存在一个问题：没有定义退出条件。请用户提供一系列输入时，该在什么地方提供退出条件呢？我们要让用户能够尽可能容易地退出，因此每次提示用户输入时，都应提供退出途径。每次提示用户输入时，都使用`break`语句提供了退出循环的简单途径：

```
def get_formatted_name(first_name, last_name):
    """返回整洁的姓名"""
    full_name = first_name + ' ' + last_name
    return full_name.title()

while True:
    print("\nPlease tell me your name:")
    print("(enter 'q' at any time to quit)")

    f_name = input("First name: ")
    if f_name == 'q':
        break

    l_name = input("Last name: ")
    if l_name == 'q':
        break

    formatted_name = get_formatted_name(f_name, l_name)
    print("\nHello, " + formatted_name + "!")
```

我们添加了一条消息来告诉用户如何退出，然后在每次提示用户输入时，都检查他输入的是否是退出值，如果是，就退出循环。现在，这个程序将不断地问候，直到用户输入的姓或名为`'q'`为止：

```
Please tell me your name:
(enter 'q' at any time to quit)
First name: eric
Last name: matthes

Hello, Eric Matthes!

Please tell me your name:
(enter 'q' at any time to quit)
First name: q
```

> **动手试一试**
>
> **8-6 城市名**：编写一个名为`city_country()`的函数，它接受城市的名称及其所属的国家。这个函数应返回一个格式类似于下面这样的字符串：
>
> ```
> "Santiago, Chile"
> ```
>
> 至少使用三个城市-国家对调用这个函数，并打印它返回的值。
>
> **8-7 专辑**：编写一个名为`make_album()`的函数，它创建一个描述音乐专辑的字典。这个函数应接受歌手的名字和专辑名，并返回一个包含这两项信息的字典。使用这个函数创建三个表示不同专辑的字典，并打印每个返回的值，以核实字典正确地存储了专辑的信息。
>
> 给函数`make_album()`添加一个可选形参，以便能够存储专辑包含的歌曲数。如果调用这个函数时指定了歌曲数，就将这个值添加到表示专辑的字典中。调用这个函数，并至少在一次调用中指定专辑包含的歌曲数。
>
> **8-8 用户的专辑**：在为完成练习8-7编写的程序中，编写一个`while`循环，让用户输入一个专辑的歌手和名称。获取这些信息后，使用它们来调用函数`make_album()`，并将创建的字典打印出来。在这个`while`循环中，务必要提供退出途径。

### **8.4　传递列表**

你经常会发现，向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。下面使用函数来提高处理列表的效率。

假设有一个用户列表，我们要问候其中的每位用户。下面的示例将一个名字列表传递给一个名为`greet_users()`的函数，这个函数问候列表中的每个人：

**greet_users.py**

```
  def greet_users(names):
      """向列表中的每位用户都发出简单的问候"""
      for name in names:
          msg = "Hello, " + name.title() + "!"
          print(msg)

❶ usernames = ['hannah', 'ty', 'margot']
  greet_users(usernames)
```

我们将`greet_users()`定义成接受一个名字列表，并将其存储在形参`names`中。这个函数遍历收到的列表，并对其中的每位用户都打印一条问候语。在❶处，我们定义了一个用户列表——`usernames`，然后调用`greet_users()`，并将这个列表传递给它：

```
Hello, Hannah!
Hello, Ty!
Hello, Margot!
```

输出完全符合预期，每位用户都看到了一条个性化的问候语。每当你要问候一组用户时，都可调用这个函数。

#### **8.4.1　在函数中修改列表**

将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。

来看一家为用户提交的设计制作 3D 打印模型的公司。需要打印的设计存储在一个列表中，打印后移到另一个列表中。下面是在不使用函数的情况下模拟这个过程的代码：

**printing_models.py**

```
# 首先创建一个列表，其中包含一些要打印的设计
unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

# 模拟打印每个设计，直到没有未打印的设计为止
#  打印每个设计后，都将其移到列表 completed_models 中
while unprinted_designs:
    current_design = unprinted_designs.pop()

    #模拟根据设计制作 3D 打印模型的过程
    print("Printing model: " + current_design)
    completed_models.append(current_design)

# 显示打印好的所有模型
print("\nThe following models have been printed:")
for completed_model in completed_models:
    print(completed_model)
```

这个程序首先创建一个需要打印的设计列表，还创建一个名为`completed_models`的空列表，每个设计打印都将移到这个列表中。只要列表`unprinted_designs`中还有设计，`while`循环就模拟打印设计的过程：从该列表末尾删除一个设计，将其存储到变量`current_design`中，并显示一条消息，指出正在打印当前的设计，再将该设计加入到列表`completed_models`中。循环结束后，显示已打印的所有设计：

```
Printing model: dodecahedron
Printing model: robot pendant
Printing model: iphone case

The following models have been printed:
dodecahedron
robot pendant
iphone case
```

为重新组织这些代码，我们可编写两个函数，每个都做一件具体的工作。大部分代码都与原来相同，只是效率更高。第一个函数将负责处理打印设计的工作，而第二个将概述打印了哪些设计：

```
❶ def print_models(unprinted_designs, completed_models):
      """
      模拟打印每个设计，直到没有未打印的设计为止
      打印每个设计后，都将其移到列表 completed_models 中
      """
      while unprinted_designs:
          current_design = unprinted_designs.pop()

          # 模拟根据设计制作 3D 打印模型的过程
          print("Printing model: " + current_design)
          completed_models.append(current_design)

❷ def show_completed_models(completed_models):
      """显示打印好的所有模型"""
      print("\nThe following models have been printed:")
      for completed_model in completed_models:
          print(completed_model)

  unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
  completed_models = []

  print_models(unprinted_designs, completed_models)
  show_completed_models(completed_models)
```

在❶处，我们定义了函数`print_models()`，它包含两个形参：一个需要打印的设计列表和一个打印好的模型列表。给定这两个列表，这个函数模拟打印每个设计的过程：将设计逐个地从未打印的设计列表中取出，并加入到打印好的模型列表中。在❷处，我们定义了函数`show_completed_models()`，它包含一个形参：打印好的模型列表。给定这个列表，函数`show_completed_models()`显示打印出来的每个模型的名称。

这个程序的输出与未使用函数的版本相同，但组织更为有序。完成大部分工作的代码都移到了两个函数中，让主程序更容易理解。只要看看主程序，你就知道这个程序的功能容易看清得多：

```
unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
```

我们创建了一个未打印的设计列表，还创建了一个空列表，用于存储打印好的模型。接下来，由于我们已经定义了两个函数，因此只需调用它们并传入正确的实参即可。我们调用`print_models()`并向它传递两个列表；像预期的一样，`print_models()`模拟打印设计的过程。接下来，我们调用`show_completed_models()`，并将打印好的模型列表传递给它，让其能够指出打印了哪些模型。描述性的函数名让别人阅读这些代码时也能明白，虽然其中没有任何注释。

相比于没有使用函数的版本，这个程序更容易扩展和维护。如果以后需要打印其他设计，只需再次调用`print_models()`即可。如果我们发现需要对打印代码进行修改，只需修改这些代码一次，就能影响所有调用该函数的地方；与必须分别修改程序的多个地方相比，这种修改的效率更高。

这个程序还演示了这样一种理念，即每个函数都应只负责一项具体的工作。第一个函数打印每个设计，而第二个显示打印好的模型；这优于使用一个函数来完成两项工作。编写函数时，如果你发现它执行的任务太多，请尝试将这些代码划分到两个函数中。别忘了，总是可以在一个函数中调用另一个函数，这有助于将复杂的任务划分成一系列的步骤。

#### **8.4.2　禁止函数修改列表**

有时候，需要禁止函数修改列表。例如，假设像前一个示例那样，你有一个未打印的设计列表，并编写了一个将这些设计移到打印好的模型列表中的函数。你可能会做出这样的决定：即便打印所有设计后，也要保留原来的未打印的设计列表，以供备案。但由于你将所有的设计都移出了`unprinted_designs`，这个列表变成了空的，原来的列表没有了。为解决这个问题，可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件。

要将列表的副本传递给函数，可以像下面这样做：

```
function_name(list_name[:])
```

切片表示法`[:]`创建列表的副本。在 print_models.py 中，如果不想清空未打印的设计列表，可像下面这样调用`print_models()`：

```
print_models(unprinted_designs[:], completed_models)
```

这样函数`print_models()`依然能够完成其工作，因为它获得了所有未打印的设计的名称，但它使用的是列表`unprinted_designs`的副本，而不是列表`unprinted_designs`本身。像以前一样，列表`completed_models`也将包含打印好的模型的名称，但函数所做的修改不会影响到列表`unprinted_designs`。

虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，否则还是应该将原始列表传递给函数，因为让函数使用现成列表可避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。

> **动手试一试**
>
> **8-9 魔术师**：创建一个包含魔术师名字的列表，并将其传递给一个名为`show_magicians()`的函数，这个函数打印列表中每个魔术师的名字。
>
> **8-10 了不起的魔术师**：在你为完成练习8-9而编写的程序中，编写一个名为`make_great()`的函数，对魔术师列表进行修改，在每个魔术师的名字中都加入字样“the Great”。调用函数`show_magicians()`，确认魔术师列表确实变了。
>
> **8-11 不变的魔术师**：修改你为完成练习8-10而编写的程序，在调用函数`make_great()`时，向它传递魔术师列表的副本。由于不想修改原始列表，请返回修改后的列表，并将其存储到另一个列表中。分别使用这两个列表来调用`show_magicians()`，确认一个列表包含的是原来的魔术师名字，而另一个列表包含的是添加了字样“the Great”的魔术师名字。

### **8.5　传递任意数量的实参**

有时候，你预先不知道函数需要接受多少个实参，好在 Python 允许函数从调用语句中收集任意数量的实参。

例如，来看一个制作比萨的函数，它需要接受很多配料，但你无法预先确定顾客要多少种配料。下面的函数只有一个形参`*toppings`，但不管调用语句提供了多少实参，这个形参都将它们统统收入囊中：

**pizza.py**

```
def make_pizza(*toppings):
    """打印顾客点的所有配料"""
    print(toppings)

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')
```

形参名`*toppings`中的星号让 Python 创建一个名为`toppings`的空元组，并将收到的所有值都封装到这个元组中。函数体内的`print`语句通过生成输出来证明 Python 能够处理使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。它以类似的方式处理不同的调用，注意，Python 将实参封装到一个元组中，即便函数只收到一个值也如此：

```
('pepperoni',)
('mushrooms', 'green peppers', 'extra cheese')
```

现在，我们可以将这条`print`语句替换为一个循环，对配料列表进行遍历，并对顾客点的比萨进行描述：

```
def make_pizza(*toppings):
    """概述要制作的比萨"""
    print("\nMaking a pizza with the following toppings:")
    for topping in toppings:
        print("- " + topping)

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')
```

不管收到的是一个值还是三个值，这个函数都能妥善地处理：

```
Making a pizza with the following toppings:
- pepperoni

Making a pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
```

不管函数收到的实参是多少个，这种语法都管用。

#### **8.5.1　结合使用位置实参和任意数量实参**

如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python 先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。

例如，如果前面的函数还需要一个表示比萨尺寸的实参，必须将该形参放在形参`*toppings`的前面：

```
def make_pizza(size, *toppings):
    """概述要制作的比萨"""
    print("\nMaking a " + str(size) +
          "-inch pizza with the following toppings:")
    for topping in toppings:
        print("- " + topping)

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

基于上述函数定义，Python 将收到的第一个值存储在形参`size`中，并将其他的所有值都存储在元组`toppings`中。在函数调用中，首先指定表示比萨尺寸的实参，然后根据需要指定任意数量的配料。

现在，每个比萨都有了尺寸和一系列配料，这些信息按正确的顺序打印出来了——首先是尺寸，然后是配料：

```
Making a 16-inch pizza with the following toppings:
- pepperoni

Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
```

#### **8.5.2　使用任意数量的关键字实参**

有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。一个这样的示例是创建用户简介：你知道你将收到有关用户的信息，但不确定会是什么样的信息。在下面的示例中，函数`build_profile()`接受名和姓，同时还接受任意数量的关键字实参：

**user_profile.py**

```
  def build_profile(first, last, **user_info):
      """创建一个字典，其中包含我们知道的有关用户的一切"""
      profile = {}
❶     profile['first_name'] = first
      profile['last_name'] = last
❷     for key, value in user_info.items():
          profile[key] = value
      return profile

  user_profile = build_profile('albert', 'einstein',
                               location='princeton',
                               field='physics')
  print(user_profile)
```

函数`build_profile()`的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—值对。形参`**user_info`中的两个星号让 Python 创建一个名为`user_info`的空字典，并将收到的所有名称—值对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问`user_info`中的名称—值对。

在`build_profile()`的函数体内，我们创建了一个名为`profile`的空字典，用于存储用户简介。在❶处，我们将名和姓加入到这个字典中，因为我们总是会从用户那里收到这两项信息。在❷处，我们遍历字典`user_info`中的键—值对，并将每个键—值对都加入到字典`profile`中。最后，我们将字典`profile`返回给函数调用行。

我们调用`build_profile()`，向它传递名（`'albert'`）、姓（`'einstein'`）和两个键—值对（`location='princeton'`和`field='physics'`），并将返回的`profile`存储在变量`user_profile`中，再打印这个变量：

```
{'first_name': 'albert', 'last_name': 'einstein',
'location': 'princeton', 'field': 'physics'}
```

在这里，返回的字典包含用户的名和姓，还有求学的地方和所学专业。调用这个函数时，不管额外提供了多少个键—值对，它都能正确地处理。

编写函数时，你可以以各种方式混合使用位置实参、关键字实参和任意数量的实参。知道这些实参类型大有裨益，因为阅读别人编写的代码时经常会见到它们。要正确地使用这些类型的实参并知道它们的使用时机，需要经过一定的练习。就目前而言，牢记使用最简单的方法来完成任务就好了。你继续往下阅读，就会知道在各种情况下哪种方法的效率是最高的。

> **动手试一试**
>
> **8-12 三明治**：编写一个函数，它接受顾客要在三明治中添加的一系列食材。这个函数只有一个形参（它收集函数调用中提供的所有食材），并打印一条消息，对顾客点的三明治进行概述。调用这个函数三次，每次都提供不同数量的实参。
>
> **8-13 用户简介**：复制前面的程序 user_profile.py，在其中调用`build_profile()`来创建有关你的简介；调用这个函数时，指定你的名和姓，以及三个描述你的键-值对。
>
> **8-14 汽车**：编写一个函数，将一辆汽车的信息存储在一个字典中。这个函数总是接受制造商和型号，还接受任意数量的关键字实参。这样调用这个函数：提供必不可少的信息，以及两个名称—值对，如颜色和选装配件。这个函数必须能够像下面这样进行调用：
>
> ```
> car = make_car('subaru', 'outback', color='blue', tow_package=True)
> ```
>
> 打印返回的字典，确认正确地处理了所有的信息。

### **8.6　将函数存储在模块中**

函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为**模块**的独立文件中，再将模块**导入**到主程序中。`import`语句允许在当前运行的程序文件中使用模块中的代码。

通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。这还能让你在众多不同的程序中重用函数。将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序。知道如何导入函数还能让你使用其他程序员编写的函数库。

导入模块的方法有多种，下面对每种都作简要的介绍。

#### **8.6.1　导入整个模块**

要让函数是可导入的，得先创建模块。**模块**是扩展名为.py 的文件，包含要导入到程序中的代码。下面来创建一个包含函数`make_pizza()`的模块。为此，我们将文件 pizza.py 中除函数`make_pizza()`之外的其他代码都删除：

**pizza.py**

```
def make_pizza(size, *toppings):
    """概述要制作的比萨"""
    print("\nMaking a " + str(size) +
          "-inch pizza with the following toppings:")
    for topping in toppings:
        print("- " + topping)
```

接下来，我们在 pizza.py 所在的目录中创建另一个名为 making_pizzas.py 的文件，这个文件导入刚创建的模块，再调用`make_pizza()`两次：

**making_pizzas.py**

```
  import pizza

❶ pizza.make_pizza(16, 'pepperoni')
  pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

Python 读取这个文件时，代码行`import pizza`让 Python 打开文件 pizza.py，并将其中的所有函数都复制到这个程序中。你看不到复制的代码，因为这个程序运行时，Python 在幕后复制这些代码。你只需知道，在 making_pizzas.py 中，可以使用 pizza.py 中定义的所有函数。

要调用被导入的模块中的函数，可指定导入的模块的名称`pizza`和函数名`make_pizza()`，并用句点分隔它们（见❶）。这些代码的输出与没有导入模块的原始程序相同：

```
Making a 16-inch pizza with the following toppings:
- pepperoni

Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
```

这就是一种导入方法：只需编写一条`import`语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。如果你使用这种`import`语句导入了名为`module_name.py`的整个模块，就可使用下面的语法来使用其中任何一个函数：

```
module_name.function_name()
```

#### **8.6.2　导入特定的函数**

你还可以导入模块中的特定函数，这种导入方法的语法如下：

```
from module_name import function_name
```

通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数：

```
from module_name import function_0, function_1, function_2
```

对于前面的 making_pizzas.py 示例，如果只想导入要使用的函数，代码将类似于下面这样：

```
from pizza import make_pizza

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

若使用这种语法，调用函数时就无需使用句点。由于我们在`import`语句中显式地导入了函数`make_pizza()`，因此调用它时只需指定其名称。

#### **8.6.3　使用 as 给函数指定别名**

如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的**别名**——函数的另一个名称，类似于外号。要给函数指定这种特殊外号，需要在导入它时这样做。

下面给函数`make_pizza()`指定了别名`mp()`。这是在`import`语句中使用`make_pizza as mp`实现的，关键字`as`将函数重命名为你提供的别名：

```
from pizza import make_pizza as mp

mp(16, 'pepperoni')
mp(12, 'mushrooms', 'green peppers', 'extra cheese')
```

上面的`import`语句将函数`make_pizza()`重命名为`mp()`；在这个程序中，每当需要调用`make_pizza()`时，都可简写成`mp()`，而 Python 将运行`make_pizza()`中的代码，这可避免与这个程序可能包含的函数`make_pizza()`混淆。

指定别名的通用语法如下：

```
from module_name import function_name as fn
```

#### **8.6.4　使用 as 给模块指定别名**

你还可以给模块指定别名。通过给模块指定简短的别名（如给模块`pizza`指定别名`p`），让你能够更轻松地调用模块中的函数。相比于`pizza.make_pizza()`，`p.make_pizza()`更为简洁：

```
import pizza as p

p.make_pizza(16, 'pepperoni')
p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

上述`import`语句给模块`pizza`指定了别名`p`，但该模块中所有函数的名称都没变。调用函数`make_pizza()`时，可编写代码`p.make_pizza()`而不是`pizza.make_pizza()`，这样不仅能使代码更简洁，还可以让你不再关注模块名，而专注于描述性的函数名。这些函数名明确地指出了函数的功能，对理解代码而言，它们比模块名更重要。

给模块指定别名的通用语法如下：

```
import module_name as mn
```

#### **8.6.5　导入模块中的所有函数**

使用星号（`*`）运算符可让 Python 导入模块中的所有函数：

```
from pizza import *

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

`import`语句中的星号让 Python 将模块`pizza`中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：Python 可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。

最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰，更容易阅读和理解。这里之所以介绍这种导入方法，只是想让你在阅读别人编写的代码时，如果遇到类似于下面的`import`语句，能够理解它们：

```
from module_name import *
```

### **8.7　函数编写指南**

编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。

每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它：他们完全可以相信代码如描述的那样运行；只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。

给形参指定默认值时，等号两边不要有空格：

```
def function_name(parameter_0, parameter_1='default value')
```

对于函数调用中的关键字实参，也应遵循这种约定：

```
function_name(value_0, parameter_1='value')
```

PEP 8（<https://www.python.org/dev/peps/pep-0008/>）建议代码行的长度不要超过79字符，这样只要编辑器窗口适中，就能看到整行代码。如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次 Tab 键，从而将形参列表和只缩进一层的函数体区分开来。

大多数编辑器都会自动对齐后续参数列表行，使其缩进程度与你给第一个参数列表行指定的缩进程度相同：

```
def function_name(
        parameter_0, parameter_1, parameter_2,
        parameter_3, parameter_4, parameter_5):
    function body...
```

如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。

所有的`import`语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。

> **动手试一试**
>
> **8-15 打印模型**：将示例 print_models.py 中的函数放在另一个名为 printing_functions.py 的文件中；在 print_models.py 的开头编写一条`import`语句，并修改这个文件以使用导入的函数。
>
> **8-16 导入**：选择一个你编写的且只包含一个函数的程序，并将这个函数放在另一个文件中。在主程序文件中，使用下述各种方法导入这个函数，再调用它：
>
> ```
> import module_name
> from module_name import function_name
> from module_name import function_name as fn
> import module_name as mn
> from module_name import *
> ```
>
> **8-17 函数编写指南**：选择你在本章中编写的三个程序，确保它们遵循了本节介绍的函数编写指南。

### **8.8　小结**

在本章中，你学习了：如何编写函数，以及如何传递实参，让函数能够访问完成其工作所需的信息；如何使用位置实参和关键字实参，以及如何接受任意数量的实参；显示输出的函数和返回值的函数；如何将函数同列表、字典、`if`语句和`while`循环结合起来使用。你还知道了如何将函数存储在被称为**模块**的独立文件中，让程序文件更简单、更易于理解。最后，你学习了函数编写指南，遵循这些指南可让程序始终结构良好，并对你和其他人来说易于阅读。

程序员的目标之一是，编写简单的代码来完成任务，而函数有助于你实现这样的目标。它们让你编写好代码块并确定其能够正确运行后，就可置之不理。确定函数能够正确地完成其工作后，你就可以接着投身于下一个编码任务。

函数让你编写代码一次后，想重用它们多少次就重用多少次。需要运行函数中的代码时，只需编写一行函数调用代码，就可让函数完成其工作。需要修改函数的行为时，只需修改一个代码块，而所做的修改将影响调用这个函数的每个地方。

使用函数让程序更容易阅读，而良好的函数名概述了程序各个部分的作用。相对于阅读一系列的代码块，阅读一系列函数调用让你能够更快地明白程序的作用。

函数还让代码更容易测试和调试。如果程序使用一系列的函数来完成其任务，而其中的每个函数都完成一项具体的工作，测试和维护起来将容易得多：你可编写分别调用每个函数的程序，并测试每个函数是否在它可能遇到的各种情形下都能正确地运行。经过这样的测试后你就能信心满满，深信你每次调用这些函数时，它们都将正确地运行。

在第 9 章，你将学习编写类。类将函数和数据整洁地封装起来，让你能够灵活而高效地使用它们。

------



## 第9章　类

### **老齐导读**

本章的重要程度与函数同等。

首先，请同学一定要把书中关于定义类和通过类创建实例（也称为实例化）的代码全部自己敲过，并且将程序调试成功，因为这是本章最基础的内容。

在了解了定义一个最通常类，并实现实例化的基础上，理解关于继承（单继承）的知识，方法还是跟着书敲代码、调试程序。

以上过程中难免遇到问题，请使用以下方法解决各种报错：

- 首先用网上搜索。注意，搜索有技巧，使用哪个搜索引擎搜索什么内容，也是有讲究的。
- 其次可以在群里面提问，但是，群里提问，应该是在搜索并尝试多种解决方案之后未遂才有的行为。如果见到错误就提问，即使得到了解决，下次遇到同样问题还是不知道怎么办。
- 第三，根据网上或者别人的帮助，再思考代码，做一些新的尝试修改，验证自己的理解。

以上是应对报错的方法，是得“渔”之道。

此外，在学习本章的时候，特别建议使用前面推荐的图书对比阅读。通过比较，不同图书各有各的侧重点，能够帮助你形成比较全面的对类的认识。当然，最好还是要多做一些练习题，熟能生巧。

![enter image description here](https://images.gitbook.cn/b7241fc0-882b-11e9-b6f4-77ea8c81f44e)

> **面向对象编程**是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为。基于类创建**对象**时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。
>
> 根据类来创建对象被称为**实例化**，这让你能够使用类的实例。在本章中，你将编写一些类并创建其实例。你将指定可在实例中存储什么信息，定义可对这些实例执行哪些操作。你还将编写一些类来扩展既有类的功能，让相似的类能够高效地共享代码。你将把自己编写的类存储在模块中，并在自己的程序文件中导入其他程序员编写的类。
>
> 理解面向对象编程有助于你像程序员那样看世界，还可以帮助你真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。了解类背后的概念可培养逻辑思维，让你能够通过编写程序来解决遇到的几乎任何问题。
>
> 随着面临的挑战日益严峻，类还能让你以及与你合作的其他程序员的生活更轻松。如果你与其他程序员基于同样的逻辑来编写代码，你们就能明白对方所做的工作；你编写的程序将能被众多合作者所理解，每个人都能事半功倍。

### **9.1　创建和使用类**

使用类几乎可以模拟任何东西。下面来编写一个表示小狗的简单类`Dog`——它表示的不是特定的小狗，而是任何小狗。对于大多数宠物狗，我们都知道些什么呢？它们都有名字和年龄；我们还知道，大多数小狗还会蹲下和打滚。由于大多数小狗都具备上述两项信息（名字和年龄）和两种行为（蹲下和打滚），我们的`Dog`类将包含它们。这个类让 Python 知道如何创建表示小狗的对象。编写这个类后，我们将使用它来创建表示特定小狗的实例。

#### **9.1.1　创建 Dog 类**

根据`Dog`类创建的每个实例都将存储名字和年龄。我们赋予了每条小狗蹲下（`sit()`）和打滚（`roll_over()`）的能力：

**dog.py**

```
❶ class Dog():
❷     """一次模拟小狗的简单尝试"""

❸     def __init__(self, name, age):
          """初始化属性 name 和 age"""
❹         self.name = name
          self.age = age

❺     def sit(self):
          """模拟小狗被命令时蹲下"""
          print(self.name.title() + " is now sitting.")

      def roll_over(self):
          """模拟小狗被命令时打滚"""
          print(self.name.title() + " rolled over!")
```

这里需要注意的地方很多，但你也不用担心，本章充斥着这样的结构，你有大把的机会熟悉它。在❶处，我们定义了一个名为`Dog`的类。根据约定，在 Python 中，首字母大写的名称指的是类。这个类定义中的括号是空的，因为我们要从空白创建这个类。在❷处，我们编写了一个文档字符串，对这个类的功能作了描述。

**1. 方法__init__()**

类中的函数称为**方法**；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。❸处的方法`__init__()`是一个特殊的方法，每当你根据`Dog`类创建新实例时，Python 都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免 Python 默认方法与普通方法发生名称冲突。

我们将方法`__init__()`定义成了包含三个形参：`self`、`name`和`age`。在这个方法的定义中，形参`self`必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参`self`呢？因为 Python 调用这个`__init__()`方法来创建`Dog`实例时，将自动传入实参`self`。每个与类相关联的方法调用都自动传递实参`self`，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建`Dog`实例时，Python 将调用`Dog`类的方法`__init__()`。我们将通过实参向`Dog()`传递名字和年龄；`self`会自动传递，因此我们不需要传递它。每当我们根据`Dog`类创建实例时，都只需给最后两个形参（`name`和`age`）提供值。

❹处定义的两个变量都有前缀`self`。以`self`为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。`self.name=name`获取存储在形参`name`中的值，并将其存储到变量`name`中，然后该变量被关联到当前创建的实例。`self.age=age`的作用与此类似。像这样可通过实例访问的变量称为**属性**。

`Dog`类还定义了另外两个方法：`sit()`和`roll_over()`（见❺）。由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参`self`。我们后面将创建的实例能够访问这些方法，换句话说，它们都会蹲下和打滚。当前，`sit()`和`roll_over()`所做的有限，它们只是打印一条消息，指出小狗正蹲下或打滚。但可以扩展这些方法以模拟实际情况：如果这个类包含在一个计算机游戏中，这些方法将包含创建小狗蹲下和打滚动画效果的代码。如果这个类是用于控制机器狗的，这些方法将引导机器狗做出蹲下和打滚的动作。

**2. 在 Python 2.7 中创建类**

在 Python 2.7 中创建类时，需要做细微的修改——在括号内包含单词`object`：

```
class ClassName(object):
    --snip--
```

这让 Python 2.7 类的行为更像 Python 3 类，从而简化了你的工作。

在 Python 2.7 中定义`Dog`类时，代码类似于下面这样：

```
class Dog(object):
    --snip--
```

#### **9.1.2　根据类创建实例**

可将类视为有关如何创建实例的说明。`Dog`类是一系列说明，让 Python 知道如何创建表示特定小狗的实例。

下面来创建一个表示特定小狗的实例：

```
  class Dog():
      --snip--

❶ my_dog = Dog('willie', 6)

❷ print("My dog's name is " + my_dog.name.title() + ".")
❸ print("My dog is " + str(my_dog.age) + " years old.")
```

这里使用的是前一个示例中编写的`Dog`类。在❶处，我们让 Python 创建一条名字为`'willie'`、年龄为`6`的小狗。遇到这行代码时，Python 使用实参`'willie'`和`6`调用`Dog`类中的方法`__init__()`。方法`__init__()`创建一个表示特定小狗的示例，并使用我们提供的值来设置属性`name`和`age`。方法`__init__()`并未显式地包含`return`语句，但 Python 自动返回一个表示这条小狗的实例。我们将这个实例存储在变量`my_dog`中。在这里，命名约定很有用：我们通常可以认为首字母大写的名称（如`Dog`）指的是类，而小写的名称（如`my_dog`）指的是根据类创建的实例。

**1. 访问属性**

要访问实例的属性，可使用句点表示法。在❷处，我们编写了如下代码来访问`my_dog`的属性`name`的值：

```
my_dog.name
```

句点表示法在 Python 中很常用，这种语法演示了 Python 如何获悉属性的值。在这里，Python 先找到实例`my_dog`，再查找与这个实例相关联的属性`name`。在`Dog`类中引用这个属性时，使用的是`self.name`。在❸处，我们使用同样的方法来获取属性`age`的值。在前面的第1条`print`语句中，`my_dog.name.title()`将`my_dog`的属性`name`的值`'willie'`改为首字母大写的；在第2条`print`语句中，`str(my_dog.age)`将`my_dog`的属性`age`的值`6`转换为字符串。

输出是有关`my_dog`的摘要：

```
My dog's name is Willie.
My dog is 6 years old.
```

**2. 调用方法**

根据`Dog`类创建实例后，就可以使用句点表示法来调用`Dog`类中定义的任何方法。下面来让小狗蹲下和打滚：

```
class Dog():
    --snip--

my_dog = Dog('willie', 6)
my_dog.sit()
my_dog.roll_over()
```

要调用方法，可指定实例的名称（这里是`my_dog`）和要调用的方法，并用句点分隔它们。遇到代码`my_dog.sit()`时，Python 在类`Dog`中查找方法`sit()`并运行其代码。Python 以同样的方式解读代码`my_dog.roll_over()`。

Willie 按我们的命令做了：

```
Willie is now sitting.
Willie rolled over!
```

这种语法很有用。如果给属性和方法指定了合适的描述性名称，如`name`、`age`、`sit()`和`roll_over()`，即便是从未见过的代码块，我们也能够轻松地推断出它是做什么的。

**3. 创建多个实例**

可按需求根据类创建任意数量的实例。下面再创建一个名为`your_dog`的实例：

```
class Dog():
    --snip--

my_dog = Dog('willie', 6)
your_dog = Dog('lucy', 3)

print("My dog's name is " + my_dog.name.title() + ".")
print("My dog is " + str(my_dog.age) + " years old.")
my_dog.sit()

print("\nYour dog's name is " + your_dog.name.title() + ".")
print("Your dog is " + str(your_dog.age) + " years old.")
your_dog.sit()
```

在这个实例中，我们创建了两条小狗，它们分别名为 Willie 和 Lucy。每条小狗都是一个独立的实例，有自己的一组属性，能够执行相同的操作：

```
My dog's name is Willie.
My dog is 6 years old.
Willie is now sitting.

Your dog's name is Lucy.
Your dog is 3 years old.
Lucy is now sitting.
```

就算我们给第二条小狗指定同样的名字和年龄，Python 依然会根据`Dog`类创建另一个实例。你可按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用列表或字典的不同位置。

> **动手试一试**
>
> **9-1 餐馆**：创建一个名为`Restaurant`的类，其方法`__init__()`设置两个属性：`restaurant_name`和`cuisine_type`。创建一个名为`describe_restaurant()`的方法和一个名为`open_restaurant()`的方法，其中前者打印前述两项信息，而后者打印一条消息，指出餐馆正在营业。
>
> 根据这个类创建一个名为`restaurant`的实例，分别打印其两个属性，再调用前述两个方法。
>
> **9-2 三家餐馆**：根据你为完成练习9-1而编写的类创建三个实例，并对每个实例调用方法`describe_restaurant()`。
>
> **9-3 用户**：创建一个名为`User`的类，其中包含属性`first_name`和`last_name`，还有用户简介通常会存储的其他几个属性。在类`User`中定义一个名为`describe_user()`的方法，它打印用户信息摘要；再定义一个名为`greet_user()`的方法，它向用户发出个性化的问候。
>
> 创建多个表示不同用户的实例，并对每个实例都调用上述两个方法。

### **9.2　使用类和实例**

你可以使用类来模拟现实世界中的很多情景。类编写好后，你的大部分时间都将花在使用根据类创建的实例上。你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。

#### **9.2.1　Car 类**

下面来编写一个表示汽车的类，它存储了有关汽车的信息，还有一个汇总这些信息的方法：

**car.py**

```
  class Car():
      """一次模拟汽车的简单尝试"""

❶     def __init__(self, make, model, year):
          """初始化描述汽车的属性"""
          self.make = make
          self.model = model
          self.year = year

❷     def get_descriptive_name(self):
          """返回整洁的描述性信息"""
          long_name = str(self.year) + ' ' + self.make + ' ' + self.model
          return long_name.title()

❸ my_new_car = Car('audi', 'a4', 2016)
  print(my_new_car.get_descriptive_name())
```

在❶处，我们定义了方法`__init__()`。与前面的`Dog`类中一样，这个方法的第一个形参为`self`；我们还在这个方法中包含了另外三个形参：`make`、`model`和`year`。方法`__init__()`接受这些形参的值，并将它们存储在根据这个类创建的实例的属性中。创建新的`Car`实例时，我们需要指定其制造商、型号和生产年份。

在❷处，我们定义了一个名为`get_descriptive_name()`的方法，它使用属性`year`、`make`和`model`创建一个对汽车进行描述的字符串，让我们无需分别打印每个属性的值。为在这个方法中访问属性的值，我们使用了`self.make`、`self.model`和`self.year`。在❸处，我们根据`Car`类创建了一个实例，并将其存储到变量`my_new_car`中。接下来，我们调用方法`get_descriptive_name()`，指出我们拥有的是一辆什么样的汽车：

```
2016 Audi A4
```

为让这个类更有趣，下面给它添加一个随时间变化的属性，它存储汽车的总里程。

#### **9.2.2　给属性指定默认值**

类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法`__init__()`内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。

下面来添加一个名为`odometer_reading`的属性，其初始值总是为0。我们还添加了一个名为`read_odometer()`的方法，用于读取汽车的里程表：

```
  class Car():

      def __init__(self, make, model, year):
          """初始化描述汽车的属性"""
          self.make = make
          self.model = model
          self.year = year
❶         self.odometer_reading = 0

      def get_descriptive_name(self):
          --snip--

❷     def read_odometer(self):
          """打印一条指出汽车里程的消息"""
          print("This car has " + str(self.odometer_reading) + " miles on it.")

  my_new_car = Car('audi', 'a4', 2016)
  print(my_new_car.get_descriptive_name())
  my_new_car.read_odometer()
```

现在，当 Python 调用方法`__init__()`来创建新实例时，将像前一个示例一样以属性的方式存储制造商、型号和生产年份。接下来，Python 将创建一个名为`odometer_reading`的属性，并将其初始值设置为0（见❶）。在❷处，我们还定义了一个名为`read_odometer()`的方法，它让你能够轻松地获悉汽车的里程。

一开始汽车的里程为0：

```
2016 Audi A4
This car has 0 miles on it.
```

出售时里程表读数为0的汽车并不多，因此我们需要一个修改该属性的值的途径。

#### **9.2.3　修改属性的值**

可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）。下面依次介绍这些方法。

**1. 直接修改属性的值**

要修改属性的值，最简单的方式是通过实例直接访问它。下面的代码直接将里程表读数设置为23：

```
  class Car():
      --snip--

  my_new_car = Car('audi', 'a4', 2016)
  print(my_new_car.get_descriptive_name())

❶ my_new_car.odometer_reading = 23
  my_new_car.read_odometer()
```

在❶处，我们使用句点表示法来直接访问并设置汽车的属性`odometer_reading`。这行代码让 Python 在实例`my_new_car`中找到属性`odometer_reading`，并将该属性的值设置为23：

```
2016 Audi A4
This car has 23 miles on it.
```

有时候需要像这样直接访问属性，但其他时候需要编写对属性进行更新的方法。

**2. 通过方法修改属性的值**

如果有替你更新属性的方法，将大有裨益。这样，你就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新。

下面的示例演示了一个名为`update_odometer()`的方法：

```
  class Car():
      --snip--

❶     def update_odometer(self, mileage):
          """将里程表读数设置为指定的值"""
          self.odometer_reading = mileage

  my_new_car = Car('audi', 'a4', 2016)
  print(my_new_car.get_descriptive_name())

❷ my_new_car.update_odometer(23)
  my_new_car.read_odometer()
```

对`Car`类所做的唯一修改是在❶处添加了方法`update_odometer()`。这个方法接受一个里程值，并将其存储到`self.odometer_reading`中。在❷处，我们调用了`update_odometer()`，并向它提供了实参23（该实参对应于方法定义中的形参`mileage`）。它将里程表读数设置为23；而方法`read_odometer()`打印该读数：

```
2016 Audi A4
This car has 23 miles on it.
```

可对方法`update_odometer()`进行扩展，使其在修改里程表读数时做些额外的工作。下面来添加一些逻辑，禁止任何人将里程表读数往回调：

```
  class Car():
      --snip--

      def update_odometer(self, mileage):
          """
          将里程表读数设置为指定的值
          禁止将里程表读数往回调
          """
❶         if mileage >= self.odometer_reading:
              self.odometer_reading = mileage
          else:
❷             print("You can't roll back an odometer!")
```

现在，`update_odometer()`在修改属性前检查指定的读数是否合理。如果新指定的里程（`mileage`）大于或等于原来的里程（`self.odometer_reading`），就将里程表读数改为新指定的里程（见❶）；否则就发出警告，指出不能将里程表往回拨（见❷）。

**3. 通过方法对属性的值进行递增**

有时候需要将属性值递增特定的量，而不是将其设置为全新的值。假设我们购买了一辆二手车，且从购买到登记期间增加了100英里的里程，下面的方法让我们能够传递这个增量，并相应地增加里程表读数：

```
  class Car():
      --snip--

      def update_odometer(self, mileage):
          --snip--

❶     def increment_odometer(self, miles):
          """将里程表读数增加指定的量"""
          self.odometer_reading += miles

❷ my_used_car = Car('subaru', 'outback', 2013)
  print(my_used_car.get_descriptive_name())

❸ my_used_car.update_odometer(23500)
  my_used_car.read_odometer()

❹ my_used_car.increment_odometer(100)
  my_used_car.read_odometer()
```

在❶处，新增的方法`increment_odometer()`接受一个单位为英里的数字，并将其加入到`self.odometer_reading`中。在❷处，我们创建了一辆二手车——`my_used_car`。在❸处，我们调用方法`update_odometer()`并传入`23500`，将这辆二手车的里程表读数设置为23500。在❹处，我们调用`increment_odometer()`并传入`100`，以增加从购买到登记期间行驶的100英里：

```
2013 Subaru Outback
This car has 23500 miles on it.
This car has 23600 miles on it.
```

你可以轻松地修改这个方法，以禁止增量为负值，从而防止有人利用它来回拨里程表。

> **注意**　
>
> 你可以使用类似于上面的方法来控制用户修改属性值（如里程表读数）的方式，但能够访问程序的人都可以通过直接访问属性来将里程表修改为任何值。要确保安全，除了进行类似于前面的基本检查外，还需特别注意细节。

> **动手试一试**
>
> **9-4 就餐人数**：在为完成练习9-1而编写的程序中，添加一个名为`number_served`的属性，并将其默认值设置为0。根据这个类创建一个名为`restaurant`的实例；打印有多少人在这家餐馆就餐过，然后修改这个值并再次打印它。
>
> 添加一个名为`set_number_served()`的方法，它让你能够设置就餐人数。调用这个方法并向它传递一个值，然后再次打印这个值。
>
> 添加一个名为`increment_number_served()`的方法，它让你能够将就餐人数递增。调用这个方法并向它传递一个这样的值：你认为这家餐馆每天可能接待的就餐人数。
>
> **9-5 尝试登录次数**：在为完成练习9-3而编写的`User`类中，添加一个名为`login_attempts` 的属性。编写一个名为`increment_login_attempts()`的方法，它将属性`login_attempts`的值加1。再编写一个名为`reset_login_attempts()`的方法，它将属性`login_attempts`的值重置为0。
>
> 根据`User`类创建一个实例，再调用方法`increment_login_attempts()`多次。打印属性`login_attempts`的值，确认它被正确地递增；然后，调用方法`reset_login_attempts()`，并再次打印属性`login_attempts`的值，确认它被重置为0。

### **9.3　继承**

编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用**继承**。一个类**继承**另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为**父类**，而新类称为**子类**。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。

#### **9.3.1　子类的方法__init__()**

创建子类的实例时，Python 首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法`__init__()`需要父类施以援手。

例如，下面来模拟电动汽车。电动汽车是一种特殊的汽车，因此我们可以在前面创建的`Car`类的基础上创建新类`ElectricCar`，这样我们就只需为电动汽车特有的属性和行为编写代码。

下面来创建一个简单的`ElectricCar`类版本，它具备`Car`类的所有功能：

**electric_car.py**

```
❶ class Car():
      """一次模拟汽车的简单尝试"""

      def __init__(self, make, model, year):
          self.make = make
          self.model = model
          self.year = year
          self.odometer_reading = 0

      def get_descriptive_name(self):
          long_name = str(self.year) + ' ' + self.make + ' ' + self.model
          return long_name.title()

      def read_odometer(self):
          print("This car has " + str(self.odometer_reading) + " miles on it.")

      def update_odometer(self, mileage):
          if mileage >= self.odometer_reading:
              self.odometer_reading = mileage
          else:
              print("You can't roll back an odometer!")

      def increment_odometer(self, miles):
          self.odometer_reading += miles

❷ class ElectricCar(Car):
      """电动汽车的独特之处"""

❸     def __init__(self, make, model, year):
          """初始化父类的属性"""
❹         super().__init__(make, model, year)


❺ my_tesla = ElectricCar('tesla', 'model s', 2016)
  print(my_tesla.get_descriptive_name())
```

首先是`Car`类的代码（见❶）。创建子类时，父类必须包含在当前文件中，且位于子类前面。在❷处，我们定义了子类`ElectricCar`。定义子类时，必须在括号内指定父类的名称。方法`__init__()`接受创建`Car`实例所需的信息（见❸）。

❹处的`super()`是一个特殊函数，帮助 Python 将父类和子类关联起来。这行代码让 Python 调用`ElectricCar`的父类的方法`__init__()`，让`ElectricCar`实例包含父类的所有属性。父类也称为**超类**（superclass），名称 super 因此而得名。

为测试继承是否能够正确地发挥作用，我们尝试创建一辆电动汽车，但提供的信息与创建普通汽车时相同。在❺处，我们创建`ElectricCar`类的一个实例，并将其存储在变量`my_tesla`中。这行代码调用`ElectricCar`类中定义的方法`__init__()`，后者让 Python 调用父类`Car`中定义的方法`__init__()`。我们提供了实参`'tesla'`、`'model s'`和`2016`。

除方法`__init__()`外，电动汽车没有其他特有的属性和方法。当前，我们只想确认电动汽车具备普通汽车的行为：

```
2016 Tesla Model S
```

`ElectricCar`实例的行为与`Car`实例一样，现在可以开始定义电动汽车特有的属性和方法了。

#### **9.3.2　Python 2.7 中的继承**

在 Python 2.7 中，继承语法稍有不同，`ElectricCar`类的定义类似于下面这样：

```
class Car(object):
    def __init__(self, make, model, year):
        --snip--

class ElectricCar(Car):
    def __init__(self, make, model, year):
        super(ElectricCar, self).__init__(make, model, year)
        --snip--
```

函数`super()`需要两个实参：子类名和对象`self`。为帮助 Python 将父类和子类关联起来，这些实参必不可少。另外，在 Python 2.7 中使用继承时，务必在定义父类时在括号内指定`object`。

#### **9.3.3　给子类定义属性和方法**

让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。

下面来添加一个电动汽车特有的属性（电瓶），以及一个描述该属性的方法。我们将存储电瓶容量，并编写一个打印电瓶描述的方法：

```
  class Car():
      --snip--

  class ElectricCar(Car):
      """Represent aspects of a car, specific to electric vehicles."""

      def __init__(self, make, model, year):
          """
          电动汽车的独特之处
          初始化父类的属性，再初始化电动汽车特有的属性
          """
          super().__init__(make, model, year)
❶         self.battery_size = 70

❷     def describe_battery(self):
          """打印一条描述电瓶容量的消息"""
          print("This car has a " + str(self.battery_size) + "-kWh battery.")

  my_tesla = ElectricCar('tesla', 'model s', 2016)
  print(my_tesla.get_descriptive_name())
  my_tesla.describe_battery()
```

在❶处，我们添加了新属性`self.battery_size`，并设置其初始值（如`70`）。根据`ElectricCar` 类创建的所有实例都将包含这个属性，但所有`Car`实例都不包含它。在❷处，我们还添加了一个名为`describe_battery()`的方法，它打印有关电瓶的信息。我们调用这个方法时，将看到一条电动汽车特有的描述：

```
2016 Tesla Model S
This car has a 70-kWh battery.
```

对于`ElectricCar`类的特殊化程度没有任何限制。模拟电动汽车时，你可以根据所需的准确程度添加任意数量的属性和方法。如果一个属性或方法是任何汽车都有的，而不是电动汽车特有的，就应将其加入到`Car`类而不是`ElectricCar`类中。这样，使用`Car`类的人将获得相应的功能，而`ElectricCar`类只包含处理电动汽车特有属性和行为的代码。

#### **9.3.4　重写父类的方法**

对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python 将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。

假设`Car`类有一个名为`fill_gas_tank()`的方法，它对全电动汽车来说毫无意义，因此你可能想重写它。下面演示了一种重写方式：

```
class ElectricCar(Car):
    --snip--

    def fill_gas_tank():
        """电动汽车没有油箱"""
        print("This car doesn't need a gas tank!")
```

现在，如果有人对电动汽车调用方法`fill_gas_tank()`，Python 将忽略`Car`类中的方法`fill_gas_tank()`，转而运行上述代码。使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。

#### **9.3.5　将实例用作属性**

使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。

例如，不断给`ElectricCar`类添加细节时，我们可能会发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为`Battery`的类中，并将一个`Battery`实例用作`ElectricCar`类的一个属性：

```
  class Car():
      --snip--

❶ class Battery():
      """一次模拟电动汽车电瓶的简单尝试"""

❷     def __init__(self, battery_size=70):
          """初始化电瓶的属性"""
          self.battery_size = battery_size

❸     def describe_battery(self):
          """打印一条描述电瓶容量的消息"""
          print("This car has a " + str(self.battery_size) + "-kWh battery.")


  class ElectricCar(Car):
      """电动汽车的独特之处"""

      def __init__(self, make, model, year):
          """
          初始化父类的属性，再初始化电动汽车特有的属性
          """
          super().__init__(make, model, year)
❹         self.battery = Battery()


  my_tesla = ElectricCar('tesla', 'model s', 2016)

  print(my_tesla.get_descriptive_name())
  my_tesla.battery.describe_battery()
```

在❶处，我们定义了一个名为`Battery`的新类，它没有继承任何类。❷处的方法`__init__()`除`self`外，还有另一个形参`battery_size`。这个形参是可选的：如果没有给它提供值，电瓶容量将被设置为70。方法`describe_battery()`也移到了这个类中（见❸）。

在`ElectricCar`类中，我们添加了一个名为`self.battery`的属性（见❹）。这行代码让 Python 创建一个新的`Battery`实例（由于没有指定尺寸，因此为默认值`70`），并将该实例存储在属性`self.battery`中。每当方法`__init__()`被调用时，都将执行该操作；因此现在每个`ElectricCar`实例都包含一个自动创建的`Battery`实例。

我们创建一辆电动汽车，并将其存储在变量`my_tesla`中。要描述电瓶时，需要使用电动汽车的属性`battery`：

```
my_tesla.battery.describe_battery()
```

这行代码让 Python 在实例`my_tesla`中查找属性`battery`，并对存储在该属性中的`Battery`实例调用方法`describe_battery()`。

输出与我们前面看到的相同：

```
2016 Tesla Model S
This car has a 70-kWh battery.
```

这看似做了很多额外的工作，但现在我们想多详细地描述电瓶都可以，且不会导致`ElectricCar`类混乱不堪。下面再给`Battery`类添加一个方法，它根据电瓶容量报告汽车的续航里程：

```
  class Car():
      --snip--

  class Battery():
      --snip--

❶     def get_range(self):
          """打印一条消息，指出电瓶的续航里程"""
         if self.battery_size == 70:
              range = 240
          elif self.battery_size == 85:
              range = 270

          message = "This car can go approximately " + str(range)
          message += " miles on a full charge."
          print(message)

  class ElectricCar(Car):
      --snip--

  my_tesla = ElectricCar('tesla', 'model s', 2016)
  print(my_tesla.get_descriptive_name())
  my_tesla.battery.describe_battery()
❷ my_tesla.battery.get_range()
```

❶处新增的方法`get_range()`做了一些简单的分析：如果电瓶的容量为 70kWh，它就将续航里程设置为240英里；如果容量为 85kWh，就将续航里程设置为270英里，然后报告这个值。为使用这个方法，我们也通过汽车的属性`battery`来调用它（见❷）。

输出指出了汽车的续航里程（这取决于电瓶的容量）：

```
2016 Tesla Model S
This car has a 70-kWh battery.
This car can go approximately 240 miles on a full charge.
```

#### **9.3.6　模拟实物**

模拟较复杂的物件（如电动汽车）时，需要解决一些有趣的问题。续航里程是电瓶的属性还是汽车的属性呢？如果我们只需描述一辆汽车，那么将方法`get_range()`放在`Battery`类中也许是合适的；但如果要描述一家汽车制造商的整个产品线，也许应该将方法`get_range()`移到`ElectricCar`类中。在这种情况下，`get_range()`依然根据电瓶容量来确定续航里程，但报告的是一款汽车的续航里程。我们也可以这样做：将方法`get_range()`还留在`Battery`类中，但向它传递一个参数，如`car_model`；在这种情况下，方法`get_range()`将根据电瓶容量和汽车型号报告续航里程。

这让你进入了程序员的另一个境界：解决上述问题时，你从较高的逻辑层面（而不是语法层面）考虑；你考虑的不是 Python，而是如何使用代码来表示实物。到达这种境界后，你经常会发现，现实世界的建模方法并没有对错之分。有些方法的效率更高，但要找出效率最高的表示法，需要经过一定的实践。只要代码像你希望的那样运行，就说明你做得很好！即便你发现自己不得不多次尝试使用不同的方法来重写类，也不必气馁；要编写出高效、准确的代码，都得经过这样的过程。

> **动手试一试**
>
> **9-6 冰淇淋小店**：冰淇淋小店是一种特殊的餐馆。编写一个名为`IceCreamStand`的类，让它继承你为完成练习9-1或练习9-4而编写的`Restaurant`类。这两个版本的`Restaurant`类都可以，挑选你更喜欢的那个即可。添加一个名为`flavors`的属性，用于存储一个由各种口味的冰淇淋组成的列表。编写一个显示这些冰淇淋的方法。创建一个`IceCreamStand`实例，并调用这个方法。
>
> **9-7 管理员**：管理员是一种特殊的用户。编写一个名为`Admin`的类，让它继承你为完成练习9-3或练习9-5而编写的`User`类。添加一个名为`privileges`的属性，用于存储一个由字符串（如`"can add post"`、`"can delete post"`、`"can ban user"`等）组成的列表。编写一个名为`show_privileges()`的方法，它显示管理员的权限。创建一个`Admin`实例，并调用这个方法。
>
> **9-8 权限**：编写一个名为`Privileges`的类，它只有一个属性——`privileges`，其中存储了练习`9-7`所说的字符串列表。将方法`show_privileges()`移到这个类中。在`Admin`类中，将一个`Privileges`实例用作其属性。创建一个`Admin`实例，并使用方法`show_privileges()`来显示其权限。
>
> **9-9 电瓶升级**：在本节最后一个 electric_car.py 版本中，给`Battery`类添加一个名为`upgrade_battery()`的方法。这个方法检查电瓶容量，如果它不是85，就将它设置为85。创建一辆电瓶容量为默认值的电动汽车，调用方法`get_range()`，然后对电瓶进行升级，并再次调用`get_range()`。你会看到这辆汽车的续航里程增加了。

### **9.4　导入类**

随着你不断地给类添加功能，文件可能变得很长，即便你妥善地使用了继承亦如此。为遵循 Python 的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python 允许你将类存储在模块中，然后在主程序中导入所需的模块。

#### **9.4.1　导入单个类**

下面来创建一个只包含`Car`类的模块。这让我们面临一个微妙的命名问题：在本章中，已经有一个名为 car.py 的文件，但这个模块也应命名为 car.py，因为它包含表示汽车的代码。我们将这样解决这个命名问题：将`Car`类存储在一个名为 car.py 的模块中，该模块将覆盖前面使用的文件 car.py。从现在开始，使用该模块的程序都必须使用更具体的文件名，如 my_car.py。下面是模块 car.py，其中只包含`Car`类的代码：

**car.py**

```
❶ """一个可用于表示汽车的类"""

  class Car():
      """一次模拟汽车的简单尝试"""

      def __init__(self, make, model, year):
          """初始化描述汽车的属性"""
          self.make = make
          self.model = model
          self.year = year
          self.odometer_reading = 0

      def get_descriptive_name(self):
          """返回整洁的描述性名称"""
          long_name = str(self.year) + ' ' + self.make + ' ' + self.model
          return long_name.title()

      def read_odometer(self):
          """打印一条消息，指出汽车的里程"""
          print("This car has " + str(self.odometer_reading) + " miles on it.")

      def update_odometer(self, mileage):
          """
          将里程表读数设置为指定的值
          拒绝将里程表往回拨
          """
          if mileage >= self.odometer_reading:
              self.odometer_reading = mileage
          else:
              print("You can't roll back an odometer!")

      def increment_odometer(self, miles):
          """将里程表读数增加指定的量"""
          self.odometer_reading += miles
```

在❶处，我们包含了一个模块级文档字符串，对该模块的内容做了简要的描述。你应为自己创建的每个模块都编写文档字符串。

下面来创建另一个文件——my_car.py，在其中导入`Car`类并创建其实例：

**my_car.py**

```
❶ from car import Car

  my_new_car = Car('audi', 'a4', 2016)
  print(my_new_car.get_descriptive_name())

  my_new_car.odometer_reading = 23
  my_new_car.read_odometer()
```

❶处的`import`语句让 Python 打开模块`car`，并导入其中的`Car`类。这样我们就可以使用`Car`类了，就像它是在这个文件中定义的一样。输出与我们在前面看到的一样：

```
2016 Audi A4
This car has 23 miles on it.
```

导入类是一种有效的编程方式。如果在这个程序中包含了整个`Car`类，它该有多长呀！通过将这个类移到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易于阅读了。这还能让你将大部分逻辑存储在独立的文件中；确定类像你希望的那样工作后，你就可以不管这些文件，而专注于主程序的高级逻辑了。

#### **9.4.2　在一个模块中存储多个类**

虽然同一个模块中的类之间应存在某种相关性，但可根据需要在一个模块中存储任意数量的类。类`Battery`和`ElectricCar`都可帮助模拟汽车，因此下面将它们都加入模块 car.py 中：

**car.py**

```
"""一组用于表示燃油汽车和电动汽车的类"""

class Car():
    --snip--

class Battery():
    """一次模拟电动汽车电瓶的简单尝试"""

    def __init__(self, battery_size=70):
        """初始化电瓶的属性"""
        self.battery_size = battery_size

    def describe_battery(self):
        """打印一条描述电瓶容量的消息"""
        print("This car has a " + str(self.battery_size) + "-kWh battery.")

    def get_range(self):
        """打印一条描述电瓶续航里程的消息"""
        if self.battery_size == 70:
            range = 240
        elif self.battery_size == 85:
            range = 270

        message = "This car can go approximately " + str(range)
        message += " miles on a full charge."
        print(message)

class ElectricCar(Car):
    """模拟电动汽车的独特之处"""

    def __init__(self, make, model, year):
        """
        初始化父类的属性，再初始化电动汽车特有的属性
        """
        super().__init__(make, model, year)
        self.battery = Battery()
```

现在，可以新建一个名为 my_electric_car.py 的文件，导入`ElectricCar`类，并创建一辆电动汽车了：

**my_electric_car.py**

```
from car import ElectricCar

my_tesla = ElectricCar('tesla', 'model s', 2016)

print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()
```

输出与我们前面看到的相同，但大部分逻辑都隐藏在一个模块中：

```
2016 Tesla Model S
This car has a 70-kWh battery.
This car can go approximately 240 miles on a full charge.
```

#### **9.4.3　从一个模块中导入多个类**

可根据需要在程序文件中导入任意数量的类。如果我们要在同一个程序中创建普通汽车和电动汽车，就需要将`Car`和`ElectricCar`类都导入：

**my_cars.py**

```
❶ from car import Car, ElectricCar

❷ my_beetle = Car('volkswagen', 'beetle', 2016)
  print(my_beetle.get_descriptive_name())

❸ my_tesla = ElectricCar('tesla', 'roadster', 2016)
  print(my_tesla.get_descriptive_name())
```

在❶处从一个模块中导入多个类时，用逗号分隔了各个类。导入必要的类后，就可根据需要创建每个类的任意数量的实例。

在这个示例中，我们在❷处创建了一辆大众甲壳虫普通汽车，并在❸处创建了一辆特斯拉 Roadster 电动汽车：

```
2016 Volkswagen Beetle
2016 Tesla Roadster
```

#### **9.4.4　导入整个模块**

你还可以导入整个模块，再使用句点表示法访问需要的类。这种导入方法很简单，代码也易于阅读。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。

下面的代码导入整个`car`模块，并创建一辆普通汽车和一辆电动汽车：

**my_cars.py**

```
❶ import car

❷ my_beetle = car.Car('volkswagen', 'beetle', 2016)
  print(my_beetle.get_descriptive_name())

❸ my_tesla = car.ElectricCar('tesla', 'roadster', 2016)
  print(my_tesla.get_descriptive_name())
```

在❶处，我们导入了整个`car`模块。接下来，我们使用语法*module_name.class_name*访问需要的类。像前面一样，我们在❷处创建了一辆大众甲壳虫汽车，并在❸处创建了一辆特斯拉 Roadster 汽车。

#### **9.4.5　导入模块中的所有类**

要导入模块中的每个类，可使用下面的语法：

```
from module_name import *
```

不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的`import`语句，就能清楚地知道程序使用了哪些类，将大有裨益；但这种导入方式没有明确地指出你使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使用这种方式，但你可能会在别人编写的代码中见到它。

需要从一个模块中导入很多类时，最好导入整个模块，并使用*module_name.class_name*语法来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地方使用了导入的模块；你还避免了导入模块中的每个类可能引发的名称冲突。

#### **9.4.6　在一个模块中导入另一个模块**

有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中存储不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。

例如，下面将`Car`类存储在一个模块中，并将`ElectricCar`和`Battery`类存储在另一个模块中。我们将第二个模块命名为`electric_car.py`（这将覆盖前面创建的文件 electric_car.py），并将`Battery`和`ElectricCar`类复制到这个模块中：

**electric_car.py**

```
  """一组可用于表示电动汽车的类"""

❶ from car import Car

  class Battery():
      --snip--

  class ElectricCar(Car):
      --snip--
```

`ElectricCar`类需要访问其父类`Car`，因此在❶处，我们直接将`Car`类导入该模块中。如果我们忘记了这行代码，Python 将在我们试图创建`ElectricCar`实例时引发错误。我们还需要更新模块`car`，使其包含`Car`类：

**car.py**

```
"""一个可用于表示汽车的类"""

class Car():
    --snip--
```

现在可以分别从每个模块中导入类，以根据需要创建任何类型的汽车了：

**my_cars.py**

```
❶ from car import Car
  from electric_car import ElectricCar

  my_beetle = Car('volkswagen', 'beetle', 2016)
  print(my_beetle.get_descriptive_name())

  my_tesla = ElectricCar('tesla', 'roadster', 2016)
  print(my_tesla.get_descriptive_name())
```

在❶处，我们从模块`car`中导入了`Car`类，并从模块`electric_car`中导入`ElectricCar`类。接下来，我们创建了一辆普通汽车和一辆电动汽车。这两种汽车都得以正确地创建：

```
2016 Volkswagen Beetle
2016 Tesla Roadster
```

#### **9.4.7　自定义工作流程**

正如你看到的，在组织大型项目的代码方面，Python 提供了很多选项。熟悉所有这些选项很重要，这样你才能确定哪种项目组织方式是最佳的，并能理解别人开发的项目。

一开始应让代码结构尽可能简单。先尽可能在一个文件中完成所有的工作，确定一切都能正确运行后，再将类移到独立的模块中。如果你喜欢模块和文件的交互方式，可在项目开始时就尝试将类存储到模块中。先找出让你能够编写出可行代码的方式，再尝试让代码更为组织有序。

> **动手试一试**
>
> **9-10 导入Restaurant类**：将最新的`Restaurant`类存储在一个模块中。在另一个文件中，导入`Restaurant`类，创建一个`Restaurant`实例，并调用`Restaurant`的一个方法，以确认`import`语句正确无误。
>
> **9-11 导入Admin类**：以为完成练习9-8而做的工作为基础，将`User`、`Privileges`和`Admin`类存储在一个模块中，再创建一个文件，在其中创建一个`Admin`实例并对其调用方法`show_privileges()`，以确认一切都能正确地运行。
>
> **9-12 多个模块**：将`User`类存储在一个模块中，并将`Privileges`和`Admin`类存储在另一个模块中。再创建一个文件，在其中创建一个`Admin`实例，并对其调用方法`show_privileges()`，以确认一切都依然能够正确地运行。

### **9.5　Python 标准库**

Python **标准库**是一组模块，安装的 Python 都包含它。你现在对类的工作原理已有大致的了解，可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的`import`语句。下面来看模块`collections`中的一个类——`OrderedDict`。

字典让你能够将信息关联起来，但它们不记录你添加键—值对的顺序。要创建字典并记录其中的键—值对的添加顺序，可使用模块`collections`中的`OrderedDict`类。`OrderedDict`实例的行为几乎与字典相同，区别只在于记录了键—值对的添加顺序。

我们再来看一看第6章的 favorite_languages.py 示例，但这次将记录被调查者参与调查的顺序：

**favorite_languages.py**

```
❶ from collections import OrderedDict

❷ favorite_languages = OrderedDict()

❸ favorite_languages['jen'] = 'python'
  favorite_languages['sarah'] = 'c'
  favorite_languages['edward'] = 'ruby'
  favorite_languages['phil'] = 'python'

❹ for name, language in favorite_languages.items():
      print(name.title() + "'s favorite language is " +
          language.title() + ".")
```

我们首先从模块`collections`中导入了`OrderedDict`类（见❶）。在❷处，我们创建了`OrderedDict`类的一个实例，并将其存储到`favorite_languages`中。请注意，这里没有使用花括号，而是调用`OrderedDict()`来创建一个空的有序字典，并将其存储在`favorite_languages`中。接下来，我们以每次一对的方式添加名字—语言对（见❸）。在❹处，我们遍历`favorite_languages`，但知道将以添加的顺序获取调查结果：

```
Jen's favorite language is Python.
Sarah's favorite language is C.
Edward's favorite language is Ruby.
Phil's favorite language is Python.
```

这是一个很不错的类，它兼具列表和字典的主要优点（在将信息关联起来的同时保留原来的顺序）。等你开始对关心的现实情形建模时，可能会发现有序字典正好能够满足需求。随着你对标准库的了解越来越深入，将熟悉大量可帮助你处理常见情形的模块。

> **注意**　
>
> 你还可以从其他地方下载外部模块。本书第二部分的每个项目都需要使用外部模块，届时你将看到很多这样的示例。

> **动手试一试**
>
> **9-13 使用OrderedDict**：在练习6-4中，你使用了一个标准字典来表示词汇表。请使用`OrderedDict`类来重写这个程序，并确认输出的顺序与你在字典中添加键—值对的顺序一致。
>
> **9-14 骰子**：模块`random`包含以各种方式生成随机数的函数，其中的`randint()`返回一个位于指定范围内的整数，例如，下面的代码返回一个1~6内的整数：
>
> ```
> from random import randint
> x = randint(1, 6)
> ```
>
> 请创建一个`Die`类，它包含一个名为`sides`的属性，该属性的默认值为6。编写一个名为`roll_die()`的方法，它打印位于1和骰子面数之间的随机数。创建一个6面的骰子，再掷10次。 创建一个10面的骰子和一个20面的骰子，并将它们都掷10次。
>
> **9-15 Python Module of the Week**：要了解 Python 标准库，一个很不错的资源是网站 Python Module of the Week。请访问<http://pymotw.com/> 并查看其中的目录，在其中找一个你感兴趣的模块进行探索，或阅读模块`collections`和`random`的文档。

### **9.6　类编码风格**

你必须熟悉有些与类相关的编码风格问题，在你编写的程序较复杂时尤其如此。

类名应采用**驼峰命名法**，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。

对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。

可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。

需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的`import`语句，再添加一个空行，然后编写导入你自己编写的模块的`import`语句。在包含多条`import`语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。

### **9.7　小结**

在本章中，你学习了：如何编写类；如何使用属性在类中存储信息，以及如何编写方法，以让类具备所需的行为；如何编写方法`__init__()`，以便根据类创建包含所需属性的实例。你见识了如何修改实例的属性——包括直接修改以及通过方法进行修改。你还了解了：使用继承可简化相关类的创建工作；将一个类的实例用作另一个类的属性可让类更简洁。

你了解到，通过将类存储在模块中，并在需要使用这些类的文件中导入它们，可让项目组织有序。你学习了 Python 标准库，并见识了一个使用模块`collections`中的`OrderedDict`类的示例。最后，你学习了编写类时应遵循的 Python 约定。

在第10章中，你将学习如何使用文件，这让你能够保存你在程序中所做的工作，以及你让用户做的工作。你还将学习**异常**，这是一种特殊的 Python 类，用于帮助你在发生错误时采取相应的措施。

------



## 第10章　文件和异常

### **老齐导读**

Python 中直接打开文件的函数是 open，书中分别演示了读、写两种模式。并且直接使用上限文管理器：with 实现对文件的管理，这样在写入文件之后，就不需要执行 close 方法，否则就要执行此方法。

对于文件对象而言，还有很多其他方法，建议读者利用`dir`函数和`help`函数查看。

异常，是程序常见的现象，每次我们的代码有问题，都会出现异常，导致程序中止运行。如何处理异常，通常使用 try … except 捕获。

如果你在业务中遇到了非常特别的异常，还可以利用上一章学习的类的知识，自定义异常（需要参考推荐的书籍进一步学习）。

![enter image description here](https://images.gitbook.cn/8bb9b790-8831-11e9-b6f4-77ea8c81f44e)

> 至此，你掌握了编写组织有序而易于使用的程序所需的基本技能，该考虑让程序目标更明确、用途更大了。在本章中，你将学习处理文件，让程序能够快速地分析大量的数据；你将学习错误处理，避免程序在面对意外情形时崩溃；你将学习**异常**，它们是 Python 创建的特殊对象，用于管理程序运行时出现的错误；你还将学习模块`json`，它让你能够保存用户数据，以免在程序停止运行后丢失。
>
> 学习处理文件和保存数据可让你的程序使用起来更容易：用户将能够选择输入什么样的数据，以及在什么时候输入；用户使用你的程序做一些工作后，可将程序关闭，以后再接着往下做。学习处理异常可帮助你应对文件不存在的情形，以及处理其他可能导致程序崩溃的问题。这让你的程序在面对错误的数据时更健壮——不管这些错误数据源自无意的错误，还是源自破坏程序的恶意企图。你在本章学习的技能可提高程序的适用性、可用性和稳定性。

### **10.1　从文件中读取数据**

文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此。例如，你可以编写一个这样的程序：读取一个文本文件的内容，重新设置这些数据的格式并将其写入文件，让浏览器能够显示这些内容。

要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。

#### **10.1.1　读取整个文件**

要读取文件，需要一个包含几行文本的文件。下面首先来创建一个文件，它包含精确到小数点后30位的圆周率值，且在小数点后每10位处都换行：

**pi_digits.txt**

```
3.1415926535
  8979323846
  2643383279
  　
```

要动手尝试后续示例，可在编辑器中输入这些数据行，再将文件保存为 pi_digits.txt，也可从本书的主页（<http://www.ituring.com.cn/book/1861>）下载该文件。然后，将该文件保存到本章程序所在的目录中。

下面的程序打开并读取这个文件，再将其内容显示到屏幕上：

**file_reader.py**

```
with open('pi_digits.txt') as file_object:
    contents = file_object.read()
    print(contents)
```

在这个程序中，第1行代码做了大量的工作。我们先来看看函数`open()`。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先**打开**文件，这样才能访问它。函数`open()`接受一个参数：要打开的文件的名称。Python 在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是 file_reader.py，因此 Python 在 file_reader.py 所在的目录中查找 pi_digits.txt。函数`open()`返回一个表示文件的对象。在这里，`open('pi_digits.txt')`返回一个表示文件`pi_digits.txt`的对象；Python 将这个对象存储在我们将在后面使用的变量中。

关键字`with`在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了`open()`，但没有调用`close()`；你也可以调用`open()`和`close()`来打开和关闭文件，但这样做时，如果程序存在 bug，导致`close()`语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用`close()`，你会发现需要使用文件时它已**关闭**（无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让 Python 去确定：你只管打开文件，并在需要时使用它，Python 自会在合适的时候自动将其关闭。

有了表示 pi_digits.txt 的文件对象后，我们使用方法`read()`（前述程序的第2行）读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量`contents`中。这样，通过打印`contents`的值，就可将这个文本文件的全部内容显示出来：

```
3.1415926535
  8979323846
  2643383279
  　
```

为何会多出这个空行呢？因为`read()`到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除末尾的空行，可在`print`语句中使用`rstrip()`：

```
with open('pi_digits.txt') as file_object:
    contents = file_object.read()
    print(contents.rstrip())
```

本书前面说过，Python 方法`rstrip()`删除（剥除）字符串末尾的空白。现在，输出与原始文件的内容完全相同：

```
3.1415926535
  8979323846
  2643383279
```

#### **10.1.2　文件路径**

当你将类似 pi_digits.txt 这样的简单文件名传递给函数`open()`时，Python 将在当前执行的文件（即.py 程序文件）所在的目录中查找文件。

根据你组织文件的方式，有时可能要打开不在程序文件所属目录中的文件。例如，你可能将程序文件存储在了文件夹 python_work 中，而在文件夹 python_work中，有一个名为 text_files 的文件夹，用于存储程序文件操作的文本文件。虽然文件夹 text_files 包含在文件夹 python_work 中，但仅向`open()`传递位于该文件夹中的文件的名称也不可行，因为 Python 只在文件夹 python_work 中查找，而不会在其子文件夹 text_files 中查找。要让 Python 打开不与程序文件位于同一个目录中的文件，需要提供**文件路径**，它让 Python 到系统的特定位置去查找。

由于文件夹 text_files 位于文件夹 python_work 中，因此可使用**相对文件路**径来打开该文件夹中的文件。相对文件路径让 Python 到指定的位置去查找，而该位置是相对于当前运行的程序所在目录的。在 Linux 和 OS X 中，你可以这样编写代码：

```
with open('text_files/filename.txt') as file_object:
```

这行代码让 Python 到文件夹 python_work 下的文件夹 text_files 中去查找指定的.txt 文件。在 Windows 系统中，在文件路径中使用反斜杠（`\`）而不是斜杠（`/`）：

```
with open('text_files\filename.txt') as file_object:
```

你还可以将文件在计算机中的准确位置告诉 Python，这样就不用关心当前运行的程序存储在什么地方了。这称为**绝对文件路径**。在相对路径行不通时，可使用绝对路径。例如，如果 text_files 并不在文件夹 python_work 中，而在文件夹 other_files 中，则向`open()`传递路径`'text_files/ filename.txt'`行不通，因为 Python 只在文件夹 python_work 中查找该位置。为明确地指出你希望 Python 到哪里去查找，你需要提供完整的路径。

绝对路径通常比相对路径更长，因此将其存储在一个变量中，再将该变量传递给`open()`会有所帮助。在 Linux 和 OS X 中，绝对路径类似于下面这样：

```
file_path = '/home/ehmatthes/other_files/text_files/filename.txt'
with open(file_path) as file_object:
```

而在 Windows 系统中，它们类似于下面这样：

```
file_path = 'C:\Users\ehmatthes\other_files\text_files\filename.txt'
with open(file_path) as file_object:
```

通过使用绝对路径，可读取系统任何地方的文件。就目前而言，最简单的做法是，要么将数据文件存储在程序文件所在的目录，要么将其存储在程序文件所在目录下的一个文件夹（如 text_files）中。

> **注意**　
>
> Windows 系统有时能够正确地解读文件路径中的斜杠。如果你使用的是 Windows 系统，且结果不符合预期，请确保在文件路径中使用的是反斜杠。另外，由于反斜杠在 Python 中被视为转义标记，为在 Windows 中确保万无一失，应以原始字符串的方式指定路径，即在开头的单引号前加上`r`。

#### **10.1.3　逐行读取**

读取文件时，常常需要检查其中的每一行：你可能要在文件中查找特定的信息，或者要以某种方式修改文件中的文本。例如，你可能要遍历一个包含天气数据的文件，并使用天气描述中包含字样 sunny 的行。在新闻报道中，你可能会查找包含标签`<headline>`的行，并按特定的格式设置它。

要以每次一行的方式检查文件，可对文件对象使用`for`循环：

**file_reader.py**

```
❶ filename = 'pi_digits.txt'

❷ with open(filename) as file_object:
❸     for line in file_object:
      print(line)
```

在❶处，我们将要读取的文件的名称存储在变量`filename`中，这是使用文件时一种常见的做法。由于变量`filename`表示的并非实际文件——它只是一个让 Python 知道到哪里去查找文件的字符串，因此可轻松地将`'pi_digits.txt'`替换为你要使用的另一个文件的名称。调用`open()`后，将一个表示文件及其内容的对象存储到了变量`file_object`中（见❷）。这里也使用了关键字`with`，让 Python 负责妥善地打开和关闭文件。为查看文件的内容，我们通过对文件对象执行循环来遍历文件中的每一行（见❸）。

我们打印每一行时，发现空白行更多了：

```
3.1415926535

  8979323846

  2643383279
```

为何会出现这些空白行呢？因为在这个文件中，每行的末尾都有一个看不见的换行符，而`print`语句也会加上一个换行符，因此每行末尾都有两个换行符：一个来自文件，另一个来自`print`语句。要消除这些多余的空白行，可在`print`语句中使用`rstrip()`：

```
filename = 'pi_digits.txt'

with open(filename) as file_object:
    for line in file_object:
        print(line.rstrip())
```

现在，输出又与文件内容完全相同了：

```
3.1415926535
  8979323846
  2643383279
```

#### **10.1.4　创建一个包含文件各行内容的列表**

使用关键字`with`时，`open()`返回的文件对象只在`with`代码块内可用。如果要在`with`代码块外访问文件的内容，可在`with`代码块内将文件的各行存储在一个列表中，并在`with`代码块外使用该列表：你可以立即处理文件的各个部分，也可推迟到程序后面再处理。

下面的示例在`with`代码块中将文件 pi_digits.txt 的各行存储在一个列表中，再在`with`代码块外打印它们：

```
  filename = 'pi_digits.txt'

  with open(filename) as file_object:
❶     lines = file_object.readlines()

❷ for line in lines:
      print(line.rstrip())
```

❶处的方法`readlines()`从文件中读取每一行，并将其存储在一个列表中；接下来，该列表被存储到变量`lines`中；在`with`代码块外，我们依然可以使用这个变量。在❷处，我们使用一个简单的`for`循环来打印`lines`中的各行。由于列表`lines`的每个元素都对应于文件中的一行，因此输出与文件内容完全一致。

#### **10.1.5　使用文件的内容**

将文件读取到内存中后，就可以以任何方式使用这些数据了。下面以简单的方式使用圆周率的值。首先，我们将创建一个字符串，它包含文件中存储的所有数字，且没有任何空格：

**pi_string.py**

```
  filename = 'pi_digits.txt'

  with open(filename) as file_object:
      lines = file_object.readlines()

❶ pi_string = ''
❷ for line in lines:
      pi_string += line.rstrip()

❸ print(pi_string)
  print(len(pi_string))
```

就像前一个示例一样，我们首先打开文件，并将其中的所有行都存储在一个列表中。在❶处，我们创建了一个变量——`pi_string`，用于存储圆周率的值。接下来，我们使用一个循环将各行都加入`pi_string`，并删除每行末尾的换行符（见❷）。在❸处，我们打印这个字符串及其长度：

```
3.1415926535  8979323846  2643383279
36
```

在变量`pi_string`存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用`strip()`而不是`rstrip()`：

```
filename = 'pi_30_digits.txt'

with open(filename) as file_object:
    lines = file_object.readlines()

pi_string = ''
for line in lines:
    pi_string += line.strip()

print(pi_string)
print(len(pi_string))
```

这样，我们就获得了一个这样的字符串：它包含精确到30位小数的圆周率值。这个字符串长32字符，因为它还包含整数部分的3和小数点：

```
3.141592653589793238462643383279
32
```

> **注意**　
>
> 读取文本文件时，Python 将其中的所有文本都解读为字符串。如果你读取的是数字，并要将其作为数值使用，就必须使用函数`int()`将其转换为整数，或使用函数`float()`将其转换为浮点数。

#### **10.1.6　包含一百万位的大型文件**

前面我们分析的都是一个只有三行的文本文件，但这些代码示例也可处理大得多的文件。如果我们有一个文本文件，其中包含精确到小数点后1000000位而不是30位的圆周率值，也可创建一个包含所有这些数字的字符串。为此，我们无需对前面的程序做任何修改，只需将这个文件传递给它即可。在这里，我们只打印到小数点后50位，以免终端为显示全部1000000位而不断地翻滚：

**pi_string.py**

```
filename = 'pi_million_digits.txt'

with open(filename) as file_object:
    lines = file_object.readlines()

pi_string = ''
for line in lines:
    pi_string += line.strip()

print(pi_string[:52] + "...")
print(len(pi_string))
```

输出表明，我们创建的字符串确实包含精确到小数点后1000000位的圆周率值：

```
3.14159265358979323846264338327950288419716939937510...
1000002
```

对于你可处理的数据量，Python 没有任何限制；只要系统的内存足够多，你想处理多少数据都可以。

> **注意**　
>
> 要运行这个程序（以及后面的众多示例），你需要从<http://www.ituring.com.cn/book/1861> 下载相关的资源。

#### **10.1.7　圆周率值中包含你的生日吗**

我一直想知道自己的生日是否包含在圆周率值中。下面来扩展刚才编写的程序，以确定某个人的生日是否包含在圆周率值的前1000000位中。为此，可将生日表示为一个由数字组成的字符串，再检查这个字符串是否包含在`pi_string`中：

```
  filename = 'pi_million_digits.txt'

  with open(filename) as file_object:
      lines = file_object.readlines()

  pi_string = ''
  for line in lines:
      pi_string += line.strip()

❶ birthday = input("Enter your birthday, in the form mmddyy: ")
❷ if birthday in pi_string:
      print("Your birthday appears in the first million digits of pi!")
  else:
      print("Your birthday does not appear in the first million digits of pi.")
```

在❶处，我们提示用户输入其生日，在接下来的❷处，我们检查这个字符串是否包含在`pi_string`中。运行一下这个程序：

```
Enter your birthdate, in the form mmddyy: 120372
Your birthday appears in the first million digits of pi!
```

我的生日确实出现在了圆周率值中！读取文件的内容后，就可以以你能想到的任何方式对其进行分析。

> **动手试一试**
>
> **10-1 Python 学习笔记**：在文本编辑器中新建一个文件，写几句话来总结一下你至此学到的 Python 知识，其中每一行都以“In Python you can”打头。将这个文件命名为 learning_python.txt，并将其存储到为完成本章练习而编写的程序所在的目录中。编写一个程序，它读取这个文件，并将你所写的内容打印三次：第一次打印时读取整个文件；第二次打印时遍历文件对象；第三次打印时将各行存储在一个列表中，再在`with`代码块外打印它们。
>
> **10-2 C 语言学习笔记**：可使用方法`replace()`将字符串中的特定单词都替换为另一个单词。下面是一个简单的示例，演示了如何将句子中的`'dog'`替换为`'cat'`：
>
> ```
> >>> message = "I really like dogs."
> >>> message.replace('dog', 'cat')
> 'I really like cats.'
> ```
>
> 读取你刚创建的文件 learning_python.txt 中的每一行，将其中的 Python 都替换为另一门语言的名称，如 C。将修改后的各行都打印到屏幕上。

### **10.2　写入文件**

保存数据的最简单的方式之一是将其写入到文件中。通过将输出写入文件，即便关闭包含程序输出的终端窗口，这些输出也依然存在：你可以在程序结束运行后查看这些输出，可与别人分享输出文件，还可编写程序来将这些输出读取到内存中并进行处理。

#### **10.2.1　写入空文件**

要将文本写入文件，你在调用`open()`时需要提供另一个实参，告诉 Python 你要写入打开的文件。为明白其中的工作原理，我们来将一条简单的消息存储到文件中，而不是将其打印到屏幕上：

**write_message.py**

```
  filename = 'programming.txt'

❶ with open(filename, 'w') as file_object:
❷     file_object.write("I love programming.")
```

在这个示例中，调用`open()`时提供了两个实参（见❶）。第一个实参也是要打开的文件的名称；第二个实参（`'w'`）告诉 Python，我们要以**写入模式**打开这个文件。打开文件时，可指定**读取模式**（`'r'`）、**写入模式**（`'w'`）、**附加模式**（`'a'`）或让你能够读取和写入文件的模式（`'r+'`）。如果你省略了模式实参，Python 将以默认的只读模式打开文件。

如果你要写入的文件不存在，函数`open()`将自动创建它。然而，以写入（`'w'`）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python 将在返回文件对象前清空该文件。

在❷处，我们使用文件对象的方法`write()`将一个字符串写入文件。这个程序没有终端输出，但如果你打开文件 programming.txt，将看到其中包含如下一行内容：

**programming.txt**

```
I love programming.
```

相比于你的计算机中的其他文件，这个文件没有什么不同。你可以打开它、在其中输入新文本、复制其内容、将内容粘贴到其中等。

> **注意**　
>
> Python 只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数`str()`将其转换为字符串格式。

#### **10.2.2　写入多行**

函数`write()`不会在你写入的文本末尾添加换行符，因此如果你写入多行时没有指定换行符，文件看起来可能不是你希望的那样：

```
filename = 'programming.txt'

with open(filename, 'w') as file_object:
    file_object.write("I love programming.")
    file_object.write("I love creating new games.")
```

如果你打开 programming.txt，将发现两行内容挤在一起：

```
I love programming.I love creating new games.
```

要让每个字符串都单独占一行，需要在`write()`语句中包含换行符：

```
filename = 'programming.txt'

with open(filename, 'w') as file_object:
    file_object.write("I love programming.\n")
    file_object.write("I love creating new games.\n")
    　
```

现在，输出出现在不同行中：

```
I love programming.
I love creating new games.
```

像显示到终端的输出一样，还可以使用空格、制表符和空行来设置这些输出的格式。

#### **10.2.3　附加到文件**

如果你要给文件添加内容，而不是覆盖原有的内容，可以**附加模式**打开文件。你以附加模式打开文件时，Python 不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python 将为你创建一个空文件。

下面来修改 write_message.py，在既有文件 programming.txt 中再添加一些你酷爱编程的原因：

**write_message.py**

```
  filename = 'programming.txt'

❶ with open(filename, 'a') as file_object:
❷     file_object.write("I also love finding meaning in large datasets.\n")
      file_object.write("I love creating apps that can run in a browser.\n")
```

在❶处，我们打开文件时指定了实参`'a'`，以便将内容附加到文件末尾，而不是覆盖文件原来的内容。在❷处，我们又写入了两行，它们被添加到文件 programming.txt 末尾：

**programming.txt**

```
I love programming.
I love creating new games.
I also love finding meaning in large datasets.
I love creating apps that can run in a browser.
　
```

最终的结果是，文件原来的内容还在，它们后面是我们刚添加的内容。

> **动手试一试**
>
> **10-3 访客**：编写一个程序，提示用户输入其名字；用户作出响应后，将其名字写入到文件 guest.txt 中。
>
> **10-4 访客名单**：编写一个`while`循环，提示用户输入其名字。用户输入其名字后，在屏幕上打印一句问候语，并将一条访问记录添加到文件 guest_book.txt 中。确保这个文件中的每条记录都独占一行。
>
> **10-5 关于编程的调查**：编写一个`while`循环，询问用户为何喜欢编程。每当用户输入一个原因后，都将其添加到一个存储所有原因的文件中。

### **10.3　异常**

Python 使用被称为**异常**的特殊对象来管理程序执行期间发生的错误。每当发生让 Python 不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个 traceback，其中包含有关异常的报告。

异常是使用`try-except`代码块处理的。`try-except`代码块让 Python 执行指定的操作，同时告诉 Python 发生异常时怎么办。使用了`try-except`代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的 traceback。

#### **10.3.1　处理 ZeroDivisionError 异常**

下面来看一种导致 Python 引发异常的简单错误。你可能知道不能将一个数字除以0，但我们还是让 Python 这样做吧：

**division.py**

```
print(5/0)
```

显然，Python 无法这样做，因此你将看到一个 traceback：

```
  Traceback (most recent call last):
    File "division.py", line 1, in <module>
      print(5/0)
❶ ZeroDivisionError: division by zero
```

在上述 traceback 中，❶处指出的错误`ZeroDivisionError`是一个异常对象。Python 无法按你的要求做时，就会创建这种对象。在这种情况下，Python 将停止运行程序，并指出引发了哪种异常，而我们可根据这些信息对程序进行修改。下面我们将告诉 Python，发生这种错误时怎么办；这样，如果再次发生这样的错误，我们就有备无患了。

#### **10.3.2　使用 try-except 代码块**

当你认为可能发生了错误时，可编写一个`try-except`代码块来处理可能引发的异常。你让 Python 尝试运行一些代码，并告诉它如果这些代码引发了指定的异常，该怎么办。

处理`ZeroDivisionError`异常的`try-except`代码块类似于下面这样：

```
try:
    print(5/0)
except ZeroDivisionError:
    print("You can't divide by zero!")
```

我们将导致错误的代码行`print(5/0)`放在了一个`try`代码块中。如果`try`代码块中的代码运行起来没有问题，Python 将跳过`except`代码块；如果`try`代码块中的代码导致了错误，Python 将查找这样的`except`代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。

在这个示例中，`try`代码块中的代码引发了`ZeroDivisionError`异常，因此 Python 指出了该如何解决问题的`except`代码块，并运行其中的代码。这样，用户看到的是一条友好的错误消息，而不是 traceback：

```
You can't divide by zero!
```

如果`try-except`代码块后面还有其他代码，程序将接着运行，因为已经告诉了 Python 如何处理这种错误。下面来看一个捕获错误后程序将继续运行的示例。

#### **10.3.3　使用异常避免崩溃**

发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出现在要求用户提供输入的程序中；如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。

下面来创建一个只执行除法运算的简单计算器：

**division.py**

```
  print("Give me two numbers, and I'll divide them.")
  print("Enter 'q' to quit.")

  while True:
❶     first_number = input("\nFirst number: ")
      if first_number == 'q':
          break
❷     second_number = input("Second number: ")
      if second_number == 'q':
          break
❸     answer = int(first_number) / int(second_number)
      print(answer)
```

在❶处，这个程序提示用户输入一个数字，并将其存储到变量`first_number`中；如果用户输入的不是表示退出的 q，就再提示用户输入一个数字，并将其存储到变量`second_number`中（见❷）。接下来，我们计算这两个数字的商（即`answer`，见❸）。这个程序没有采取任何处理错误的措施，因此让它执行除数为0的除法运算时，它将崩溃：

```
Give me two numbers, and I'll divide them.
Enter 'q' to quit.

First number: 5
Second number: 0
Traceback (most recent call last):
  File "division.py", line 9, in <module>
    answer = int(first_number) / int(second_number)
ZeroDivisionError: division by zero
```

程序崩溃可不好，但让用户看到 traceback 也不是好主意。不懂技术的用户会被它们搞糊涂，而且如果用户怀有恶意，他会通过 traceback 获悉你不希望他知道的信息。例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。

#### **10.3.4　else 代码块**

通过将可能引发错误的代码放在`try-except`代码块中，可提高这个程序抵御错误的能力。错误是执行除法运算的代码行导致的，因此我们需要将它放到`try-except`代码块中。这个示例还包含一个`else`代码块；依赖于`try`代码块成功执行的代码都应放到`else`代码块中：

```
  print("Give me two numbers, and I'll divide them.")
  print("Enter 'q' to quit.")

  while True:
      first_number = input("\nFirst number: ")
      if first_number == 'q':
          break
      second_number = input("Second number: ")
❶     try:
          answer = int(first_number) / int(second_number)
❷     except ZeroDivisionError:
          print("You can't divide by 0!")
❸     else:
          print(answer)
```

我们让 Python 尝试执行`try`代码块中的除法运算（见❶），这个代码块只包含可能导致错误的代码。依赖于`try`代码块成功执行的代码都放在`else`代码块中；在这个示例中，如果除法运算成功，我们就使用`else`代码块来打印结果（见❸）。

`except`代码块告诉 Python，出现`ZeroDivisionError`异常时该怎么办（见❷）。如果`try`代码块因除零错误而失败，我们就打印一条友好的消息，告诉用户如何避免这种错误。程序将继续运行，用户根本看不到 traceback：

```
Give me two numbers, and I'll divide them.
Enter 'q' to quit.

First number: 5
Second number: 0
You can't divide by 0!

First number: 5
Second number: 2
2.5

First number: q
```

`try-except-else`代码块的工作原理大致如下：Python 尝试执行`try`代码块中的代码；只有可能引发异常的代码才需要放在`try`语句中。有时候，有一些仅在`try`代码块成功执行时才需要运行的代码；这些代码应放在`else`代码块中。`except`代码块告诉 Python，如果它尝试运行`try`代码块中的代码时引发了指定的异常，该怎么办。

通过预测可能发生错误的代码，可编写健壮的程序，它们即便面临无效数据或缺少资源，也能继续运行，从而能够抵御无意的用户错误和恶意的攻击。

#### **10.3.5　处理 FileNotFoundError 异常**

使用文件时，一种常见的问题是找不到文件：你要查找的文件可能在其他地方、文件名可能不正确或者这个文件根本就不存在。对于所有这些情形，都可使用`try-except`代码块以直观的方式进行处理。

我们来尝试读取一个不存在的文件。下面的程序尝试读取文件 alice.txt 的内容，但我没有将这个文件存储在 alice.py 所在的目录中：

**alice.py**

```
filename = 'alice.txt'

with open(filename) as f_obj:
    contents = f_obj.read()
```

Python 无法读取不存在的文件，因此它引发一个异常：

```
Traceback (most recent call last):
  File "alice.py", line 3, in <module>
    with open(filename) as f_obj:
FileNotFoundError: [Errno 2] No such file or directory: 'alice.txt'
```

在上述 traceback 中，最后一行报告了`FileNotFoundError`异常，这是 Python 找不到要打开的文件时创建的异常。在这个示例中，这个错误是函数`open()`导致的，因此要处理这个错误，必须将`try`语句放在包含`open()`的代码行之前：

```
filename = 'alice.txt'

try:
    with open(filename) as f_obj:
        contents = f_obj.read()
except FileNotFoundError:
    msg = "Sorry, the file " + filename + " does not exist."
    print(msg)
```

在这个示例中，`try`代码块引发`FileNotFoundError`异常，因此 Python 找出与该错误匹配的`except`代码块，并运行其中的代码。最终的结果是显示一条友好的错误消息，而不是 traceback：

```
Sorry, the file alice.txt does not exist.
```

如果文件不存在，这个程序什么都不做，因此错误处理代码的意义不大。下面来扩展这个示例，看看在你使用多个文件时，异常处理可提供什么样的帮助。

#### **10.3.6　分析文本**

你可以分析包含整本书的文本文件。很多经典文学作品都是以简单文本文件的方式提供的，因为它们不受版权限制。本节使用的文本来自项目 Gutenberg（<http://gutenberg.org/>），这个项目提供了一系列不受版权限制的文学作品，如果你要在编程项目中使用文学文本，这是一个很不错的资源。

下面来提取童话 *Alice in Wonderland* 的文本，并尝试计算它包含多少个单词。我们将使用方法`split()`，它根据一个字符串创建一个单词列表。下面是对只包含童话名`"Alice in Wonderland"`的字符串调用方法`split()`的结果：

```
>>> title = "Alice in Wonderland"
>>> title.split()
['Alice', 'in', 'Wonderland']
```

方法`split()`以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。结果是一个包含字符串中所有单词的列表，虽然有些单词可能包含标点。为计算 *Alice in Wonderland* 包含多少个单词，我们将对整篇小说调用`split()`，再计算得到的列表包含多少个元素，从而确定整篇童话大致包含多少个单词：

```
  filename = 'alice.txt'

  try:
      with open(filename) as f_obj:
          contents = f_obj.read()
  except FileNotFoundError:
      msg = "Sorry, the file " + filename + " does not exist."
      print(msg)
  else:
      # 计算文件大致包含多少个单词
❶     words = contents.split()
❷     num_words = len(words)
❸     print("The file " + filename + " has about " + str(num_words) + " words.")
```

我们把文件 alice.txt 移到了正确的目录中，让`try`代码块能够成功地执行。在❶处，我们对变量`contents`（它现在是一个长长的字符串，包含童话 *Alice in Wonderland* 的全部文本）调用方法`split()`，以生成一个列表，其中包含这部童话中的所有单词。当我们使用`len()`来确定这个列表的长度时，就知道了原始字符串大致包含多少个单词（见❷）。在❸处，我们打印一条消息，指出文件包含多少个单词。这些代码都放在`else`代码块中，因为仅当`try`代码块成功执行时才执行它们。输出指出了文件 alice.txt 包含多少个单词：

```
The file alice.txt has about 29461 words.
```

这个数字有点大，因为这里使用的文本文件包含出版商提供的额外信息，但与童话 *Alice in Wonderland* 的长度相当一致。

#### **10.3.7　使用多个文件**

下面多分析几本书。这样做之前，我们先将这个程序的大部分代码移到一个名为`count_words()`的函数中，这样对多本书进行分析时将更容易：

**word_count.py**

```
  def count_words(filename):
❶     """计算一个文件大致包含多少个单词"""
      try:
          with open(filename) as f_obj:
              contents = f_obj.read()
      except FileNotFoundError:
          msg = "Sorry, the file " + filename + " does not exist."
          print(msg)
      else:
          # 计算文件大致包含多少个单词
          words = contents.split()
          num_words = len(words)
          print("The file " + filename + " has about " + str(num_words) +
              " words.")

  filename = 'alice.txt'
  count_words(filename)
```

这些代码大都与原来一样，我们只是将它们移到了函数`count_words()`中，并增加了缩进量。修改程序的同时更新注释是个不错的习惯，因此我们将注释改成了文档字符串，并稍微调整了一下措辞（见❶）。

现在可以编写一个简单的循环，计算要分析的任何文本包含多少个单词了。为此，我们将要分析的文件的名称存储在一个列表中，然后对列表中的每个文件都调用`count_words()`。我们将尝试计算 *Alice in Wonderland*、*Siddhartha*、*Moby Dick* 和 *Little Women* 分别包含多少个单词，它们都不受版权限制。我故意没有将 siddhartha.txt 放到 word_count.py 所在的目录中，让你能够看到这个程序在文件不存在时处理得有多出色：

```
def count_words(filename):
    --snip--

filenames = ['alice.txt', 'siddhartha.txt', 'moby_dick.txt', 'little_women.txt']
for filename in filenames:
    count_words(filename)
```

文件 siddhartha.txt 不存在，但这丝毫不影响这个程序处理其他文件：

```
The file alice.txt has about 29461 words.
Sorry, the file siddhartha.txt does not exist.
The file moby_dick.txt has about 215136 words.
The file little_women.txt has about 189079 words.
```

在这个示例中，使用`try-except`代码块提供了两个重要的优点：避免让用户看到 traceback；让程序能够继续分析能够找到的其他文件。如果不捕获因找不到 siddhartha.txt 而引发的`FileNotFoundError`异常，用户将看到完整的 traceback，而程序将在尝试分析 *Siddhartha* 后停止运行——根本不分析 *Moby Dick* 和 *Little Women*。

#### **10.3.8　失败时一声不吭**

在前一个示例中，我们告诉用户有一个文件找不到。但并非每次捕获到异常时都需要告诉用户，有时候你希望程序在发生异常时一声不吭，就像什么都没有发生一样继续运行。要让程序在失败时一声不吭，可像通常那样编写`try`代码块，但在`except`代码块中明确地告诉 Python 什么都不要做。Python 有一个`pass`语句，可在代码块中使用它来让 Python 什么都不要做：

```
  def count_words(filename):
      """计算一个文件大致包含多少个单词"""
      try:
          --snip--
      except FileNotFoundError:
❶         pass
      else:
          --snip--

  filenames = ['alice.txt', 'siddhartha.txt', 'moby_dick.txt', 'little_women.txt']
  for filename in filenames:
      count_words(filename)
```

相比于前一个程序，这个程序唯一不同的地方是❶处的`pass`语句。现在，出现`FileNotFoundError`异常时，将执行`except`代码块中的代码，但什么都不会发生。这种错误发生时，不会出现 traceback，也没有任何输出。用户将看到存在的每个文件包含多少个单词，但没有任何迹象表明有一个文件未找到：

```
The file alice.txt has about 29461 words.
The file moby_dick.txt has about 215136 words.
The file little_women.txt has about 189079 words.
```

`pass`语句还充当了占位符，它提醒你在程序的某个地方什么都没有做，并且以后也许要在这里做些什么。例如，在这个程序中，我们可能决定将找不到的文件的名称写入到文件 missing_files.txt 中。用户看不到这个文件，但我们可以读取这个文件，进而处理所有文件找不到的问题。

#### **10.3.9　决定报告哪些错误**

在什么情况下该向用户报告错误？在什么情况下又应该在失败时一声不吭呢？如果用户知道要分析哪些文件，他们可能希望在有文件没有分析时出现一条消息，将其中的原因告诉他们。如果用户只想看到结果，而并不知道要分析哪些文件，可能就无需在有些文件不存在时告知他们。向用户显示他不想看到的信息可能会降低程序的可用性。Python 的错误处理结构让你能够细致地控制与用户分享错误信息的程度，要分享多少信息由你决定。

编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。

> **动手试一试**
>
> **10-6 加法运算**：提示用户提供数值输入时，常出现的一个问题是，用户提供的是文本而不是数字。在这种情况下，当你尝试将输入转换为整数时，将引发`ValueError`异常。编写一个程序，提示用户输入两个数字，再将它们相加并打印结果。在用户输入的任何一个值不是数字时都捕获`ValueError`异常，并打印一条友好的错误消息。对你编写的程序进行测试：先输入两个数字，再输入一些文本而不是数字。
>
> **10-7 加法计算器**：将你为完成练习10-6而编写的代码放在一个`while`循环中，让用户犯错（输入的是文本而不是数字）后能够继续输入数字。
>
> **10-8 猫和狗**：创建两个文件 cats.txt 和 dogs.txt，在第一个文件中至少存储三只猫的名字，在第二个文件中至少存储三条狗的名字。编写一个程序，尝试读取这些文件，并将其内容打印到屏幕上。将这些代码放在一个`try-except`代码块中，以便在文件不存在时捕获`FileNotFound`错误，并打印一条友好的消息。将其中一个文件移到另一个地方，并确认`except`代码块中的代码将正确地执行。
>
> **10-9 沉默的猫和狗**：修改你在练习10-8中编写的`except`代码块，让程序在文件不存在时一言不发。
>
> **10-10 常见单词**：访问项目 Gutenberg（<http://gutenberg.org/>），并找一些你想分析的图书。下载这些作品的文本文件或将浏览器中的原始文本复制到文本文件中。
>
> 你可以使用方法`count()`来确定特定的单词或短语在字符串中出现了多少次。例如，下面的代码计算`'row'`在一个字符串中出现了多少次：

```
>>> line = "Row, row, row your boat"
>>> line.count('row')
2
>>> line.lower().count('row')
3
```

> 请注意，通过使用`lower()`将字符串转换为小写，可捕捉要查找的单词出现的所有次数，而不管其大小写格式如何。
>
> 编写一个程序，它读取你在项目 Gutenberg 中获取的文件，并计算单词`'the'`在每个文件中分别出现了多少次。

### **10.4　存储数据**

很多程序都要求用户输入某种信息，如让用户存储游戏首选项或提供要可视化的数据。不管专注的是什么，程序都把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你几乎总是要保存他们提供的信息；一种简单的方式是使用模块`json`来存储数据。

模块`json`让你能够将简单的 Python 数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用`json`在 Python 程序之间分享数据。更重要的是，JSON 数据格式并非 Python 专用的，这让你能够将以 JSON 格式存储的数据与使用其他编程语言的人分享。这是一种轻便格式，很有用，也易于学习。

> **注意**　
>
> JSON（JavaScript Object Notation）格式最初是为 JavaScript 开发的，但随后成了一种常见格式，被包括 Python 在内的众多语言采用。

#### **10.4.1　使用 json.dump() 和 json.load()**

我们来编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序。第一个程序将使用`json.dump()`来存储这组数字，而第二个程序将使用`json.load()`。

函数`json.dump()`接受两个实参：要存储的数据以及可用于存储数据的文件对象。下面演示了如何使用`json.dump()`来存储数字列表：

**number_writer.py**

```
  import json

  numbers = [2, 3, 5, 7, 11, 13]

❶ filename = 'numbers.json'
❷ with open(filename, 'w') as f_obj:
❸     json.dump(numbers, f_obj)
```

我们先导入模块`json`，再创建一个数字列表。在❶处，我们指定了要将该数字列表存储到其中的文件的名称。通常使用文件扩展名.json 来指出文件存储的数据为 JSON 格式。接下来，我们以写入模式打开这个文件，让`json`能够将数据写入其中（见❷）。在❸处，我们使用函数`json.dump()`将数字列表存储到文件 numbers.json 中。

这个程序没有输出，但我们可以打开文件 numbers.json，看看其内容。数据的存储格式与 Python 中一样：

```
[2, 3, 5, 7, 11, 13]
```

下面再编写一个程序，使用`json.load()`将这个列表读取到内存中：

**number_reader.py**

```
  import json

❶ filename = 'numbers.json'
❷ with open(filename) as f_obj:
❸     numbers = json.load(f_obj)

  print(numbers)
```

在❶处，我们确保读取的是前面写入的文件。这次我们以读取方式打开这个文件，因为 Python 只需读取这个文件（见❷）。在❸处，我们使用函数`json.load()`加载存储在 numbers.json 中的信息，并将其存储到变量`numbers`中。最后，我们打印恢复的数字列表，看看它是否与 number_writer.py 中创建的数字列表相同：

```
[2, 3, 5, 7, 11, 13]
```

这是一种在程序之间共享数据的简单方式。

#### **10.4.2　保存和读取用户生成的数据**

对于用户生成的数据，使用`json`保存它们大有裨益，因为如果不以某种方式进行存储，等程序停止运行时用户的信息将丢失。下面来看一个这样的例子：用户首次运行程序时被提示输入自己的名字，这样再次运行程序时就记住他了。

我们先来存储用户的名字：

**remember_me.py**

```
  import json

❶ username = input("What is your name? ")

  filename = 'username.json'
  with open(filename, 'w') as f_obj:
❷     json.dump(username, f_obj)
❸     print("We'll remember you when you come back, " + username + "!")
```

在❶处，我们提示输入用户名，并将其存储在一个变量中。接下来，我们调用`json.dump()`，并将用户名和一个文件对象传递给它，从而将用户名存储到文件中（见❷）。然后，我们打印一条消息，指出我们存储了他输入的信息（见❸）：

```
What is your name? Eric
We'll remember you when you come back, Eric!
```

现在再编写一个程序，向其名字被存储的用户发出问候：

**greet_user.py**

```
  import json

  filename = 'username.json'

  with open(filename) as f_obj:
❶     username = json.load(f_obj)
❷     print("Welcome back, " + username + "!")
```

在❶处，我们使用`json.load()`将存储在 username.json 中的信息读取到变量`username`中。恢复用户名后，我们就可以欢迎用户回来了（见❷）：

```
Welcome back, Eric!
```

我们需要将这两个程序合并到一个程序（remember_me.py）中。这个程序运行时，我们将尝试从文件 username.json 中获取用户名，因此我们首先编写一个尝试恢复用户名的`try`代码块。如果这个文件不存在，我们就在`except`代码块中提示用户输入用户名，并将其存储在 username.json 中，以便程序再次运行时能够获取它：

**remember_me.py**

```
  import json

  # 如果以前存储了用户名，就加载它
  #  否则，就提示用户输入用户名并存储它
  filename = 'username.json'
  try:
❶     with open(filename) as f_obj:
❷         username = json.load(f_obj)
❸ except FileNotFoundError:
❹     username = input("What is your name? ")
❺     with open(filename, 'w') as f_obj:
          json.dump(username, f_obj)
          print("We'll remember you when you come back, " + username + "!")
  else:
      print("Welcome back, " + username + "!")
```

这里没有任何新代码，只是将前两个示例的代码合并到了一个程序中。在❶处，我们尝试打开文件 username.json。如果这个文件存在，就将其中的用户名读取到内存中（见❷），再执行`else`代码块，即打印一条欢迎用户回来的消息。用户首次运行这个程序时，文件 username.json 不存在，将引发`FileNotFoundError`异常（见❸），因此 Python 将执行`except`代码块：提示用户输入其用户名（见❹），再使用`json.dump()`存储该用户名，并打印一句问候语（见❺）。

无论执行的是`except`代码块还是`else`代码块，都将显示用户名和合适的问候语。如果这个程序是首次运行，输出将如下：

```
What is your name? Eric
We'll remember you when you come back, Eric!
```

否则，输出将如下：

```
Welcome back, Eric!
```

这是程序之前至少运行了一次时的输出。

#### **10.4.3　重构**

你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为一系列完成具体工作的函数。这样的过程被称为**重构**。重构让代码更清晰、更易于理解、更容易扩展。

要重构 remember_me.py，可将其大部分逻辑放到一个或多个函数中。remember_me.py 的重点是问候用户，因此我们将其所有代码都放到一个名为`greet_user()`的函数中：

**remember_me.py**

```
  import json

  def greet_user():
❶     """问候用户，并指出其名字"""
      filename = 'username.json'
      try:
          with open(filename) as f_obj:
              username = json.load(f_obj)
      except FileNotFoundError:
          username = input("What is your name? ")
          with open(filename, 'w') as f_obj:
              json.dump(username, f_obj)
              print("We'll remember you when you come back, " + username + "!")
      else:
          print("Welcome back, " + username + "!")

  greet_user()
```

考虑到现在使用了一个函数，我们删除了注释，转而使用一个文档字符串来指出程序是做什么的（见❶）。这个程序更清晰些，但函数`greet_user()`所做的不仅仅是问候用户，还在存储了用户名时获取它，而在没有存储用户名时提示用户输入一个。

下面来重构`greet_user()`，让它不执行这么多任务。为此，我们首先将获取存储的用户名的代码移到另一个函数中：

```
  import json

  def get_stored_username():
❶     """如果存储了用户名，就获取它"""
      filename = 'username.json'
      try:
          with open(filename) as f_obj:
              username = json.load(f_obj)
      except FileNotFoundError:
❷         return None
      else:
          return username

  def greet_user():
      """问候用户，并指出其名字"""
      username = get_stored_username()
❸     if username:
          print("Welcome back, " + username + "!")
      else:
          username = input("What is your name? ")
          filename = 'username.json'
          with open(filename, 'w') as f_obj:
              json.dump(username, f_obj)
              print("We'll remember you when you come back, " + username + "!")

  greet_user()
```

新增的函数`get_stored_username()`目标明确，❶处的文档字符串指出了这一点。如果存储了用户名，这个函数就获取并返回它；如果文件 username.json 不存在，这个函数就返回`None`（见❷）。这是一种不错的做法：函数要么返回预期的值，要么返回`None`；这让我们能够使用函数的返回值做简单测试。在❸处，如果成功地获取了用户名，就打印一条欢迎用户回来的消息，否则就提示用户输入用户名。

我们还需将`greet_user()`中的另一个代码块提取出来：将没有存储用户名时提示用户输入的代码放在一个独立的函数中：

```
import json

def get_stored_username():
    """如果存储了用户名，就获取它"""
    --snip--

def get_new_username():
    """提示用户输入用户名"""
    username = input("What is your name? ")
    filename = 'username.json'
    with open(filename, 'w') as f_obj:
        json.dump(username, f_obj)
    return username

def greet_user():
    """问候用户，并指出其名字"""
    username = get_stored_username()
    if username:
        print("Welcome back, " + username + "!")
    else:
        username = get_new_username()
        print("We'll remember you when you come back, " + username + "!")

greet_user()
```

在 remember_me.py 的这个最终版本中，每个函数都执行单一而清晰的任务。我们调用`greet_user()`，它打印一条合适的消息：要么欢迎老用户回来，要么问候新用户。为此，它首先调用`get_stored_username()`，这个函数只负责获取存储的用户名（如果存储了的话），再在必要时调用`get_new_username()`，这个函数只负责获取并存储新用户的用户名。要编写出清晰而易于维护和扩展的代码，这种划分工作必不可少。

> **动手试一试**
>
> **10-11 喜欢的数字**：编写一个程序，提示用户输入他喜欢的数字，并使用`json.dump()`将这个数字存储到文件中。再编写一个程序，从文件中读取这个值，并打印消息“I know your favorite number! It's _____.”。
>
> **10-12 记住喜欢的数字**：将练习10-11中的两个程序合而为一。如果存储了用户喜欢的数字，就向用户显示它，否则提示用户输入他喜欢的数字并将其存储到文件中。运行这个程序两次，看看它是否像预期的那样工作。
>
> **10-13 验证用户**：最后一个 remember_me.py 版本假设用户要么已输入其用户名，要么是首次运行该程序。我们应修改这个程序，以应对这样的情形：当前和最后一次运行该程序的用户并非同一个人。
>
> 为此，在`greet_user()`中打印欢迎用户回来的消息前，先询问他用户名是否是对的。如果不对，就调用`get_new_username()`让用户输入正确的用户名。

### **10.5　小结**

在本章中，你学习了：如何使用文件；如何一次性读取整个文件，以及如何以每次一行的方式读取文件的内容；如何写入文件，以及如何将文本附加到文件末尾；什么是异常以及如何处理程序可能引发的异常；如何存储 Python 数据结构，以保存用户提供的信息，避免用户每次运行程序时都需要重新提供。

在第11章中，你将学习高效的代码测试方式，这可帮助你确定代码正确无误，以及发现扩展现有程序时可能引入的 bug。